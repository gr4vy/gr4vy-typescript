/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListTransactionsRequest = {
  /**
   * A pointer to the page of results to return.
   */
  cursor?: string | undefined;
  /**
   * The maximum number of items that are at returned.
   */
  limit?: number | undefined;
  /**
   * Filters the results to only transactions created before this ISO date-time string. The time zone must be included. Ensure that the date-time string is URL encoded, e.g. `2022-01-01T12:00:00+08:00` must be encoded as `2022-01-01T12%3A00%3A00%2B08%3A00`.
   */
  createdAtLte?: Date | undefined;
  /**
   * Filters the results to only transactions created after this ISO date-time string. The time zone must be included. Ensure that the date-time string is URL encoded, e.g. `2022-01-01T12:00:00+08:00` must be encoded as `2022-01-01T12%3A00%3A00%2B08%3A00`.
   */
  createdAtGte?: Date | undefined;
  /**
   * Filters the results to only transactions updated before this ISO date-time string. The time zone must be included. Ensure that the date-time string is URL encoded, e.g. `2022-01-01T12:00:00+08:00` must be encoded as `2022-01-01T12%3A00%3A00%2B08%3A00`.
   */
  updatedAtLte?: Date | undefined;
  /**
   * Filters the results to only transactions updated after this ISO date-time string. The time zone must be included. Ensure that the date-time string is URL encoded, e.g. `2022-01-01T12:00:00+08:00` must be encoded as `2022-01-01T12%3A00%3A00%2B08%3A00`.
   */
  updatedAtGte?: Date | undefined;
  search?: string | undefined;
  buyerExternalIdentifier?: string | undefined;
  buyerId?: string | undefined;
  buyerEmailAddress?: string | undefined;
  /**
   * Filters the results to only the transactions that have a `status` that matches with any of the provided status values.
   */
  status?: Array<components.TransactionStatus> | undefined;
  id?: string | undefined;
  paymentServiceTransactionId?: string | undefined;
  externalIdentifier?: string | undefined;
  /**
   * Filters for transactions where their `metadata` values contain all of the provided `metadata` keys. The value sent for `metadata` must be formatted as a JSON string, and all keys and values must be strings. This value should also be URL encoded.
   */
  metadata?: Array<string> | undefined;
  /**
   * Filters for transactions that have an `amount` that is equal to the provided `amount_eq` value.
   */
  amountEq?: number | undefined;
  /**
   * Filters for transactions that have an `amount` that is less than or equal to the `amount_lte` value.
   */
  amountLte?: number | undefined;
  /**
   * Filters for transactions that have an `amount` that is greater than or equal to the `amount_gte` value.
   */
  amountGte?: number | undefined;
  /**
   * Filters for transactions that have matching `currency` values. The `currency` values provided must be formatted as 3-letter ISO currency code.
   */
  currency?: Array<string> | undefined;
  /**
   * Filters for transactions that were processed by the provided `payment_service_id` values.
   */
  paymentServiceId?: Array<string> | undefined;
  paymentMethodId?: string | undefined;
  paymentMethodLabel?: string | undefined;
  paymentMethodFingerprint?: string | undefined;
  /**
   * Filters for transactions that have matching `method` values.
   */
  method?: Array<components.Method> | undefined;
  /**
   * Filters for transactions where the `error_code` matches one for the provided values.
   */
  errorCode?: Array<string> | undefined;
  /**
   * Filters for trasnactions with refunds.
   */
  hasRefunds?: boolean | undefined;
  /**
   * Filters for transactions with a pending manual anti-fraud review.
   */
  pendingReview?: boolean | undefined;
  /**
   * Filters for transactions where the `checkout_session_id` matches the provided value.
   */
  checkoutSessionId?: string | undefined;
  /**
   * Filters for transactions where the `reconciliation_id` matches the provided value.
   */
  reconciliationId?: string | undefined;
  /**
   * Filters for transactions with gift card redemptions.
   */
  hasGiftCardRedemptions?: boolean | undefined;
  /**
   * Filters for transactions where a gift card used has an `id` that matches the provided value.
   */
  giftCardId?: string | undefined;
  /**
   * Filters for transactions that have at least one gift card redemption where the last 4 digits of its gift card number matches exactly with the provided value.
   */
  giftCardLast4?: string | undefined;
  /**
   * Filters for transactions that have at least one associated settlement record.
   */
  hasSettlements?: boolean | undefined;
  /**
   * Filter for transactions that have a card with a BIN that matches exactly with the provided value.
   */
  paymentMethodBin?: string | undefined;
  /**
   * Filters the results to only the transactions that have a payment source that matches with any of the provided values.
   */
  paymentSource?: Array<components.TransactionPaymentSource> | undefined;
  /**
   * Filters for transactions where the `is_subsequent_payment` matches the provided value.
   */
  isSubsequentPayment?: boolean | undefined;
  /**
   * Filters for transactions where the `merchant_initiated` matches the provided value.
   */
  merchantInitiated?: boolean | undefined;
};

/** @internal */
export const ListTransactionsRequest$inboundSchema: z.ZodType<
  ListTransactionsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  cursor: z.string().optional(),
  limit: z.number().int().default(20),
  created_at_lte: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  created_at_gte: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  updated_at_lte: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  updated_at_gte: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ).optional(),
  search: z.string().optional(),
  buyer_external_identifier: z.string().optional(),
  buyer_id: z.string().optional(),
  buyer_email_address: z.string().optional(),
  status: z.array(components.TransactionStatus$inboundSchema).optional(),
  id: z.string().optional(),
  payment_service_transaction_id: z.string().optional(),
  external_identifier: z.string().optional(),
  metadata: z.array(z.string()).optional(),
  amount_eq: z.number().int().optional(),
  amount_lte: z.number().int().optional(),
  amount_gte: z.number().int().optional(),
  currency: z.array(z.string()).optional(),
  payment_service_id: z.array(z.string()).optional(),
  payment_method_id: z.string().optional(),
  payment_method_label: z.string().optional(),
  payment_method_fingerprint: z.string().optional(),
  method: z.array(components.Method$inboundSchema).optional(),
  error_code: z.array(z.string()).optional(),
  has_refunds: z.boolean().optional(),
  pending_review: z.boolean().optional(),
  checkout_session_id: z.string().optional(),
  reconciliation_id: z.string().optional(),
  has_gift_card_redemptions: z.boolean().optional(),
  gift_card_id: z.string().optional(),
  gift_card_last4: z.string().optional(),
  has_settlements: z.boolean().optional(),
  payment_method_bin: z.string().optional(),
  payment_source: z.array(components.TransactionPaymentSource$inboundSchema)
    .optional(),
  is_subsequent_payment: z.boolean().optional(),
  merchant_initiated: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "created_at_lte": "createdAtLte",
    "created_at_gte": "createdAtGte",
    "updated_at_lte": "updatedAtLte",
    "updated_at_gte": "updatedAtGte",
    "buyer_external_identifier": "buyerExternalIdentifier",
    "buyer_id": "buyerId",
    "buyer_email_address": "buyerEmailAddress",
    "payment_service_transaction_id": "paymentServiceTransactionId",
    "external_identifier": "externalIdentifier",
    "amount_eq": "amountEq",
    "amount_lte": "amountLte",
    "amount_gte": "amountGte",
    "payment_service_id": "paymentServiceId",
    "payment_method_id": "paymentMethodId",
    "payment_method_label": "paymentMethodLabel",
    "payment_method_fingerprint": "paymentMethodFingerprint",
    "error_code": "errorCode",
    "has_refunds": "hasRefunds",
    "pending_review": "pendingReview",
    "checkout_session_id": "checkoutSessionId",
    "reconciliation_id": "reconciliationId",
    "has_gift_card_redemptions": "hasGiftCardRedemptions",
    "gift_card_id": "giftCardId",
    "gift_card_last4": "giftCardLast4",
    "has_settlements": "hasSettlements",
    "payment_method_bin": "paymentMethodBin",
    "payment_source": "paymentSource",
    "is_subsequent_payment": "isSubsequentPayment",
    "merchant_initiated": "merchantInitiated",
  });
});

/** @internal */
export type ListTransactionsRequest$Outbound = {
  cursor?: string | undefined;
  limit: number;
  created_at_lte?: string | undefined;
  created_at_gte?: string | undefined;
  updated_at_lte?: string | undefined;
  updated_at_gte?: string | undefined;
  search?: string | undefined;
  buyer_external_identifier?: string | undefined;
  buyer_id?: string | undefined;
  buyer_email_address?: string | undefined;
  status?: Array<string> | undefined;
  id?: string | undefined;
  payment_service_transaction_id?: string | undefined;
  external_identifier?: string | undefined;
  metadata?: Array<string> | undefined;
  amount_eq?: number | undefined;
  amount_lte?: number | undefined;
  amount_gte?: number | undefined;
  currency?: Array<string> | undefined;
  payment_service_id?: Array<string> | undefined;
  payment_method_id?: string | undefined;
  payment_method_label?: string | undefined;
  payment_method_fingerprint?: string | undefined;
  method?: Array<string> | undefined;
  error_code?: Array<string> | undefined;
  has_refunds?: boolean | undefined;
  pending_review?: boolean | undefined;
  checkout_session_id?: string | undefined;
  reconciliation_id?: string | undefined;
  has_gift_card_redemptions?: boolean | undefined;
  gift_card_id?: string | undefined;
  gift_card_last4?: string | undefined;
  has_settlements?: boolean | undefined;
  payment_method_bin?: string | undefined;
  payment_source?: Array<string> | undefined;
  is_subsequent_payment?: boolean | undefined;
  merchant_initiated?: boolean | undefined;
};

/** @internal */
export const ListTransactionsRequest$outboundSchema: z.ZodType<
  ListTransactionsRequest$Outbound,
  z.ZodTypeDef,
  ListTransactionsRequest
> = z.object({
  cursor: z.string().optional(),
  limit: z.number().int().default(20),
  createdAtLte: z.date().transform(v => v.toISOString()).optional(),
  createdAtGte: z.date().transform(v => v.toISOString()).optional(),
  updatedAtLte: z.date().transform(v => v.toISOString()).optional(),
  updatedAtGte: z.date().transform(v => v.toISOString()).optional(),
  search: z.string().optional(),
  buyerExternalIdentifier: z.string().optional(),
  buyerId: z.string().optional(),
  buyerEmailAddress: z.string().optional(),
  status: z.array(components.TransactionStatus$outboundSchema).optional(),
  id: z.string().optional(),
  paymentServiceTransactionId: z.string().optional(),
  externalIdentifier: z.string().optional(),
  metadata: z.array(z.string()).optional(),
  amountEq: z.number().int().optional(),
  amountLte: z.number().int().optional(),
  amountGte: z.number().int().optional(),
  currency: z.array(z.string()).optional(),
  paymentServiceId: z.array(z.string()).optional(),
  paymentMethodId: z.string().optional(),
  paymentMethodLabel: z.string().optional(),
  paymentMethodFingerprint: z.string().optional(),
  method: z.array(components.Method$outboundSchema).optional(),
  errorCode: z.array(z.string()).optional(),
  hasRefunds: z.boolean().optional(),
  pendingReview: z.boolean().optional(),
  checkoutSessionId: z.string().optional(),
  reconciliationId: z.string().optional(),
  hasGiftCardRedemptions: z.boolean().optional(),
  giftCardId: z.string().optional(),
  giftCardLast4: z.string().optional(),
  hasSettlements: z.boolean().optional(),
  paymentMethodBin: z.string().optional(),
  paymentSource: z.array(components.TransactionPaymentSource$outboundSchema)
    .optional(),
  isSubsequentPayment: z.boolean().optional(),
  merchantInitiated: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    createdAtLte: "created_at_lte",
    createdAtGte: "created_at_gte",
    updatedAtLte: "updated_at_lte",
    updatedAtGte: "updated_at_gte",
    buyerExternalIdentifier: "buyer_external_identifier",
    buyerId: "buyer_id",
    buyerEmailAddress: "buyer_email_address",
    paymentServiceTransactionId: "payment_service_transaction_id",
    externalIdentifier: "external_identifier",
    amountEq: "amount_eq",
    amountLte: "amount_lte",
    amountGte: "amount_gte",
    paymentServiceId: "payment_service_id",
    paymentMethodId: "payment_method_id",
    paymentMethodLabel: "payment_method_label",
    paymentMethodFingerprint: "payment_method_fingerprint",
    errorCode: "error_code",
    hasRefunds: "has_refunds",
    pendingReview: "pending_review",
    checkoutSessionId: "checkout_session_id",
    reconciliationId: "reconciliation_id",
    hasGiftCardRedemptions: "has_gift_card_redemptions",
    giftCardId: "gift_card_id",
    giftCardLast4: "gift_card_last4",
    hasSettlements: "has_settlements",
    paymentMethodBin: "payment_method_bin",
    paymentSource: "payment_source",
    isSubsequentPayment: "is_subsequent_payment",
    merchantInitiated: "merchant_initiated",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListTransactionsRequest$ {
  /** @deprecated use `ListTransactionsRequest$inboundSchema` instead. */
  export const inboundSchema = ListTransactionsRequest$inboundSchema;
  /** @deprecated use `ListTransactionsRequest$outboundSchema` instead. */
  export const outboundSchema = ListTransactionsRequest$outboundSchema;
  /** @deprecated use `ListTransactionsRequest$Outbound` instead. */
  export type Outbound = ListTransactionsRequest$Outbound;
}

export function listTransactionsRequestToJSON(
  listTransactionsRequest: ListTransactionsRequest,
): string {
  return JSON.stringify(
    ListTransactionsRequest$outboundSchema.parse(listTransactionsRequest),
  );
}

export function listTransactionsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListTransactionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListTransactionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListTransactionsRequest' from JSON`,
  );
}
