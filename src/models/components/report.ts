/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { ReportSpec, ReportSpec$ } from "./reportspec";
import * as z from "zod";

/**
 * The type of this resource. Is always `report`.
 */
export enum ReportType {
    Report = "report",
}

/**
 * The type of the creator of this report.
 */
export enum CreatorType {
    User = "user",
    PrivateKey = "private_key",
}

/**
 * Specifies the schedule of this report.
 *
 * @remarks
 *
 * If this is a one-off report, this value is `once`.
 *
 * If this is a recurring report, this value is set to the
 * frequency by which the report will be executed. For example, a
 * `monthly` schedule means that this report will be periodically
 * executed at the start of each month.
 *
 * Note that a `weekly` schedule means that the report is executed
 * at the start of every Monday.
 */
export enum ReportSchedule {
    Daily = "daily",
    Monthly = "monthly",
    Once = "once",
    Weekly = "weekly",
}

/**
 * The type of this resource. Is always `report-execution`.
 */
export enum ReportLatestExecutionType {
    ReportExecution = "report-execution",
}

/**
 * The status of this report execution.
 */
export enum ReportStatus {
    Dispatched = "dispatched",
    Failed = "failed",
    Pending = "pending",
    Processing = "processing",
    Succeeded = "succeeded",
}

/**
 * Contains the context values used to compute the value of date-time
 *
 * @remarks
 * placeholders such as `month_start` and `month_end` if present in
 * the report's specification. Date-time placeholders are dynamic
 * timestamps that change with every report execution.
 */
export type ReportContext = {
    /**
     * The date and time used by the system as a reference point to
     *
     * @remarks
     * compute date-time placeholders.
     */
    referenceTimestamp?: Date | undefined;
    /**
     * The time zone used to compute date-time placeholders.
     */
    referenceTimezone?: string | undefined;
};

/**
 * Details of the latest execution of this report.
 */
export type ReportExecutionSummary = {
    /**
     * The type of this resource. Is always `report-execution`.
     */
    type?: ReportLatestExecutionType | undefined;
    /**
     * The unique identifier for this report execution.
     */
    id?: string | undefined;
    /**
     * The date and time this report execution was created in our system.
     */
    createdAt?: Date | undefined;
    /**
     * The date and time this report execution was last updated.
     */
    updatedAt?: Date | undefined;
    /**
     * The status of this report execution.
     */
    status?: ReportStatus | undefined;
    /**
     * Contains the context values used to compute the value of date-time
     *
     * @remarks
     * placeholders such as `month_start` and `month_end` if present in
     * the report's specification. Date-time placeholders are dynamic
     * timestamps that change with every report execution.
     */
    context?: ReportContext | undefined;
};

/**
 * A report record.
 */
export type Report = {
    /**
     * The type of this resource. Is always `report`.
     */
    type?: ReportType | undefined;
    /**
     * The unique identifier for this report.
     */
    id?: string | undefined;
    /**
     * The unique ID for a merchant account.
     */
    merchantAccountId?: string | undefined;
    /**
     * The name of this report.
     */
    name?: string | undefined;
    /**
     * The unique identifier for the creator of this report.
     */
    creatorId?: string | null | undefined;
    /**
     * The name of the creator of this report.
     */
    creatorDisplayName?: string | null | undefined;
    /**
     * The type of the creator of this report.
     */
    creatorType?: CreatorType | null | undefined;
    /**
     * The date and time this report was created in our system.
     */
    createdAt?: Date | undefined;
    /**
     * The date and time this report was last updated.
     */
    updatedAt?: Date | undefined;
    /**
     * The date and time this report will next be executed, provided
     *
     * @remarks
     * that `schedule_enabled` is `true`. This value is null if this
     * is a one-off report.
     */
    nextExecutionAt?: Date | null | undefined;
    /**
     * The description of this report.
     */
    description?: string | null | undefined;
    /**
     * Specifies the schedule of this report.
     *
     * @remarks
     *
     * If this is a one-off report, this value is `once`.
     *
     * If this is a recurring report, this value is set to the
     * frequency by which the report will be executed. For example, a
     * `monthly` schedule means that this report will be periodically
     * executed at the start of each month.
     *
     * Note that a `weekly` schedule means that the report is executed
     * at the start of every Monday.
     */
    schedule?: ReportSchedule | undefined;
    /**
     * Indicates whether this report's scheduling is enabled. This value
     *
     * @remarks
     * can only be set to `true` if this is a recurring report.
     *
     * When this value is set to `true`, this report will be executed at
     * the `next_execution_at` date and time.
     *
     * When this value is set to `false`, future executions of this
     * report are paused until this value is set to `true` again.
     */
    scheduleEnabled?: boolean | undefined;
    /**
     * The time zone in which the next execution will be scheduled. This
     *
     * @remarks
     * value is used to calculate this report's `next_execution_at` value
     * and is only relevant if this is a recurring report. This time zone
     * is also used to calculate the timestamp range for reports that use
     * date-time placeholders. Date-time placeholders are dynamic
     * timestamps that change with every report execution.
     */
    scheduleTimezone?: string | undefined;
    /**
     * The specifications of this report.
     */
    spec?: ReportSpec | undefined;
    /**
     * Details of the latest execution of this report.
     */
    latestExecution?: ReportExecutionSummary | null | undefined;
};

/** @internal */
export namespace ReportType$ {
    export const inboundSchema = z.nativeEnum(ReportType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreatorType$ {
    export const inboundSchema = z.nativeEnum(CreatorType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ReportSchedule$ {
    export const inboundSchema = z.nativeEnum(ReportSchedule);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ReportLatestExecutionType$ {
    export const inboundSchema = z.nativeEnum(ReportLatestExecutionType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ReportStatus$ {
    export const inboundSchema = z.nativeEnum(ReportStatus);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ReportContext$ {
    export const inboundSchema: z.ZodType<ReportContext, z.ZodTypeDef, unknown> = z
        .object({
            reference_timestamp: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            reference_timezone: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                reference_timestamp: "referenceTimestamp",
                reference_timezone: "referenceTimezone",
            });
        });

    export type Outbound = {
        reference_timestamp?: string | undefined;
        reference_timezone?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ReportContext> = z
        .object({
            referenceTimestamp: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            referenceTimezone: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                referenceTimestamp: "reference_timestamp",
                referenceTimezone: "reference_timezone",
            });
        });
}

/** @internal */
export namespace ReportExecutionSummary$ {
    export const inboundSchema: z.ZodType<ReportExecutionSummary, z.ZodTypeDef, unknown> = z
        .object({
            type: ReportLatestExecutionType$.inboundSchema.optional(),
            id: z.string().optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            updated_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            status: ReportStatus$.inboundSchema.optional(),
            context: z.lazy(() => ReportContext$.inboundSchema).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                created_at: "createdAt",
                updated_at: "updatedAt",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        created_at?: string | undefined;
        updated_at?: string | undefined;
        status?: string | undefined;
        context?: ReportContext$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ReportExecutionSummary> = z
        .object({
            type: ReportLatestExecutionType$.outboundSchema.optional(),
            id: z.string().optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            updatedAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            status: ReportStatus$.outboundSchema.optional(),
            context: z.lazy(() => ReportContext$.outboundSchema).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                createdAt: "created_at",
                updatedAt: "updated_at",
            });
        });
}

/** @internal */
export namespace Report$ {
    export const inboundSchema: z.ZodType<Report, z.ZodTypeDef, unknown> = z
        .object({
            type: ReportType$.inboundSchema.optional(),
            id: z.string().optional(),
            merchant_account_id: z.string().optional(),
            name: z.string().optional(),
            creator_id: z.nullable(z.string()).optional(),
            creator_display_name: z.nullable(z.string()).optional(),
            creator_type: z.nullable(CreatorType$.inboundSchema).optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            updated_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            next_execution_at: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
            description: z.nullable(z.string()).optional(),
            schedule: ReportSchedule$.inboundSchema.optional(),
            schedule_enabled: z.boolean().optional(),
            schedule_timezone: z.string().optional(),
            spec: ReportSpec$.inboundSchema.optional(),
            latest_execution: z
                .nullable(z.lazy(() => ReportExecutionSummary$.inboundSchema))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                merchant_account_id: "merchantAccountId",
                creator_id: "creatorId",
                creator_display_name: "creatorDisplayName",
                creator_type: "creatorType",
                created_at: "createdAt",
                updated_at: "updatedAt",
                next_execution_at: "nextExecutionAt",
                schedule_enabled: "scheduleEnabled",
                schedule_timezone: "scheduleTimezone",
                latest_execution: "latestExecution",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        merchant_account_id?: string | undefined;
        name?: string | undefined;
        creator_id?: string | null | undefined;
        creator_display_name?: string | null | undefined;
        creator_type?: string | null | undefined;
        created_at?: string | undefined;
        updated_at?: string | undefined;
        next_execution_at?: string | null | undefined;
        description?: string | null | undefined;
        schedule?: string | undefined;
        schedule_enabled?: boolean | undefined;
        schedule_timezone?: string | undefined;
        spec?: ReportSpec$.Outbound | undefined;
        latest_execution?: ReportExecutionSummary$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Report> = z
        .object({
            type: ReportType$.outboundSchema.optional(),
            id: z.string().optional(),
            merchantAccountId: z.string().optional(),
            name: z.string().optional(),
            creatorId: z.nullable(z.string()).optional(),
            creatorDisplayName: z.nullable(z.string()).optional(),
            creatorType: z.nullable(CreatorType$.outboundSchema).optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            updatedAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            nextExecutionAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            description: z.nullable(z.string()).optional(),
            schedule: ReportSchedule$.outboundSchema.optional(),
            scheduleEnabled: z.boolean().optional(),
            scheduleTimezone: z.string().optional(),
            spec: ReportSpec$.outboundSchema.optional(),
            latestExecution: z
                .nullable(z.lazy(() => ReportExecutionSummary$.outboundSchema))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                merchantAccountId: "merchant_account_id",
                creatorId: "creator_id",
                creatorDisplayName: "creator_display_name",
                creatorType: "creator_type",
                createdAt: "created_at",
                updatedAt: "updated_at",
                nextExecutionAt: "next_execution_at",
                scheduleEnabled: "schedule_enabled",
                scheduleTimezone: "schedule_timezone",
                latestExecution: "latest_execution",
            });
        });
}
