/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { PaymentOptionApprovalUI, PaymentOptionApprovalUI$ } from "./paymentoptionapprovalui";
import { RequiredFields, RequiredFields$ } from "./requiredfields";
import * as z from "zod";

/**
 * `payment-option`.
 */
export enum PaymentOptionType {
    PaymentOption = "payment-option",
}

/**
 * The type of payment method that is available.
 */
export enum PaymentOptionMethod {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Everydaypay = "everydaypay",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    NetworkToken = "network-token",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * The mode to use with this payment option.
 */
export enum PaymentOptionMode {
    Card = "card",
    Redirect = "redirect",
    Applepay = "applepay",
    Googlepay = "googlepay",
}

/**
 * Additional context specific to the payment option.
 *
 * @remarks
 * This is currently only returned for Apple Pay and Google Pay.
 */
export type Context = {
    /**
     * Gateway used for Google Pay payments.
     */
    gateway?: string | undefined;
    /**
     * Gateway merchant identifier used for Google Pay payments.
     */
    gatewayMerchantId?: string | undefined;
    /**
     * Display name of the merchant as registered with the digital wallet
     *
     * @remarks
     * provider.
     */
    merchantName?: string | undefined;
    /**
     * Card schemes supported by the digital wallet provider.
     */
    supportedSchemes?: Array<string> | undefined;
    /**
     * Configuration for the approval interface that should be shown to the buyer.
     */
    approvalUi?: PaymentOptionApprovalUI | undefined;
    /**
     * The fields that are required to process a transaction for this payment option.
     */
    requiredFields?: RequiredFields | undefined;
};

/**
 * An available payment option for a locale.
 */
export type PaymentOption = {
    /**
     * `payment-option`.
     */
    type?: PaymentOptionType | undefined;
    /**
     * The type of payment method that is available.
     */
    method?: PaymentOptionMethod | undefined;
    /**
     * An icon to display for the payment option.
     */
    iconUrl?: string | null | undefined;
    /**
     * The mode to use with this payment option.
     */
    mode?: PaymentOptionMode | undefined;
    /**
     * A label that describes this payment option. This label is returned in the
     *
     * @remarks
     * language defined by the `locale` query parameter. The label can be used
     * to display a list of payment options to the buyer in their language.
     */
    label?: string | undefined;
    /**
     * A flag to indicate if storing the payment method is supported.
     */
    canStorePaymentMethod?: boolean | undefined;
    /**
     * A flag to indicate if delayed capture is supported.
     */
    canDelayCapture?: boolean | undefined;
    /**
     * Additional context specific to the payment option.
     *
     * @remarks
     * This is currently only returned for Apple Pay and Google Pay.
     */
    context?: Context | undefined;
};

/** @internal */
export namespace PaymentOptionType$ {
    export const inboundSchema = z.nativeEnum(PaymentOptionType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentOptionMethod$ {
    export const inboundSchema = z.nativeEnum(PaymentOptionMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentOptionMode$ {
    export const inboundSchema = z.nativeEnum(PaymentOptionMode);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Context$ {
    export const inboundSchema: z.ZodType<Context, z.ZodTypeDef, unknown> = z
        .object({
            gateway: z.string().optional(),
            gateway_merchant_id: z.string().optional(),
            merchant_name: z.string().optional(),
            supported_schemes: z.array(z.string()).optional(),
            approval_ui: PaymentOptionApprovalUI$.inboundSchema.optional(),
            required_fields: RequiredFields$.inboundSchema.optional(),
        })
        .transform((v) => {
            return remap$(v, {
                gateway_merchant_id: "gatewayMerchantId",
                merchant_name: "merchantName",
                supported_schemes: "supportedSchemes",
                approval_ui: "approvalUi",
                required_fields: "requiredFields",
            });
        });

    export type Outbound = {
        gateway?: string | undefined;
        gateway_merchant_id?: string | undefined;
        merchant_name?: string | undefined;
        supported_schemes?: Array<string> | undefined;
        approval_ui?: PaymentOptionApprovalUI$.Outbound | undefined;
        required_fields?: RequiredFields$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Context> = z
        .object({
            gateway: z.string().optional(),
            gatewayMerchantId: z.string().optional(),
            merchantName: z.string().optional(),
            supportedSchemes: z.array(z.string()).optional(),
            approvalUi: PaymentOptionApprovalUI$.outboundSchema.optional(),
            requiredFields: RequiredFields$.outboundSchema.optional(),
        })
        .transform((v) => {
            return remap$(v, {
                gatewayMerchantId: "gateway_merchant_id",
                merchantName: "merchant_name",
                supportedSchemes: "supported_schemes",
                approvalUi: "approval_ui",
                requiredFields: "required_fields",
            });
        });
}

/** @internal */
export namespace PaymentOption$ {
    export const inboundSchema: z.ZodType<PaymentOption, z.ZodTypeDef, unknown> = z
        .object({
            type: PaymentOptionType$.inboundSchema.optional(),
            method: PaymentOptionMethod$.inboundSchema.optional(),
            icon_url: z.nullable(z.string()).optional(),
            mode: PaymentOptionMode$.inboundSchema.optional(),
            label: z.string().optional(),
            can_store_payment_method: z.boolean().optional(),
            can_delay_capture: z.boolean().optional(),
            context: z.lazy(() => Context$.inboundSchema).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                icon_url: "iconUrl",
                can_store_payment_method: "canStorePaymentMethod",
                can_delay_capture: "canDelayCapture",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        method?: string | undefined;
        icon_url?: string | null | undefined;
        mode?: string | undefined;
        label?: string | undefined;
        can_store_payment_method?: boolean | undefined;
        can_delay_capture?: boolean | undefined;
        context?: Context$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentOption> = z
        .object({
            type: PaymentOptionType$.outboundSchema.optional(),
            method: PaymentOptionMethod$.outboundSchema.optional(),
            iconUrl: z.nullable(z.string()).optional(),
            mode: PaymentOptionMode$.outboundSchema.optional(),
            label: z.string().optional(),
            canStorePaymentMethod: z.boolean().optional(),
            canDelayCapture: z.boolean().optional(),
            context: z.lazy(() => Context$.outboundSchema).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                iconUrl: "icon_url",
                canStorePaymentMethod: "can_store_payment_method",
                canDelayCapture: "can_delay_capture",
            });
        });
}
