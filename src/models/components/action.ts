/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import * as z from "zod";

/**
 * The type of this resource. Is always `action`.
 */
export enum ActionType {
    Action = "action",
}

/**
 * The identifier for the action.
 */
export enum Id {
    DeclineEarly = "decline-early",
    RouteTransaction = "route-transaction",
    Skip3ds = "skip-3ds",
}

/**
 * The name of the Flow.
 */
export enum Flow {
    Checkout = "checkout",
    CardTransaction = "card-transaction",
    NonCardTransaction = "non-card-transaction",
    RedirectTransaction = "redirect-transaction",
}

/**
 * The type of action outcome for the given rule.
 */
export enum FlowRuleUUIDsListOutcomeOutcomeType {
    List = "list",
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a list of UUIDs.
 *
 * Depending on the flow and action where this outcome is used, the UUIDs
 * may have an important meaning like the ID of a payment service to be
 * used (this is the case for `redirect-transaction` flow and
 * `route-transaction` action).
 */
export type UUIDsListOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: FlowRuleUUIDsListOutcomeOutcomeType;
    /**
     * Results for a given flow action.
     */
    result: Array<string>;
};

/**
 * The type of action outcome for the given rule.
 */
export enum FlowRuleServiceOutcomeOutcomeType {
    CardRouting = "card-routing",
}

/**
 * The name of the instrument to be used to process the transaction.
 *
 * @remarks
 * For `pan`, if a Payment Service token is available, the API will use that
 * for stored payment methods.
 *
 */
export enum OutcomeInstrument {
    NetworkToken = "network_token",
    Pan = "pan",
}

/**
 * Name of the transformation.
 */
export enum OutcomeName {
    ForceMit = "force_mit",
    UseAdditionalScheme = "use_additional_scheme",
}

export type OutcomeTransformations = {
    /**
     * Name of the transformation.
     */
    name?: OutcomeName | undefined;
};

export type OutcomeResult = {
    /**
     * ID of the payment service to be used when processing the transaction.
     */
    paymentServiceId?: string | undefined;
    /**
     * The name of the instrument to be used to process the transaction.
     *
     * @remarks
     * For `pan`, if a Payment Service token is available, the API will use that
     * for stored payment methods.
     *
     */
    instrument?: OutcomeInstrument | undefined;
    /**
     * List of transformations to apply when processing the transaction.
     */
    transformations?: Array<OutcomeTransformations> | undefined;
};

/**
 * Version of the rule outcome. Current version is `2`.
 */
export enum OutcomeVersion {
    Two = 2,
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a list of dictionaries that define the payment service,
 * instrument and transformation to be used to process a
 * transaction.
 */
export type PaymentServiceOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: FlowRuleServiceOutcomeOutcomeType;
    /**
     * Results for a given flow action.
     */
    result: Array<OutcomeResult>;
    /**
     * Version of the rule outcome. Current version is `2`.
     */
    version: OutcomeVersion;
};

/**
 * The type of action outcome for the given rule.
 */
export enum FlowRuleMethodOutcomeOutcomeType {
    List = "list",
}

export enum FlowRuleMethodOutcomeOutcomeResult {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Everydaypay = "everydaypay",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    NetworkToken = "network-token",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a list of payment types.
 */
export type PaymentMethodOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: FlowRuleMethodOutcomeOutcomeType;
    /**
     * Results for a given flow action.
     */
    result: Array<FlowRuleMethodOutcomeOutcomeResult>;
};

/**
 * The type of action outcome for the given rule.
 */
export enum OutcomeType {
    Boolean = "boolean",
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a boolean.
 */
export type BooleanOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: OutcomeType;
    /**
     * Results for a given flow action.
     */
    result: boolean;
};

/**
 * The outcome of the action.
 */
export type Outcome =
    | BooleanOutcome
    | PaymentMethodOutcome
    | UUIDsListOutcome
    | PaymentServiceOutcome;

/**
 * An action taken for a transaction.
 */
export type Action = {
    /**
     * The type of this resource. Is always `action`.
     */
    type?: ActionType | undefined;
    /**
     * The identifier for the action.
     */
    id?: Id | undefined;
    /**
     * The name of the Flow.
     */
    flow?: Flow | undefined;
    /**
     * The unique ID of the rule triggered.
     */
    ruleId?: string | undefined;
    /**
     * The date and time when this action was created.
     */
    createdAt?: Date | undefined;
    /**
     * The outcome of the action.
     */
    outcome?:
        | BooleanOutcome
        | PaymentMethodOutcome
        | UUIDsListOutcome
        | PaymentServiceOutcome
        | null
        | undefined;
};

/** @internal */
export namespace ActionType$ {
    export const inboundSchema = z.nativeEnum(ActionType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Id$ {
    export const inboundSchema = z.nativeEnum(Id);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Flow$ {
    export const inboundSchema = z.nativeEnum(Flow);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace FlowRuleUUIDsListOutcomeOutcomeType$ {
    export const inboundSchema = z.nativeEnum(FlowRuleUUIDsListOutcomeOutcomeType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace UUIDsListOutcome$ {
    export const inboundSchema: z.ZodType<UUIDsListOutcome, z.ZodTypeDef, unknown> = z.object({
        type: FlowRuleUUIDsListOutcomeOutcomeType$.inboundSchema,
        result: z.array(z.string()),
    });

    export type Outbound = {
        type: string;
        result: Array<string>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UUIDsListOutcome> = z.object({
        type: FlowRuleUUIDsListOutcomeOutcomeType$.outboundSchema,
        result: z.array(z.string()),
    });
}

/** @internal */
export namespace FlowRuleServiceOutcomeOutcomeType$ {
    export const inboundSchema = z.nativeEnum(FlowRuleServiceOutcomeOutcomeType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace OutcomeInstrument$ {
    export const inboundSchema = z.nativeEnum(OutcomeInstrument);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace OutcomeName$ {
    export const inboundSchema = z.nativeEnum(OutcomeName);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace OutcomeTransformations$ {
    export const inboundSchema: z.ZodType<OutcomeTransformations, z.ZodTypeDef, unknown> = z.object(
        {
            name: OutcomeName$.inboundSchema.optional(),
        }
    );

    export type Outbound = {
        name?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, OutcomeTransformations> =
        z.object({
            name: OutcomeName$.outboundSchema.optional(),
        });
}

/** @internal */
export namespace OutcomeResult$ {
    export const inboundSchema: z.ZodType<OutcomeResult, z.ZodTypeDef, unknown> = z
        .object({
            payment_service_id: z.string().optional(),
            instrument: OutcomeInstrument$.inboundSchema.optional(),
            transformations: z
                .array(z.lazy(() => OutcomeTransformations$.inboundSchema))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                payment_service_id: "paymentServiceId",
            });
        });

    export type Outbound = {
        payment_service_id?: string | undefined;
        instrument?: string | undefined;
        transformations?: Array<OutcomeTransformations$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, OutcomeResult> = z
        .object({
            paymentServiceId: z.string().optional(),
            instrument: OutcomeInstrument$.outboundSchema.optional(),
            transformations: z
                .array(z.lazy(() => OutcomeTransformations$.outboundSchema))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                paymentServiceId: "payment_service_id",
            });
        });
}

/** @internal */
export namespace OutcomeVersion$ {
    export const inboundSchema = z.nativeEnum(OutcomeVersion);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentServiceOutcome$ {
    export const inboundSchema: z.ZodType<PaymentServiceOutcome, z.ZodTypeDef, unknown> = z.object({
        type: FlowRuleServiceOutcomeOutcomeType$.inboundSchema,
        result: z.array(z.lazy(() => OutcomeResult$.inboundSchema)),
        version: OutcomeVersion$.inboundSchema,
    });

    export type Outbound = {
        type: string;
        result: Array<OutcomeResult$.Outbound>;
        version: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentServiceOutcome> =
        z.object({
            type: FlowRuleServiceOutcomeOutcomeType$.outboundSchema,
            result: z.array(z.lazy(() => OutcomeResult$.outboundSchema)),
            version: OutcomeVersion$.outboundSchema,
        });
}

/** @internal */
export namespace FlowRuleMethodOutcomeOutcomeType$ {
    export const inboundSchema = z.nativeEnum(FlowRuleMethodOutcomeOutcomeType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace FlowRuleMethodOutcomeOutcomeResult$ {
    export const inboundSchema = z.nativeEnum(FlowRuleMethodOutcomeOutcomeResult);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodOutcome$ {
    export const inboundSchema: z.ZodType<PaymentMethodOutcome, z.ZodTypeDef, unknown> = z.object({
        type: FlowRuleMethodOutcomeOutcomeType$.inboundSchema,
        result: z.array(FlowRuleMethodOutcomeOutcomeResult$.inboundSchema),
    });

    export type Outbound = {
        type: string;
        result: Array<string>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodOutcome> = z.object(
        {
            type: FlowRuleMethodOutcomeOutcomeType$.outboundSchema,
            result: z.array(FlowRuleMethodOutcomeOutcomeResult$.outboundSchema),
        }
    );
}

/** @internal */
export namespace OutcomeType$ {
    export const inboundSchema = z.nativeEnum(OutcomeType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace BooleanOutcome$ {
    export const inboundSchema: z.ZodType<BooleanOutcome, z.ZodTypeDef, unknown> = z.object({
        type: OutcomeType$.inboundSchema,
        result: z.boolean(),
    });

    export type Outbound = {
        type: string;
        result: boolean;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BooleanOutcome> = z.object({
        type: OutcomeType$.outboundSchema,
        result: z.boolean(),
    });
}

/** @internal */
export namespace Outcome$ {
    export const inboundSchema: z.ZodType<Outcome, z.ZodTypeDef, unknown> = z.union([
        z.lazy(() => BooleanOutcome$.inboundSchema),
        z.lazy(() => PaymentMethodOutcome$.inboundSchema),
        z.lazy(() => UUIDsListOutcome$.inboundSchema),
        z.lazy(() => PaymentServiceOutcome$.inboundSchema),
    ]);

    export type Outbound =
        | BooleanOutcome$.Outbound
        | PaymentMethodOutcome$.Outbound
        | UUIDsListOutcome$.Outbound
        | PaymentServiceOutcome$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Outcome> = z.union([
        z.lazy(() => BooleanOutcome$.outboundSchema),
        z.lazy(() => PaymentMethodOutcome$.outboundSchema),
        z.lazy(() => UUIDsListOutcome$.outboundSchema),
        z.lazy(() => PaymentServiceOutcome$.outboundSchema),
    ]);
}

/** @internal */
export namespace Action$ {
    export const inboundSchema: z.ZodType<Action, z.ZodTypeDef, unknown> = z
        .object({
            type: ActionType$.inboundSchema.optional(),
            id: Id$.inboundSchema.optional(),
            flow: Flow$.inboundSchema.optional(),
            rule_id: z.string().optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            outcome: z
                .nullable(
                    z.union([
                        z.lazy(() => BooleanOutcome$.inboundSchema),
                        z.lazy(() => PaymentMethodOutcome$.inboundSchema),
                        z.lazy(() => UUIDsListOutcome$.inboundSchema),
                        z.lazy(() => PaymentServiceOutcome$.inboundSchema),
                    ])
                )
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                rule_id: "ruleId",
                created_at: "createdAt",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        flow?: string | undefined;
        rule_id?: string | undefined;
        created_at?: string | undefined;
        outcome?:
            | BooleanOutcome$.Outbound
            | PaymentMethodOutcome$.Outbound
            | UUIDsListOutcome$.Outbound
            | PaymentServiceOutcome$.Outbound
            | null
            | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Action> = z
        .object({
            type: ActionType$.outboundSchema.optional(),
            id: Id$.outboundSchema.optional(),
            flow: Flow$.outboundSchema.optional(),
            ruleId: z.string().optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            outcome: z
                .nullable(
                    z.union([
                        z.lazy(() => BooleanOutcome$.outboundSchema),
                        z.lazy(() => PaymentMethodOutcome$.outboundSchema),
                        z.lazy(() => UUIDsListOutcome$.outboundSchema),
                        z.lazy(() => PaymentServiceOutcome$.outboundSchema),
                    ])
                )
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                ruleId: "rule_id",
                createdAt: "created_at",
            });
        });
}
