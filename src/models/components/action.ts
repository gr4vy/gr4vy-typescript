/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as z from "zod";

/**
 * The type of this resource. Is always `action`.
 */
export enum ActionType {
    Action = "action",
}

/**
 * The identifier for the action.
 */
export enum Id {
    DeclineEarly = "decline-early",
    RouteTransaction = "route-transaction",
    Skip3ds = "skip-3ds",
}

/**
 * The name of the Flow.
 */
export enum Flow {
    Checkout = "checkout",
    CardTransaction = "card-transaction",
    NonCardTransaction = "non-card-transaction",
    RedirectTransaction = "redirect-transaction",
}

/**
 * The type of action outcome for the given rule.
 */
export enum FlowRuleUUIDsListOutcomeOutcomeType {
    List = "list",
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a list of UUIDs.
 *
 * Depending on the flow and action where this outcome is used, the UUIDs
 * may have an important meaning like the ID of a payment service to be
 * used (this is the case for `redirect-transaction` flow and
 * `route-transaction` action).
 */
export type UUIDsListOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: FlowRuleUUIDsListOutcomeOutcomeType;
    /**
     * Results for a given flow action.
     */
    result: Array<string>;
};

/**
 * The type of action outcome for the given rule.
 */
export enum FlowRuleServiceOutcomeOutcomeType {
    CardRouting = "card-routing",
}

/**
 * The name of the instrument to be used to process the transaction.
 *
 * @remarks
 * For `pan`, if a Payment Service token is available, the API will use that
 * for stored payment methods.
 *
 */
export enum OutcomeInstrument {
    NetworkToken = "network_token",
    Pan = "pan",
}

/**
 * Name of the transformation.
 */
export enum OutcomeName {
    ForceMit = "force_mit",
    UseAdditionalScheme = "use_additional_scheme",
}

export type OutcomeTransformations = {
    /**
     * Name of the transformation.
     */
    name?: OutcomeName | undefined;
};

export type OutcomeResult = {
    /**
     * ID of the payment service to be used when processing the transaction.
     */
    paymentServiceId?: string | undefined;
    /**
     * The name of the instrument to be used to process the transaction.
     *
     * @remarks
     * For `pan`, if a Payment Service token is available, the API will use that
     * for stored payment methods.
     *
     */
    instrument?: OutcomeInstrument | undefined;
    /**
     * List of transformations to apply when processing the transaction.
     */
    transformations?: Array<OutcomeTransformations> | undefined;
};

/**
 * Version of the rule outcome. Current version is `2`.
 */
export enum OutcomeVersion {
    Two = 2,
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a list of dictionaries that define the payment service,
 * instrument and transformation to be used to process a
 * transaction.
 */
export type PaymentServiceOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: FlowRuleServiceOutcomeOutcomeType;
    /**
     * Results for a given flow action.
     */
    result: Array<OutcomeResult>;
    /**
     * Version of the rule outcome. Current version is `2`.
     */
    version: OutcomeVersion;
};

/**
 * The type of action outcome for the given rule.
 */
export enum FlowRuleMethodOutcomeOutcomeType {
    List = "list",
}

export enum FlowRuleMethodOutcomeOutcomeResult {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a list of payment types.
 */
export type PaymentMethodOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: FlowRuleMethodOutcomeOutcomeType;
    /**
     * Results for a given flow action.
     */
    result: Array<FlowRuleMethodOutcomeOutcomeResult>;
};

/**
 * The type of action outcome for the given rule.
 */
export enum OutcomeType {
    Boolean = "boolean",
}

/**
 * Defines the outcome of a rule in a flow where the result
 *
 * @remarks
 * is a boolean.
 */
export type BooleanOutcome = {
    /**
     * The type of action outcome for the given rule.
     */
    type: OutcomeType;
    /**
     * Results for a given flow action.
     */
    result: boolean;
};

/**
 * The outcome of the action.
 */
export type Outcome =
    | BooleanOutcome
    | PaymentMethodOutcome
    | UUIDsListOutcome
    | PaymentServiceOutcome;

/**
 * An action taken for a transaction.
 */
export type Action = {
    /**
     * The type of this resource. Is always `action`.
     */
    type?: ActionType | undefined;
    /**
     * The identifier for the action.
     */
    id?: Id | undefined;
    /**
     * The name of the Flow.
     */
    flow?: Flow | undefined;
    /**
     * The unique ID of the rule triggered.
     */
    ruleId?: string | undefined;
    /**
     * The date and time when this action was created.
     */
    createdAt?: Date | undefined;
    /**
     * The outcome of the action.
     */
    outcome?:
        | BooleanOutcome
        | PaymentMethodOutcome
        | UUIDsListOutcome
        | PaymentServiceOutcome
        | null
        | undefined;
};

/** @internal */
export const ActionType$: z.ZodNativeEnum<typeof ActionType> = z.nativeEnum(ActionType);

/** @internal */
export const Id$: z.ZodNativeEnum<typeof Id> = z.nativeEnum(Id);

/** @internal */
export const Flow$: z.ZodNativeEnum<typeof Flow> = z.nativeEnum(Flow);

/** @internal */
export const FlowRuleUUIDsListOutcomeOutcomeType$: z.ZodNativeEnum<
    typeof FlowRuleUUIDsListOutcomeOutcomeType
> = z.nativeEnum(FlowRuleUUIDsListOutcomeOutcomeType);

/** @internal */
export namespace UUIDsListOutcome$ {
    export type Inbound = {
        type: FlowRuleUUIDsListOutcomeOutcomeType;
        result: Array<string>;
    };

    export const inboundSchema: z.ZodType<UUIDsListOutcome, z.ZodTypeDef, Inbound> = z
        .object({
            type: FlowRuleUUIDsListOutcomeOutcomeType$,
            result: z.array(z.string()),
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
            };
        });

    export type Outbound = {
        type: FlowRuleUUIDsListOutcomeOutcomeType;
        result: Array<string>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, UUIDsListOutcome> = z
        .object({
            type: FlowRuleUUIDsListOutcomeOutcomeType$,
            result: z.array(z.string()),
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
            };
        });
}

/** @internal */
export const FlowRuleServiceOutcomeOutcomeType$: z.ZodNativeEnum<
    typeof FlowRuleServiceOutcomeOutcomeType
> = z.nativeEnum(FlowRuleServiceOutcomeOutcomeType);

/** @internal */
export const OutcomeInstrument$: z.ZodNativeEnum<typeof OutcomeInstrument> =
    z.nativeEnum(OutcomeInstrument);

/** @internal */
export const OutcomeName$: z.ZodNativeEnum<typeof OutcomeName> = z.nativeEnum(OutcomeName);

/** @internal */
export namespace OutcomeTransformations$ {
    export type Inbound = {
        name?: OutcomeName | undefined;
    };

    export const inboundSchema: z.ZodType<OutcomeTransformations, z.ZodTypeDef, Inbound> = z
        .object({
            name: OutcomeName$.optional(),
        })
        .transform((v) => {
            return {
                ...(v.name === undefined ? null : { name: v.name }),
            };
        });

    export type Outbound = {
        name?: OutcomeName | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, OutcomeTransformations> = z
        .object({
            name: OutcomeName$.optional(),
        })
        .transform((v) => {
            return {
                ...(v.name === undefined ? null : { name: v.name }),
            };
        });
}

/** @internal */
export namespace OutcomeResult$ {
    export type Inbound = {
        payment_service_id?: string | undefined;
        instrument?: OutcomeInstrument | undefined;
        transformations?: Array<OutcomeTransformations$.Inbound> | undefined;
    };

    export const inboundSchema: z.ZodType<OutcomeResult, z.ZodTypeDef, Inbound> = z
        .object({
            payment_service_id: z.string().optional(),
            instrument: OutcomeInstrument$.optional(),
            transformations: z
                .array(z.lazy(() => OutcomeTransformations$.inboundSchema))
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.payment_service_id === undefined
                    ? null
                    : { paymentServiceId: v.payment_service_id }),
                ...(v.instrument === undefined ? null : { instrument: v.instrument }),
                ...(v.transformations === undefined
                    ? null
                    : { transformations: v.transformations }),
            };
        });

    export type Outbound = {
        payment_service_id?: string | undefined;
        instrument?: OutcomeInstrument | undefined;
        transformations?: Array<OutcomeTransformations$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, OutcomeResult> = z
        .object({
            paymentServiceId: z.string().optional(),
            instrument: OutcomeInstrument$.optional(),
            transformations: z
                .array(z.lazy(() => OutcomeTransformations$.outboundSchema))
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.paymentServiceId === undefined
                    ? null
                    : { payment_service_id: v.paymentServiceId }),
                ...(v.instrument === undefined ? null : { instrument: v.instrument }),
                ...(v.transformations === undefined
                    ? null
                    : { transformations: v.transformations }),
            };
        });
}

/** @internal */
export const OutcomeVersion$: z.ZodNativeEnum<typeof OutcomeVersion> = z.nativeEnum(OutcomeVersion);

/** @internal */
export namespace PaymentServiceOutcome$ {
    export type Inbound = {
        type: FlowRuleServiceOutcomeOutcomeType;
        result: Array<OutcomeResult$.Inbound>;
        version: OutcomeVersion;
    };

    export const inboundSchema: z.ZodType<PaymentServiceOutcome, z.ZodTypeDef, Inbound> = z
        .object({
            type: FlowRuleServiceOutcomeOutcomeType$,
            result: z.array(z.lazy(() => OutcomeResult$.inboundSchema)),
            version: OutcomeVersion$,
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
                version: v.version,
            };
        });

    export type Outbound = {
        type: FlowRuleServiceOutcomeOutcomeType;
        result: Array<OutcomeResult$.Outbound>;
        version: OutcomeVersion;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentServiceOutcome> = z
        .object({
            type: FlowRuleServiceOutcomeOutcomeType$,
            result: z.array(z.lazy(() => OutcomeResult$.outboundSchema)),
            version: OutcomeVersion$,
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
                version: v.version,
            };
        });
}

/** @internal */
export const FlowRuleMethodOutcomeOutcomeType$: z.ZodNativeEnum<
    typeof FlowRuleMethodOutcomeOutcomeType
> = z.nativeEnum(FlowRuleMethodOutcomeOutcomeType);

/** @internal */
export const FlowRuleMethodOutcomeOutcomeResult$: z.ZodNativeEnum<
    typeof FlowRuleMethodOutcomeOutcomeResult
> = z.nativeEnum(FlowRuleMethodOutcomeOutcomeResult);

/** @internal */
export namespace PaymentMethodOutcome$ {
    export type Inbound = {
        type: FlowRuleMethodOutcomeOutcomeType;
        result: Array<FlowRuleMethodOutcomeOutcomeResult>;
    };

    export const inboundSchema: z.ZodType<PaymentMethodOutcome, z.ZodTypeDef, Inbound> = z
        .object({
            type: FlowRuleMethodOutcomeOutcomeType$,
            result: z.array(FlowRuleMethodOutcomeOutcomeResult$),
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
            };
        });

    export type Outbound = {
        type: FlowRuleMethodOutcomeOutcomeType;
        result: Array<FlowRuleMethodOutcomeOutcomeResult>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodOutcome> = z
        .object({
            type: FlowRuleMethodOutcomeOutcomeType$,
            result: z.array(FlowRuleMethodOutcomeOutcomeResult$),
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
            };
        });
}

/** @internal */
export const OutcomeType$: z.ZodNativeEnum<typeof OutcomeType> = z.nativeEnum(OutcomeType);

/** @internal */
export namespace BooleanOutcome$ {
    export type Inbound = {
        type: OutcomeType;
        result: boolean;
    };

    export const inboundSchema: z.ZodType<BooleanOutcome, z.ZodTypeDef, Inbound> = z
        .object({
            type: OutcomeType$,
            result: z.boolean(),
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
            };
        });

    export type Outbound = {
        type: OutcomeType;
        result: boolean;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BooleanOutcome> = z
        .object({
            type: OutcomeType$,
            result: z.boolean(),
        })
        .transform((v) => {
            return {
                type: v.type,
                result: v.result,
            };
        });
}

/** @internal */
export namespace Outcome$ {
    export type Inbound =
        | BooleanOutcome$.Inbound
        | PaymentMethodOutcome$.Inbound
        | UUIDsListOutcome$.Inbound
        | PaymentServiceOutcome$.Inbound;

    export type Outbound =
        | BooleanOutcome$.Outbound
        | PaymentMethodOutcome$.Outbound
        | UUIDsListOutcome$.Outbound
        | PaymentServiceOutcome$.Outbound;
    export const inboundSchema: z.ZodType<Outcome, z.ZodTypeDef, Inbound> = z.union([
        z.lazy(() => BooleanOutcome$.inboundSchema),
        z.lazy(() => PaymentMethodOutcome$.inboundSchema),
        z.lazy(() => UUIDsListOutcome$.inboundSchema),
        z.lazy(() => PaymentServiceOutcome$.inboundSchema),
    ]);
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Outcome> = z.union([
        z.lazy(() => BooleanOutcome$.outboundSchema),
        z.lazy(() => PaymentMethodOutcome$.outboundSchema),
        z.lazy(() => UUIDsListOutcome$.outboundSchema),
        z.lazy(() => PaymentServiceOutcome$.outboundSchema),
    ]);
}

/** @internal */
export namespace Action$ {
    export type Inbound = {
        type?: ActionType | undefined;
        id?: Id | undefined;
        flow?: Flow | undefined;
        rule_id?: string | undefined;
        created_at?: string | undefined;
        outcome?:
            | BooleanOutcome$.Inbound
            | PaymentMethodOutcome$.Inbound
            | UUIDsListOutcome$.Inbound
            | PaymentServiceOutcome$.Inbound
            | null
            | undefined;
    };

    export const inboundSchema: z.ZodType<Action, z.ZodTypeDef, Inbound> = z
        .object({
            type: ActionType$.optional(),
            id: Id$.optional(),
            flow: Flow$.optional(),
            rule_id: z.string().optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            outcome: z
                .nullable(
                    z.union([
                        z.lazy(() => BooleanOutcome$.inboundSchema),
                        z.lazy(() => PaymentMethodOutcome$.inboundSchema),
                        z.lazy(() => UUIDsListOutcome$.inboundSchema),
                        z.lazy(() => PaymentServiceOutcome$.inboundSchema),
                    ])
                )
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.flow === undefined ? null : { flow: v.flow }),
                ...(v.rule_id === undefined ? null : { ruleId: v.rule_id }),
                ...(v.created_at === undefined ? null : { createdAt: v.created_at }),
                ...(v.outcome === undefined ? null : { outcome: v.outcome }),
            };
        });

    export type Outbound = {
        type?: ActionType | undefined;
        id?: Id | undefined;
        flow?: Flow | undefined;
        rule_id?: string | undefined;
        created_at?: string | undefined;
        outcome?:
            | BooleanOutcome$.Outbound
            | PaymentMethodOutcome$.Outbound
            | UUIDsListOutcome$.Outbound
            | PaymentServiceOutcome$.Outbound
            | null
            | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Action> = z
        .object({
            type: ActionType$.optional(),
            id: Id$.optional(),
            flow: Flow$.optional(),
            ruleId: z.string().optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            outcome: z
                .nullable(
                    z.union([
                        z.lazy(() => BooleanOutcome$.outboundSchema),
                        z.lazy(() => PaymentMethodOutcome$.outboundSchema),
                        z.lazy(() => UUIDsListOutcome$.outboundSchema),
                        z.lazy(() => PaymentServiceOutcome$.outboundSchema),
                    ])
                )
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.type === undefined ? null : { type: v.type }),
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.flow === undefined ? null : { flow: v.flow }),
                ...(v.ruleId === undefined ? null : { rule_id: v.ruleId }),
                ...(v.createdAt === undefined ? null : { created_at: v.createdAt }),
                ...(v.outcome === undefined ? null : { outcome: v.outcome }),
            };
        });
}
