/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Creator,
  Creator$inboundSchema,
  Creator$Outbound,
  Creator$outboundSchema,
} from "./creator.js";
import {
  RefundStatus,
  RefundStatus$inboundSchema,
  RefundStatus$outboundSchema,
} from "./refundstatus.js";
import {
  RefundTargetType,
  RefundTargetType$inboundSchema,
  RefundTargetType$outboundSchema,
} from "./refundtargettype.js";

export type Refund = {
  /**
   * Always `refund`.
   */
  type?: "refund" | undefined;
  /**
   * The ID for the refund.
   */
  id: string;
  /**
   * The ID of the transaction associated with this refund.
   */
  transactionId: string;
  /**
   * The payment service's unique ID for the refund.
   */
  paymentServiceRefundId?: string | null | undefined;
  status: RefundStatus;
  /**
   * The currency code for this refund.  Will always match that of the associated transaction.
   */
  currency: string;
  /**
   * The amount requested for this refund.
   */
  amount: number;
  /**
   * The reason for this refund. Could be a multiline string.
   */
  reason?: string | null | undefined;
  targetType: RefundTargetType;
  /**
   * The optional ID of the instrument that was refunded. This may be `null` if the instrument was not stored.
   */
  targetId?: string | null | undefined;
  /**
   * The base62 encoded refund ID. This represents a shorter version of this refund's `id` which is sent to payment services, anti-fraud services, and other connectors. You can use this ID to reconcile a payment service's refund against our system.
   */
  reconciliationId: string;
  /**
   * An external identifier that can be used to match the refund against your own records.
   */
  externalIdentifier?: string | null | undefined;
  /**
   * The base62 encoded transaction ID. This represents a shorter version of the related transaction's `id` which is sent to payment services, anti-fraud services, and other connectors. You can use this ID to reconcile a payment service's transaction against our system.
   */
  transactionReconciliationId: string;
  /**
   * An external identifier that can be used to match the transaction against your own records.
   */
  transactionExternalIdentifier?: string | null | undefined;
  /**
   * The date this refund was created at.
   */
  createdAt: Date;
  /**
   * The date this refund was last updated at.
   */
  updatedAt: Date;
  /**
   * The user that created this resource
   */
  creator?: Creator | null | undefined;
};

/** @internal */
export const Refund$inboundSchema: z.ZodType<Refund, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("refund").default("refund"),
    id: z.string(),
    transaction_id: z.string(),
    payment_service_refund_id: z.nullable(z.string()).optional(),
    status: RefundStatus$inboundSchema,
    currency: z.string(),
    amount: z.number().int(),
    reason: z.nullable(z.string()).optional(),
    target_type: RefundTargetType$inboundSchema,
    target_id: z.nullable(z.string()).optional(),
    reconciliation_id: z.string(),
    external_identifier: z.nullable(z.string()).optional(),
    transaction_reconciliation_id: z.string(),
    transaction_external_identifier: z.nullable(z.string()).optional(),
    created_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    updated_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    creator: z.nullable(Creator$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "transaction_id": "transactionId",
      "payment_service_refund_id": "paymentServiceRefundId",
      "target_type": "targetType",
      "target_id": "targetId",
      "reconciliation_id": "reconciliationId",
      "external_identifier": "externalIdentifier",
      "transaction_reconciliation_id": "transactionReconciliationId",
      "transaction_external_identifier": "transactionExternalIdentifier",
      "created_at": "createdAt",
      "updated_at": "updatedAt",
    });
  });

/** @internal */
export type Refund$Outbound = {
  type: "refund";
  id: string;
  transaction_id: string;
  payment_service_refund_id?: string | null | undefined;
  status: string;
  currency: string;
  amount: number;
  reason?: string | null | undefined;
  target_type: string;
  target_id?: string | null | undefined;
  reconciliation_id: string;
  external_identifier?: string | null | undefined;
  transaction_reconciliation_id: string;
  transaction_external_identifier?: string | null | undefined;
  created_at: string;
  updated_at: string;
  creator?: Creator$Outbound | null | undefined;
};

/** @internal */
export const Refund$outboundSchema: z.ZodType<
  Refund$Outbound,
  z.ZodTypeDef,
  Refund
> = z.object({
  type: z.literal("refund").default("refund" as const),
  id: z.string(),
  transactionId: z.string(),
  paymentServiceRefundId: z.nullable(z.string()).optional(),
  status: RefundStatus$outboundSchema,
  currency: z.string(),
  amount: z.number().int(),
  reason: z.nullable(z.string()).optional(),
  targetType: RefundTargetType$outboundSchema,
  targetId: z.nullable(z.string()).optional(),
  reconciliationId: z.string(),
  externalIdentifier: z.nullable(z.string()).optional(),
  transactionReconciliationId: z.string(),
  transactionExternalIdentifier: z.nullable(z.string()).optional(),
  createdAt: z.date().transform(v => v.toISOString()),
  updatedAt: z.date().transform(v => v.toISOString()),
  creator: z.nullable(Creator$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    transactionId: "transaction_id",
    paymentServiceRefundId: "payment_service_refund_id",
    targetType: "target_type",
    targetId: "target_id",
    reconciliationId: "reconciliation_id",
    externalIdentifier: "external_identifier",
    transactionReconciliationId: "transaction_reconciliation_id",
    transactionExternalIdentifier: "transaction_external_identifier",
    createdAt: "created_at",
    updatedAt: "updated_at",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Refund$ {
  /** @deprecated use `Refund$inboundSchema` instead. */
  export const inboundSchema = Refund$inboundSchema;
  /** @deprecated use `Refund$outboundSchema` instead. */
  export const outboundSchema = Refund$outboundSchema;
  /** @deprecated use `Refund$Outbound` instead. */
  export type Outbound = Refund$Outbound;
}

export function refundToJSON(refund: Refund): string {
  return JSON.stringify(Refund$outboundSchema.parse(refund));
}

export function refundFromJSON(
  jsonString: string,
): SafeParseResult<Refund, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refund$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refund' from JSON`,
  );
}
