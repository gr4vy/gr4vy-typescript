/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import * as z from "zod";

/**
 * `payment-method`.
 */
export enum PaymentMethodTokenizedType {
    PaymentMethod = "payment-method",
}

/**
 * The type of this payment method.
 */
export enum Method {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Everydaypay = "everydaypay",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    NetworkToken = "network-token",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * The type of the card, if the payment method is a card.
 */
export enum Scheme {
    Accel = "accel",
    Amex = "amex",
    Bancontact = "bancontact",
    CarteBancaire = "carte-bancaire",
    Cirrus = "cirrus",
    Culiance = "culiance",
    Dankort = "dankort",
    DinersClub = "diners-club",
    Discover = "discover",
    EftposAustralia = "eftpos-australia",
    Elo = "elo",
    Hipercard = "hipercard",
    Jcb = "jcb",
    Maestro = "maestro",
    Mastercard = "mastercard",
    Mir = "mir",
    Nyce = "nyce",
    Other = "other",
    Pulse = "pulse",
    Rupay = "rupay",
    Star = "star",
    Uatp = "uatp",
    Unionpay = "unionpay",
    Visa = "visa",
}

export enum AdditionalSchemes {
    Accel = "accel",
    Amex = "amex",
    Bancontact = "bancontact",
    CarteBancaire = "carte-bancaire",
    Cirrus = "cirrus",
    Culiance = "culiance",
    Dankort = "dankort",
    DinersClub = "diners-club",
    Discover = "discover",
    EftposAustralia = "eftpos-australia",
    Elo = "elo",
    Hipercard = "hipercard",
    Jcb = "jcb",
    Maestro = "maestro",
    Mastercard = "mastercard",
    Mir = "mir",
    Nyce = "nyce",
    Other = "other",
    Pulse = "pulse",
    Rupay = "rupay",
    Star = "star",
    Uatp = "uatp",
    Unionpay = "unionpay",
    Visa = "visa",
}

/**
 * The browser target that an approval URL must be opened in. If `any` or `null`, then there is no specific requirement.
 */
export enum ApprovalTarget {
    Any = "any",
    NewWindow = "new_window",
}

/**
 * A mini format version of a payment method.
 */
export type PaymentMethodTokenized = {
    /**
     * `payment-method`.
     */
    type?: PaymentMethodTokenizedType | undefined;
    /**
     * The unique ID of the payment method.
     */
    id?: string | undefined;
    /**
     * The unique ID for a merchant account.
     */
    merchantAccountId?: string | undefined;
    /**
     * The type of this payment method.
     */
    method?: Method | undefined;
    /**
     * A label for the payment method. For a `card` payment method this is the
     *
     * @remarks
     * last 4 digits on the card. For others it would be the email address.
     */
    label?: string | undefined;
    /**
     * The type of the card, if the payment method is a card.
     */
    scheme?: Scheme | null | undefined;
    /**
     * Additional schemes of the card. Only applies to card payment methods.
     */
    additionalSchemes?: Array<AdditionalSchemes> | null | undefined;
    /**
     * The expiration date for the payment method.
     */
    expirationDate?: string | null | undefined;
    /**
     * The browser target that an approval URL must be opened in. If `any` or `null`, then there is no specific requirement.
     */
    approvalTarget?: ApprovalTarget | null | undefined;
    /**
     * The optional URL that the buyer needs to be redirected to to further authorize their payment.
     */
    approvalUrl?: string | null | undefined;
    /**
     * The ISO-4217 currency code that this payment method can be
     *
     * @remarks
     * used for. If this value is `null` the payment method may be
     * used for multiple currencies.
     */
    currency?: string | null | undefined;
    /**
     * The 2-letter ISO code of the country this payment method can
     *
     * @remarks
     * be used for. If this value is `null` the payment method may be
     * used in multiple countries.
     */
    country?: string | null | undefined;
    /**
     * The date and time when this card was last replaced.
     *
     * @remarks
     *
     * When the Account Updater determines that new card details are available, existing details are not
     * changed immediately. There are three scenarios in which the actual replacement occurs:
     *
     * 1. When this card has expired.
     * 2. When only the expiration date changed.
     * 3. When a transaction using this card is declined with any of the following codes:
     *     * `canceled_payment_method`
     *     * `expired_payment_method`
     *     * `unavailable_payment_method`
     *     * `unknown_payment_method`
     *
     * When the replacement is applied, this field is updated.
     * For non-card payment methods, the value of this field is always set to `null`.
     */
    lastReplacedAt?: Date | null | undefined;
    /**
     * Whether this card has a pending replacement that hasn't been applied yet.
     *
     * @remarks
     *
     * When the Account Updater determines that new card details are available, existing details are not
     * changed immediately, but this field is set to `true`. There are three scenarios in which the actual
     * replacement occurs:
     *
     * 1. When this card has expired.
     * 2. When only the expiration date changed.
     * 3. When a transaction using this card is declined with any of the following codes:
     *     * `canceled_payment_method`
     *     * `expired_payment_method`
     *     * `unavailable_payment_method`
     *     * `unknown_payment_method`
     *
     * When the replacement is applied, this field is set to `false`.
     * For non-card payment methods, the value of this field is always set to `false`.
     */
    hasReplacement?: boolean | undefined;
};

/** @internal */
export namespace PaymentMethodTokenizedType$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodTokenizedType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Method$ {
    export const inboundSchema = z.nativeEnum(Method);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Scheme$ {
    export const inboundSchema = z.nativeEnum(Scheme);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace AdditionalSchemes$ {
    export const inboundSchema = z.nativeEnum(AdditionalSchemes);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ApprovalTarget$ {
    export const inboundSchema = z.nativeEnum(ApprovalTarget);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodTokenized$ {
    export const inboundSchema: z.ZodType<PaymentMethodTokenized, z.ZodTypeDef, unknown> = z
        .object({
            type: PaymentMethodTokenizedType$.inboundSchema.optional(),
            id: z.string().optional(),
            merchant_account_id: z.string().optional(),
            method: Method$.inboundSchema.optional(),
            label: z.string().optional(),
            scheme: z.nullable(Scheme$.inboundSchema).optional(),
            additional_schemes: z.nullable(z.array(AdditionalSchemes$.inboundSchema)).optional(),
            expiration_date: z.nullable(z.string()).optional(),
            approval_target: z.nullable(ApprovalTarget$.inboundSchema).optional(),
            approval_url: z.nullable(z.string()).optional(),
            currency: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            last_replaced_at: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
            has_replacement: z.boolean().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                merchant_account_id: "merchantAccountId",
                additional_schemes: "additionalSchemes",
                expiration_date: "expirationDate",
                approval_target: "approvalTarget",
                approval_url: "approvalUrl",
                last_replaced_at: "lastReplacedAt",
                has_replacement: "hasReplacement",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        merchant_account_id?: string | undefined;
        method?: string | undefined;
        label?: string | undefined;
        scheme?: string | null | undefined;
        additional_schemes?: Array<string> | null | undefined;
        expiration_date?: string | null | undefined;
        approval_target?: string | null | undefined;
        approval_url?: string | null | undefined;
        currency?: string | null | undefined;
        country?: string | null | undefined;
        last_replaced_at?: string | null | undefined;
        has_replacement?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodTokenized> = z
        .object({
            type: PaymentMethodTokenizedType$.outboundSchema.optional(),
            id: z.string().optional(),
            merchantAccountId: z.string().optional(),
            method: Method$.outboundSchema.optional(),
            label: z.string().optional(),
            scheme: z.nullable(Scheme$.outboundSchema).optional(),
            additionalSchemes: z.nullable(z.array(AdditionalSchemes$.outboundSchema)).optional(),
            expirationDate: z.nullable(z.string()).optional(),
            approvalTarget: z.nullable(ApprovalTarget$.outboundSchema).optional(),
            approvalUrl: z.nullable(z.string()).optional(),
            currency: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            lastReplacedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            hasReplacement: z.boolean().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                merchantAccountId: "merchant_account_id",
                additionalSchemes: "additional_schemes",
                expirationDate: "expiration_date",
                approvalTarget: "approval_target",
                approvalUrl: "approval_url",
                lastReplacedAt: "last_replaced_at",
                hasReplacement: "has_replacement",
            });
        });
}
