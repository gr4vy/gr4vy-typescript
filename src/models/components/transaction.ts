/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { CartItem, CartItem$ } from "./cartitem";
import { GiftCardRedemption, GiftCardRedemption$ } from "./giftcardredemption";
import { GiftCardServiceSnapshot, GiftCardServiceSnapshot$ } from "./giftcardservicesnapshot";
import { ThreeDSecureSummary, ThreeDSecureSummary$ } from "./threedsecuresummary";
import * as z from "zod";

/**
 * The type of this resource. Is always `transaction`.
 */
export enum TransactionType {
    Transaction = "transaction",
}

/**
 * The response code received from the payment service for the Address
 *
 * @remarks
 * Verification Check (AVS). This code is mapped to a standardized Gr4vy
 * AVS response code.
 *
 * - `no_match` - neither address or postal code match
 * - `match` - both address and postal code match
 * - `partial_match_address` - address matches but postal code does not
 * - `partial_match_postcode` - postal code matches but address does not
 * - `unavailable ` - AVS is unavailable for card/country
 *
 * The value of this field can be `null` if the payment service did not
 * provide a response.
 */
export enum AvsResponseCode {
    NoMatch = "no_match",
    Match = "match",
    PartialMatchAddress = "partial_match_address",
    PartialMatchPostcode = "partial_match_postcode",
    Unavailable = "unavailable",
}

/**
 * The type of this resource. Is always `buyer`.
 */
export enum TransactionBuyerType {
    Buyer = "buyer",
}

/**
 * The type of this resource. Is always `billing-details`.
 */
export enum TransactionBuyerBillingDetailsType {
    BillingDetails = "billing-details",
}

/**
 * The billing address of the buyer.
 */
export type TransactionBuyerAddress = {
    /**
     * The city for the address.
     */
    city?: string | null | undefined;
    /**
     * The country for the address in ISO 3166 format.
     */
    country?: string | null | undefined;
    /**
     * The postal code or zip code for the address.
     */
    postalCode?: string | null | undefined;
    /**
     * The state, county, or province for the address.
     */
    state?: string | null | undefined;
    /**
     * The code of state, county, or province for the address in
     *
     * @remarks
     * ISO 3166-2 format.
     */
    stateCode?: string | null | undefined;
    /**
     * The house number or name for the address. Not all payment
     *
     * @remarks
     * services use this field but some do.
     */
    houseNumberOrName?: string | null | undefined;
    /**
     * The first line of the address.
     */
    line1?: string | null | undefined;
    /**
     * The second line of the address.
     */
    line2?: string | null | undefined;
    /**
     * The optional name of the company or organisation to add
     *
     * @remarks
     * to the address.
     */
    organization?: string | null | undefined;
};

/**
 * The kind of tax ID.
 */
export enum TransactionKind {
    AeTrn = "ae.trn",
    AuAbn = "au.abn",
    ArDni = "ar.dni",
    ArCuil = "ar.cuil",
    ArCuit = "ar.cuit",
    BrCnpj = "br.cnpj",
    BrCpf = "br.cpf",
    CaBn = "ca.bn",
    CaGstHst = "ca.gst_hst",
    CaPstBc = "ca.pst_bc",
    CaPstMb = "ca.pst_mb",
    CaPstSk = "ca.pst_sk",
    CaQst = "ca.qst",
    ChVat = "ch.vat",
    ClTin = "cl.tin",
    EsCif = "es.cif",
    EuVat = "eu.vat",
    GbVat = "gb.vat",
    HkBr = "hk.br",
    IdNik = "id.nik",
    IdNpwp = "id.npwp",
    InGst = "in.gst",
    JpCn = "jp.cn",
    JpRn = "jp.rn",
    KrBrn = "kr.brn",
    LiUid = "li.uid",
    MxCurp = "mx.curp",
    MyFrp = "my.frp",
    MyItn = "my.itn",
    MyNric = "my.nric",
    MySst = "my.sst",
    NoVat = "no.vat",
    NzGst = "nz.gst",
    PhTin = "ph.tin",
    RuInn = "ru.inn",
    RuKpp = "ru.kpp",
    SaVat = "sa.vat",
    SgGst = "sg.gst",
    SgUen = "sg.uen",
    ThId = "th.id",
    ThVat = "th.vat",
    TwVat = "tw.vat",
    UsEin = "us.ein",
    ZaVat = "za.vat",
}

/**
 * The tax information associated with the billing details.
 */
export type TransactionTaxID = {
    /**
     * The tax ID for the buyer.
     */
    value: string;
    /**
     * The kind of tax ID.
     */
    kind: TransactionKind;
};

/**
 * The billing details associated with the buyer, which include the
 *
 * @remarks
 * address and tax ID.
 */
export type TransactionBillingDetails = {
    /**
     * The type of this resource. Is always `billing-details`.
     */
    type?: TransactionBuyerBillingDetailsType | undefined;
    /**
     * The first name(s) or given name of the buyer.
     */
    firstName?: string | null | undefined;
    /**
     * The last name, or family name, of the buyer.
     */
    lastName?: string | null | undefined;
    /**
     * The email address of the buyer.
     */
    emailAddress?: string | null | undefined;
    /**
     * The phone number of the buyer. This number is formatted according to the
     *
     * @remarks
     * [E164 number standard](https://www.twilio.com/docs/glossary/what-e164).
     */
    phoneNumber?: string | null | undefined;
    /**
     * The billing address of the buyer.
     */
    address?: TransactionBuyerAddress | null | undefined;
    /**
     * The tax information associated with the billing details.
     */
    taxId?: TransactionTaxID | null | undefined;
};

/**
 * The buyer used for this transaction.
 */
export type TransactionBuyerSnapshot = {
    /**
     * The type of this resource. Is always `buyer`.
     */
    type?: TransactionBuyerType | undefined;
    /**
     * The unique Gr4vy ID for this buyer.
     */
    id?: string | undefined;
    /**
     * The billing details associated with the buyer, which include the
     *
     * @remarks
     * address and tax ID.
     */
    billingDetails?: TransactionBillingDetails | null | undefined;
    /**
     * A unique name for this buyer which is used in the Gr4vy admin panel to give a buyer a human readable name.
     */
    displayName?: string | null | undefined;
    /**
     * An external identifier that can be used to match the buyer against your own records.
     */
    externalIdentifier?: string | null | undefined;
};

/**
 * The response code received from the payment service for the Card
 *
 * @remarks
 * Verification Value (CVV). This code is mapped to a standardized Gr4vy
 * CVV response code.
 *
 * - `no_match` - the CVV does not match the expected value
 * - `match` - the CVV matches the expected value
 * - `unavailable ` - CVV check unavailable for card our country
 * - `not_provided ` - CVV not provided
 *
 * The value of this field can be `null` if the payment service did not
 * provide a response.
 */
export enum CvvResponseCode {
    NoMatch = "no_match",
    Match = "match",
    Unavailable = "unavailable",
    NotProvided = "not_provided",
}

/**
 * The name of the instrument used to process the transaction.
 *
 * @remarks
 *
 */
export enum TransactionInstrumentType {
    Applepay = "applepay",
    CardToken = "card_token",
    Googlepay = "googlepay",
    NetworkToken = "network_token",
    Pan = "pan",
    Redirect = "redirect",
    RedirectToken = "redirect_token",
}

/**
 * The original `intent` used when the transaction was
 *
 * @remarks
 * [created](#operation/authorize-new-transaction).
 */
export enum TransactionIntent {
    Authorize = "authorize",
    Capture = "capture",
}

/**
 * The outcome of the original intent of a transaction.
 *
 * @remarks
 *
 * This allows you to understand if the intent of the transaction
 * (e.g. `capture` or `authorize`) has been achieved when dealing with multiple
 * payment instruments.
 *
 * If all payment instruments (`payment_method` and/or `gift_cards`)
 * have succeeded to get an authorization or direct sale **at any point
 * in time** then this will return a `succeeded` value.
 *
 * If any of the payment instruments fails or declines then this will
 * return a `failed` value.
 *
 * If any payment instruments is still in a `pending` or `processing` state
 * then the result will be `pending`.
 *
 * Please note that if any of the payment instruments are voided or refunded
 * after the result reaches a `succeeded` state  then the result will remain
 * unchanged.
 */
export enum IntentOutcome {
    Pending = "pending",
    Succeeded = "succeeded",
    Failed = "failed",
}

export enum TransactionMethod {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Everydaypay = "everydaypay",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    NetworkToken = "network-token",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * `payment-method`.
 */
export enum TransactionPaymentMethodType {
    PaymentMethod = "payment-method",
}

/**
 * The browser target that an approval URL must be opened in. If `any` or `null`, then there is no specific requirement.
 */
export enum TransactionApprovalTarget {
    Any = "any",
    NewWindow = "new_window",
}

/**
 * The type of card, one of `credit`, `debit` or `prepaid`.
 */
export enum TransactionCardType {
    Credit = "credit",
    Debit = "debit",
    Prepaid = "prepaid",
}

/**
 * A credit or debit card payment method.
 */
export type TransactionCard = {
    /**
     * The type of card, one of `credit`, `debit` or `prepaid`.
     */
    cardType?: TransactionCardType | undefined;
    /**
     * The first 6 digits of the full card number (the BIN).
     */
    bin?: string | undefined;
};

/**
 * The type of this payment method.
 */
export enum TransactionPaymentMethodMethod {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Everydaypay = "everydaypay",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    NetworkToken = "network-token",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * An additional label used to differentiate different sub-types of a payment
 *
 * @remarks
 * method. Most notably this can include the type of card used in a
 * transaction. This field is `null` for the non-card payment methods.
 * This represents the card scheme sent to the connector and it could be different from the
 * actual card scheme that is being used by the PSP to process the transaction
 * in the following situations: 1. `use_additional_scheme` transformation is used
 * with the `PAN` instrument but we already have a PSP token for the card.
 * 2. `use_additional_scheme` transformation is used but PSP has fallen back to the
 * main card scheme internally.
 */
export enum TransactionScheme {
    Accel = "accel",
    Amex = "amex",
    Bancontact = "bancontact",
    CarteBancaire = "carte-bancaire",
    Cirrus = "cirrus",
    Culiance = "culiance",
    Dankort = "dankort",
    DinersClub = "diners-club",
    Discover = "discover",
    EftposAustralia = "eftpos-australia",
    Elo = "elo",
    Hipercard = "hipercard",
    Jcb = "jcb",
    Maestro = "maestro",
    Mastercard = "mastercard",
    Mir = "mir",
    Nyce = "nyce",
    Other = "other",
    Pulse = "pulse",
    Rupay = "rupay",
    Star = "star",
    Uatp = "uatp",
    Unionpay = "unionpay",
    Visa = "visa",
}

/**
 * The payment method used for this transaction.
 */
export type TransactionPaymentMethodSnapshot = {
    /**
     * `payment-method`.
     */
    type?: TransactionPaymentMethodType | undefined;
    /**
     * The unique ID of the payment method.
     */
    id?: string | null | undefined;
    /**
     * The browser target that an approval URL must be opened in. If `any` or `null`, then there is no specific requirement.
     */
    approvalTarget?: TransactionApprovalTarget | null | undefined;
    /**
     * The optional URL that the buyer needs to be redirected to to further authorize their payment.
     */
    approvalUrl?: string | null | undefined;
    /**
     * The 2-letter ISO code of the country this payment method can
     *
     * @remarks
     * be used for. If this value is `null` the payment method may be
     * used in multiple countries.
     */
    country?: string | null | undefined;
    /**
     * The ISO-4217 currency code that this payment method can be
     *
     * @remarks
     * used for. If this value is `null` the payment method may be
     * used for multiple currencies.
     */
    currency?: string | null | undefined;
    details?: TransactionCard | null | undefined;
    /**
     * The expiration date for this payment method. This is mostly used by cards
     *
     * @remarks
     * where the card might have an expiration date.
     */
    expirationDate?: string | null | undefined;
    /**
     * An external identifier that can be used to match the payment method
     *
     * @remarks
     * against your own records.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * A label for the payment method. This can be the last 4 digits for a card,
     *
     * @remarks
     * or the email address for an alternative payment method.
     */
    label?: string | null | undefined;
    /**
     * The date and time when this card was last replaced.
     *
     * @remarks
     *
     * When the Account Updater determines that new card details are available, existing details are not
     * changed immediately. There are three scenarios in which the actual replacement occurs:
     *
     * 1. When this card has expired.
     * 2. When only the expiration date changed.
     * 3. When a transaction using this card is declined with any of the following codes:
     *     * `canceled_payment_method`
     *     * `expired_payment_method`
     *     * `unavailable_payment_method`
     *     * `unknown_payment_method`
     *
     * When the replacement is applied, this field is updated.
     * For non-card payment methods, the value of this field is always set to `null`.
     */
    lastReplacedAt?: Date | null | undefined;
    /**
     * The type of this payment method.
     */
    method?: TransactionPaymentMethodMethod | undefined;
    /**
     * The payment account reference (PAR) returned by the card scheme. This is a unique
     *
     * @remarks
     * reference to the underlying account that has been used to fund this payment method.
     * This value will be unique if the same underlying account was used, regardless of
     * the actual payment method used. For example, a network token or an Apple Pay device
     * token will return the same PAR when possible.
     *
     * The uniqueness of this value will depend on the card scheme, please refer to their documentation
     * for further details. The availability of the PAR in our API depends on the availability
     * of its value in the API of the payment service used for the transaction.
     */
    paymentAccountReference?: string | null | undefined;
    /**
     * An additional label used to differentiate different sub-types of a payment
     *
     * @remarks
     * method. Most notably this can include the type of card used in a
     * transaction. This field is `null` for the non-card payment methods.
     * This represents the card scheme sent to the connector and it could be different from the
     * actual card scheme that is being used by the PSP to process the transaction
     * in the following situations: 1. `use_additional_scheme` transformation is used
     * with the `PAN` instrument but we already have a PSP token for the card.
     * 2. `use_additional_scheme` transformation is used but PSP has fallen back to the
     * main card scheme internally.
     */
    scheme?: TransactionScheme | null | undefined;
    /**
     * The unique hash derived from the payment method identifier (e.g. card number).
     */
    fingerprint?: string | null | undefined;
};

/**
 * The type of this resource.
 */
export enum TransactionPaymentServiceType {
    PaymentService = "payment-service",
}

/**
 * The payment method that this services handles.
 */
export enum TransactionPaymentServiceMethod {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Everydaypay = "everydaypay",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    NetworkToken = "network-token",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * The payment service used for this transaction.
 */
export type TransactionAPaymentService = {
    /**
     * The type of this resource.
     */
    type?: TransactionPaymentServiceType | undefined;
    /**
     * The ID of this payment service.
     */
    id?: string | undefined;
    /**
     * The custom name set for this service.
     */
    displayName?: string | undefined;
    /**
     * The payment method that this services handles.
     */
    method?: TransactionPaymentServiceMethod | undefined;
    /**
     * The ID of the payment service definition used to create this service.
     *
     * @remarks
     *
     */
    paymentServiceDefinitionId?: string | undefined;
};

/**
 * The source of the transaction. Defaults to `ecommerce`.
 */
export enum TransactionPaymentSource {
    Ecommerce = "ecommerce",
    Moto = "moto",
    Recurring = "recurring",
    Installment = "installment",
    CardOnFile = "card_on_file",
}

/**
 * The type of this resource. Is always `shipping-details`.
 */
export enum TransactionShippingDetailsType {
    ShippingDetails = "shipping-details",
}

/**
 * The physical shipping address associated to this buyer.
 */
export type TransactionAddress = {
    /**
     * The city for the address.
     */
    city?: string | null | undefined;
    /**
     * The country for the address in ISO 3166 format.
     */
    country?: string | null | undefined;
    /**
     * The postal code or zip code for the address.
     */
    postalCode?: string | null | undefined;
    /**
     * The state, county, or province for the address.
     */
    state?: string | null | undefined;
    /**
     * The code of state, county, or province for the address in
     *
     * @remarks
     * ISO 3166-2 format.
     */
    stateCode?: string | null | undefined;
    /**
     * The house number or name for the address. Not all payment
     *
     * @remarks
     * services use this field but some do.
     */
    houseNumberOrName?: string | null | undefined;
    /**
     * The first line of the address.
     */
    line1?: string | null | undefined;
    /**
     * The second line of the address.
     */
    line2?: string | null | undefined;
    /**
     * The optional name of the company or organisation to add
     *
     * @remarks
     * to the address.
     */
    organization?: string | null | undefined;
};

/**
 * The shipping details associated with the transaction.
 */
export type TransactionShippingDetail = {
    /**
     * The type of this resource. Is always `shipping-details`.
     */
    type?: TransactionShippingDetailsType | undefined;
    /**
     * The unique ID for a buyer's shipping detail.
     */
    id?: string | undefined;
    /**
     * The unique ID for a buyer.
     */
    buyerId?: string | undefined;
    /**
     * The first name(s) or given name of the buyer.
     */
    firstName?: string | null | undefined;
    /**
     * The last name, or family name, of the buyer.
     */
    lastName?: string | null | undefined;
    /**
     * The email address of the buyer.
     */
    emailAddress?: string | null | undefined;
    /**
     * The phone number of the buyer. This number is formatted according to the
     *
     * @remarks
     * [E164 number standard](https://www.twilio.com/docs/glossary/what-e164).
     */
    phoneNumber?: string | null | undefined;
    /**
     * The physical shipping address associated to this buyer.
     */
    address?: TransactionAddress | null | undefined;
};

/**
 * The statement descriptor is the text to be shown on the buyer's statements.
 *
 * @remarks
 *
 * The specific usage of these fields will depend on the capabilities of
 * the underlying PSP and bank. As a typical example, 'name' and
 * 'description' could be concatenated using '* ' as a separator, and
 * then the resulting descriptor would be truncated to 22 characters by
 * the issuing bank.
 */
export type TransactionStatementDescriptor = {
    /**
     * Reflects your doing business as (DBA) name.
     *
     * @remarks
     *
     * Other validations:
     *
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    name?: string | null | undefined;
    /**
     * A short description about the purchase.
     *
     * @remarks
     *
     * Other validations:
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    description?: string | null | undefined;
    /**
     * City from which the charge originated.
     */
    city?: string | null | undefined;
    /**
     * The value in the phone number field of a customer's statement which
     *
     * @remarks
     * should be formatted according to the
     * [E164 number standard](https://www.twilio.com/docs/glossary/what-e164).
     */
    phoneNumber?: string | null | undefined;
    /**
     * The value in the URL/web address field of a customer's statement.
     */
    url?: string | null | undefined;
};

/**
 * The status of the transaction for the `payment_method`. The status
 *
 * @remarks
 * may change over time as asynchronous processing events occur.
 *
 * Please note that the possible statuses returned will depend on the
 * operation performed. For example, a captured transaction will never
 * move to a `authorization_voided` status.
 */
export enum TransactionStatus {
    Processing = "processing",
    BuyerApprovalPending = "buyer_approval_pending",
    AuthorizationSucceeded = "authorization_succeeded",
    AuthorizationFailed = "authorization_failed",
    AuthorizationDeclined = "authorization_declined",
    CapturePending = "capture_pending",
    CaptureSucceeded = "capture_succeeded",
    AuthorizationVoidPending = "authorization_void_pending",
    AuthorizationVoided = "authorization_voided",
}

/**
 * A transaction record.
 */
export type Transaction = {
    /**
     * The type of this resource. Is always `transaction`.
     */
    type?: TransactionType | undefined;
    /**
     * The unique identifier for this transaction.
     */
    id?: string | undefined;
    /**
     * The total amount for this transaction across all funding sources
     *
     * @remarks
     * including gift cards.
     */
    amount?: number | undefined;
    /**
     * This is the response description received from the processor.
     */
    authResponseCode?: string | null | undefined;
    /**
     * The amount for this transaction that has been authorized for the `payment_method`.
     *
     * @remarks
     * This can be less than the `amount` if gift cards were used.
     */
    authorizedAmount?: number | undefined;
    /**
     * The date and time when this transaction was authorized in the payment
     *
     * @remarks
     * service.
     *
     * Don't use this field to determine whether the transaction was authorized.
     * A `null` value doesn't necessarily imply that the transaction wasn't
     * authorized, it can mean that the payment service doesn't provide this
     * value, that it didn't provide it at the time the transaction was
     * authorized or that the transaction was authorized before the introduction
     * of this field.
     */
    authorizedAt?: Date | null | undefined;
    /**
     * The date and time when this transaction will be marked as failed if it does
     *
     * @remarks
     * not successfully gets captured, authorized or otherwise approved before.
     */
    approvalExpiresAt?: Date | null | undefined;
    /**
     * The response code received from the payment service for the Address
     *
     * @remarks
     * Verification Check (AVS). This code is mapped to a standardized Gr4vy
     * AVS response code.
     *
     * - `no_match` - neither address or postal code match
     * - `match` - both address and postal code match
     * - `partial_match_address` - address matches but postal code does not
     * - `partial_match_postcode` - postal code matches but address does not
     * - `unavailable ` - AVS is unavailable for card/country
     *
     * The value of this field can be `null` if the payment service did not
     * provide a response.
     */
    avsResponseCode?: AvsResponseCode | null | undefined;
    /**
     * The buyer used for this transaction.
     */
    buyer?: TransactionBuyerSnapshot | null | undefined;
    /**
     * The captured amount for this transaction. This can be the full value
     *
     * @remarks
     * of the `authorized_amount` or less.
     */
    capturedAmount?: number | undefined;
    /**
     * The date and time when this transaction was captured in the payment
     *
     * @remarks
     * service.
     *
     * Don't use this field to determine whether the transaction was captured.
     * A `null` value doesn't necessarily imply that the transaction wasn't
     * captured, it can mean that the payment service doesn't provide this value,
     * that it didn't provide it at the time the transaction was captured or that
     * the transaction was captured before the introduction of this field.
     */
    capturedAt?: Date | null | undefined;
    /**
     * An array of cart items that represents the line items of a transaction.
     */
    cartItems?: Array<CartItem> | undefined;
    /**
     * The identifier for the checkout session this transaction is associated with.
     */
    checkoutSessionId?: string | null | undefined;
    /**
     * The 2-letter ISO code of the country of the transaction.
     *
     * @remarks
     * This is used to filter the payment services that is used to process the
     * transaction.
     *
     */
    country?: string | null | undefined;
    /**
     * The date and time when this transaction was created in our system.
     */
    createdAt?: Date | undefined;
    /**
     * The currency code for this transaction.
     */
    currency?: string | undefined;
    /**
     * The response code received from the payment service for the Card
     *
     * @remarks
     * Verification Value (CVV). This code is mapped to a standardized Gr4vy
     * CVV response code.
     *
     * - `no_match` - the CVV does not match the expected value
     * - `match` - the CVV matches the expected value
     * - `unavailable ` - CVV check unavailable for card our country
     * - `not_provided ` - CVV not provided
     *
     * The value of this field can be `null` if the payment service did not
     * provide a response.
     */
    cvvResponseCode?: CvvResponseCode | null | undefined;
    /**
     * This is an error code set by Gr4vy.
     */
    errorCode?: string | null | undefined;
    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * The gift card service used for this transaction.
     */
    giftCardService?: GiftCardServiceSnapshot | undefined;
    /**
     * The gift cards redeemed for this transaction.
     */
    giftCardRedemptions?: Array<GiftCardRedemption> | undefined;
    /**
     * The name of the instrument used to process the transaction.
     *
     * @remarks
     *
     */
    instrumentType?: TransactionInstrumentType | null | undefined;
    /**
     * The original `intent` used when the transaction was
     *
     * @remarks
     * [created](#operation/authorize-new-transaction).
     */
    intent?: TransactionIntent | undefined;
    /**
     * The outcome of the original intent of a transaction.
     *
     * @remarks
     *
     * This allows you to understand if the intent of the transaction
     * (e.g. `capture` or `authorize`) has been achieved when dealing with multiple
     * payment instruments.
     *
     * If all payment instruments (`payment_method` and/or `gift_cards`)
     * have succeeded to get an authorization or direct sale **at any point
     * in time** then this will return a `succeeded` value.
     *
     * If any of the payment instruments fails or declines then this will
     * return a `failed` value.
     *
     * If any payment instruments is still in a `pending` or `processing` state
     * then the result will be `pending`.
     *
     * Please note that if any of the payment instruments are voided or refunded
     * after the result reaches a `succeeded` state  then the result will remain
     * unchanged.
     */
    intentOutcome?: IntentOutcome | undefined;
    /**
     * Indicates whether the transaction represents a subsequent payment
     *
     * @remarks
     * coming from a setup recurring payment.
     * Please note there are some restrictions on how this flag may be
     * used.
     *
     * The flag can only be `false` (or not set) when the transaction meets
     * one of the following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     *
     * The flag can only be set to `true` when the transaction meets one of the
     * following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and
     * `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    isSubsequentPayment?: boolean | undefined;
    /**
     * The ID of the merchant account to which this transaction belongs to.
     */
    merchantAccountId?: string | undefined;
    /**
     * Indicates whether the transaction was initiated by the merchant (true)
     *
     * @remarks
     * or customer (false).
     */
    merchantInitiated?: boolean | undefined;
    /**
     * Additional information about the transaction stored as key-value pairs.
     */
    metadata?: { [k: string]: string } | undefined;
    method?: TransactionMethod | null | undefined;
    /**
     * Defines if this transaction has been split across multiple payment instruments
     *
     * @remarks
     * such as a `payment_method` and one or more `gift_cards`, or multiple `gift_cards`
     * without a `payment_method`.
     */
    multiTender?: boolean | undefined;
    /**
     * The payment method used for this transaction.
     */
    paymentMethod?: TransactionPaymentMethodSnapshot | null | undefined;
    /**
     * The payment service used for this transaction.
     */
    paymentService?: TransactionAPaymentService | null | undefined;
    /**
     * The payment service's unique ID for the transaction.
     */
    paymentServiceTransactionId?: string | undefined;
    /**
     * The source of the transaction. Defaults to `ecommerce`.
     */
    paymentSource?: TransactionPaymentSource | undefined;
    /**
     * Whether a manual review is pending.
     */
    pendingReview?: boolean | undefined;
    /**
     * This is the response code received from the payment service. This
     *
     * @remarks
     * can be set to any value and is not standardized across different
     * payment services.
     */
    rawResponseCode?: string | null | undefined;
    /**
     * This is the response description received from the payment service. This
     *
     * @remarks
     * can be set to any value and is not standardized across different
     * payment services.
     */
    rawResponseDescription?: string | null | undefined;
    /**
     * The base62 encoded transaction ID. This represents a shorter version
     *
     * @remarks
     * of this transaction's `id` which is sent to payment services, anti-fraud services,
     * and other connectors. You can use this ID to reconcile a payment service's
     * transaction against our system.
     *
     * This ID is sent instead of the transaction ID because not all services
     * support 36 digit identifiers.
     */
    reconciliationId?: string | undefined;
    /**
     * The refunded amount for this transaction. This can be the full value
     *
     * @remarks
     * of the `captured_amount` or less.
     */
    refundedAmount?: number | undefined;
    /**
     * An identifier for the transaction used by the scheme itself, when
     *
     * @remarks
     * available.
     *
     * e.g. the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    schemeTransactionId?: string | null | undefined;
    /**
     * The shipping details associated with the transaction.
     */
    shippingDetails?: TransactionShippingDetail | null | undefined;
    statementDescriptor?: TransactionStatementDescriptor | null | undefined;
    /**
     * The status of the transaction for the `payment_method`. The status
     *
     * @remarks
     * may change over time as asynchronous processing events occur.
     *
     * Please note that the possible statuses returned will depend on the
     * operation performed. For example, a captured transaction will never
     * move to a `authorization_voided` status.
     */
    status?: TransactionStatus | undefined;
    /**
     * The 3-D Secure data that was sent to the payment
     *
     * @remarks
     * service for the transaction.
     */
    threeDSecure?: ThreeDSecureSummary | undefined;
    /**
     * Defines when the transaction was last updated.
     */
    updatedAt?: Date | undefined;
    /**
     * The date and time when this transaction was voided in the payment service.
     *
     * @remarks
     *
     * Don't use this field to determine whether the transaction was voided.
     * A `null` value doesn't necessarily imply that the transaction wasn't
     * voided, it can mean that the payment service doesn't provide this value,
     * that it didn't provide it at the time the transaction was voided or that
     * the transaction was voided before the introduction of this field.
     */
    voidedAt?: Date | null | undefined;
};

/** @internal */
export namespace TransactionType$ {
    export const inboundSchema = z.nativeEnum(TransactionType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace AvsResponseCode$ {
    export const inboundSchema = z.nativeEnum(AvsResponseCode);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionBuyerType$ {
    export const inboundSchema = z.nativeEnum(TransactionBuyerType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionBuyerBillingDetailsType$ {
    export const inboundSchema = z.nativeEnum(TransactionBuyerBillingDetailsType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionBuyerAddress$ {
    export const inboundSchema: z.ZodType<TransactionBuyerAddress, z.ZodTypeDef, unknown> = z
        .object({
            city: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            postal_code: z.nullable(z.string()).optional(),
            state: z.nullable(z.string()).optional(),
            state_code: z.nullable(z.string()).optional(),
            house_number_or_name: z.nullable(z.string()).optional(),
            line1: z.nullable(z.string()).optional(),
            line2: z.nullable(z.string()).optional(),
            organization: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                postal_code: "postalCode",
                state_code: "stateCode",
                house_number_or_name: "houseNumberOrName",
            });
        });

    export type Outbound = {
        city?: string | null | undefined;
        country?: string | null | undefined;
        postal_code?: string | null | undefined;
        state?: string | null | undefined;
        state_code?: string | null | undefined;
        house_number_or_name?: string | null | undefined;
        line1?: string | null | undefined;
        line2?: string | null | undefined;
        organization?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionBuyerAddress> = z
        .object({
            city: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            postalCode: z.nullable(z.string()).optional(),
            state: z.nullable(z.string()).optional(),
            stateCode: z.nullable(z.string()).optional(),
            houseNumberOrName: z.nullable(z.string()).optional(),
            line1: z.nullable(z.string()).optional(),
            line2: z.nullable(z.string()).optional(),
            organization: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                postalCode: "postal_code",
                stateCode: "state_code",
                houseNumberOrName: "house_number_or_name",
            });
        });
}

/** @internal */
export namespace TransactionKind$ {
    export const inboundSchema = z.nativeEnum(TransactionKind);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionTaxID$ {
    export const inboundSchema: z.ZodType<TransactionTaxID, z.ZodTypeDef, unknown> = z.object({
        value: z.string(),
        kind: TransactionKind$.inboundSchema,
    });

    export type Outbound = {
        value: string;
        kind: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionTaxID> = z.object({
        value: z.string(),
        kind: TransactionKind$.outboundSchema,
    });
}

/** @internal */
export namespace TransactionBillingDetails$ {
    export const inboundSchema: z.ZodType<TransactionBillingDetails, z.ZodTypeDef, unknown> = z
        .object({
            type: TransactionBuyerBillingDetailsType$.inboundSchema.optional(),
            first_name: z.nullable(z.string()).optional(),
            last_name: z.nullable(z.string()).optional(),
            email_address: z.nullable(z.string()).optional(),
            phone_number: z.nullable(z.string()).optional(),
            address: z.nullable(z.lazy(() => TransactionBuyerAddress$.inboundSchema)).optional(),
            tax_id: z.nullable(z.lazy(() => TransactionTaxID$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                first_name: "firstName",
                last_name: "lastName",
                email_address: "emailAddress",
                phone_number: "phoneNumber",
                tax_id: "taxId",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        first_name?: string | null | undefined;
        last_name?: string | null | undefined;
        email_address?: string | null | undefined;
        phone_number?: string | null | undefined;
        address?: TransactionBuyerAddress$.Outbound | null | undefined;
        tax_id?: TransactionTaxID$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionBillingDetails> = z
        .object({
            type: TransactionBuyerBillingDetailsType$.outboundSchema.optional(),
            firstName: z.nullable(z.string()).optional(),
            lastName: z.nullable(z.string()).optional(),
            emailAddress: z.nullable(z.string()).optional(),
            phoneNumber: z.nullable(z.string()).optional(),
            address: z.nullable(z.lazy(() => TransactionBuyerAddress$.outboundSchema)).optional(),
            taxId: z.nullable(z.lazy(() => TransactionTaxID$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                firstName: "first_name",
                lastName: "last_name",
                emailAddress: "email_address",
                phoneNumber: "phone_number",
                taxId: "tax_id",
            });
        });
}

/** @internal */
export namespace TransactionBuyerSnapshot$ {
    export const inboundSchema: z.ZodType<TransactionBuyerSnapshot, z.ZodTypeDef, unknown> = z
        .object({
            type: TransactionBuyerType$.inboundSchema.optional(),
            id: z.string().optional(),
            billing_details: z
                .nullable(z.lazy(() => TransactionBillingDetails$.inboundSchema))
                .optional(),
            display_name: z.nullable(z.string()).optional(),
            external_identifier: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                billing_details: "billingDetails",
                display_name: "displayName",
                external_identifier: "externalIdentifier",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        billing_details?: TransactionBillingDetails$.Outbound | null | undefined;
        display_name?: string | null | undefined;
        external_identifier?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionBuyerSnapshot> = z
        .object({
            type: TransactionBuyerType$.outboundSchema.optional(),
            id: z.string().optional(),
            billingDetails: z
                .nullable(z.lazy(() => TransactionBillingDetails$.outboundSchema))
                .optional(),
            displayName: z.nullable(z.string()).optional(),
            externalIdentifier: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                billingDetails: "billing_details",
                displayName: "display_name",
                externalIdentifier: "external_identifier",
            });
        });
}

/** @internal */
export namespace CvvResponseCode$ {
    export const inboundSchema = z.nativeEnum(CvvResponseCode);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionInstrumentType$ {
    export const inboundSchema = z.nativeEnum(TransactionInstrumentType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionIntent$ {
    export const inboundSchema = z.nativeEnum(TransactionIntent);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace IntentOutcome$ {
    export const inboundSchema = z.nativeEnum(IntentOutcome);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionMethod$ {
    export const inboundSchema = z.nativeEnum(TransactionMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionPaymentMethodType$ {
    export const inboundSchema = z.nativeEnum(TransactionPaymentMethodType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionApprovalTarget$ {
    export const inboundSchema = z.nativeEnum(TransactionApprovalTarget);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionCardType$ {
    export const inboundSchema = z.nativeEnum(TransactionCardType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionCard$ {
    export const inboundSchema: z.ZodType<TransactionCard, z.ZodTypeDef, unknown> = z
        .object({
            card_type: TransactionCardType$.inboundSchema.optional(),
            bin: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                card_type: "cardType",
            });
        });

    export type Outbound = {
        card_type?: string | undefined;
        bin?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionCard> = z
        .object({
            cardType: TransactionCardType$.outboundSchema.optional(),
            bin: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                cardType: "card_type",
            });
        });
}

/** @internal */
export namespace TransactionPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(TransactionPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionScheme$ {
    export const inboundSchema = z.nativeEnum(TransactionScheme);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionPaymentMethodSnapshot$ {
    export const inboundSchema: z.ZodType<TransactionPaymentMethodSnapshot, z.ZodTypeDef, unknown> =
        z
            .object({
                type: TransactionPaymentMethodType$.inboundSchema.optional(),
                id: z.nullable(z.string()).optional(),
                approval_target: z.nullable(TransactionApprovalTarget$.inboundSchema).optional(),
                approval_url: z.nullable(z.string()).optional(),
                country: z.nullable(z.string()).optional(),
                currency: z.nullable(z.string()).optional(),
                details: z.nullable(z.lazy(() => TransactionCard$.inboundSchema)).optional(),
                expiration_date: z.nullable(z.string()).optional(),
                external_identifier: z.nullable(z.string()).optional(),
                label: z.nullable(z.string()).optional(),
                last_replaced_at: z
                    .nullable(
                        z
                            .string()
                            .datetime({ offset: true })
                            .transform((v) => new Date(v))
                    )
                    .optional(),
                method: TransactionPaymentMethodMethod$.inboundSchema.optional(),
                payment_account_reference: z.nullable(z.string()).optional(),
                scheme: z.nullable(TransactionScheme$.inboundSchema).optional(),
                fingerprint: z.nullable(z.string()).optional(),
            })
            .transform((v) => {
                return remap$(v, {
                    approval_target: "approvalTarget",
                    approval_url: "approvalUrl",
                    expiration_date: "expirationDate",
                    external_identifier: "externalIdentifier",
                    last_replaced_at: "lastReplacedAt",
                    payment_account_reference: "paymentAccountReference",
                });
            });

    export type Outbound = {
        type?: string | undefined;
        id?: string | null | undefined;
        approval_target?: string | null | undefined;
        approval_url?: string | null | undefined;
        country?: string | null | undefined;
        currency?: string | null | undefined;
        details?: TransactionCard$.Outbound | null | undefined;
        expiration_date?: string | null | undefined;
        external_identifier?: string | null | undefined;
        label?: string | null | undefined;
        last_replaced_at?: string | null | undefined;
        method?: string | undefined;
        payment_account_reference?: string | null | undefined;
        scheme?: string | null | undefined;
        fingerprint?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        TransactionPaymentMethodSnapshot
    > = z
        .object({
            type: TransactionPaymentMethodType$.outboundSchema.optional(),
            id: z.nullable(z.string()).optional(),
            approvalTarget: z.nullable(TransactionApprovalTarget$.outboundSchema).optional(),
            approvalUrl: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            currency: z.nullable(z.string()).optional(),
            details: z.nullable(z.lazy(() => TransactionCard$.outboundSchema)).optional(),
            expirationDate: z.nullable(z.string()).optional(),
            externalIdentifier: z.nullable(z.string()).optional(),
            label: z.nullable(z.string()).optional(),
            lastReplacedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            method: TransactionPaymentMethodMethod$.outboundSchema.optional(),
            paymentAccountReference: z.nullable(z.string()).optional(),
            scheme: z.nullable(TransactionScheme$.outboundSchema).optional(),
            fingerprint: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                approvalTarget: "approval_target",
                approvalUrl: "approval_url",
                expirationDate: "expiration_date",
                externalIdentifier: "external_identifier",
                lastReplacedAt: "last_replaced_at",
                paymentAccountReference: "payment_account_reference",
            });
        });
}

/** @internal */
export namespace TransactionPaymentServiceType$ {
    export const inboundSchema = z.nativeEnum(TransactionPaymentServiceType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionPaymentServiceMethod$ {
    export const inboundSchema = z.nativeEnum(TransactionPaymentServiceMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionAPaymentService$ {
    export const inboundSchema: z.ZodType<TransactionAPaymentService, z.ZodTypeDef, unknown> = z
        .object({
            type: TransactionPaymentServiceType$.inboundSchema.optional(),
            id: z.string().optional(),
            display_name: z.string().optional(),
            method: TransactionPaymentServiceMethod$.inboundSchema.optional(),
            payment_service_definition_id: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                display_name: "displayName",
                payment_service_definition_id: "paymentServiceDefinitionId",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        display_name?: string | undefined;
        method?: string | undefined;
        payment_service_definition_id?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionAPaymentService> = z
        .object({
            type: TransactionPaymentServiceType$.outboundSchema.optional(),
            id: z.string().optional(),
            displayName: z.string().optional(),
            method: TransactionPaymentServiceMethod$.outboundSchema.optional(),
            paymentServiceDefinitionId: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                displayName: "display_name",
                paymentServiceDefinitionId: "payment_service_definition_id",
            });
        });
}

/** @internal */
export namespace TransactionPaymentSource$ {
    export const inboundSchema = z.nativeEnum(TransactionPaymentSource);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionShippingDetailsType$ {
    export const inboundSchema = z.nativeEnum(TransactionShippingDetailsType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionAddress$ {
    export const inboundSchema: z.ZodType<TransactionAddress, z.ZodTypeDef, unknown> = z
        .object({
            city: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            postal_code: z.nullable(z.string()).optional(),
            state: z.nullable(z.string()).optional(),
            state_code: z.nullable(z.string()).optional(),
            house_number_or_name: z.nullable(z.string()).optional(),
            line1: z.nullable(z.string()).optional(),
            line2: z.nullable(z.string()).optional(),
            organization: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                postal_code: "postalCode",
                state_code: "stateCode",
                house_number_or_name: "houseNumberOrName",
            });
        });

    export type Outbound = {
        city?: string | null | undefined;
        country?: string | null | undefined;
        postal_code?: string | null | undefined;
        state?: string | null | undefined;
        state_code?: string | null | undefined;
        house_number_or_name?: string | null | undefined;
        line1?: string | null | undefined;
        line2?: string | null | undefined;
        organization?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionAddress> = z
        .object({
            city: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            postalCode: z.nullable(z.string()).optional(),
            state: z.nullable(z.string()).optional(),
            stateCode: z.nullable(z.string()).optional(),
            houseNumberOrName: z.nullable(z.string()).optional(),
            line1: z.nullable(z.string()).optional(),
            line2: z.nullable(z.string()).optional(),
            organization: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                postalCode: "postal_code",
                stateCode: "state_code",
                houseNumberOrName: "house_number_or_name",
            });
        });
}

/** @internal */
export namespace TransactionShippingDetail$ {
    export const inboundSchema: z.ZodType<TransactionShippingDetail, z.ZodTypeDef, unknown> = z
        .object({
            type: TransactionShippingDetailsType$.inboundSchema.optional(),
            id: z.string().optional(),
            buyer_id: z.string().optional(),
            first_name: z.nullable(z.string()).optional(),
            last_name: z.nullable(z.string()).optional(),
            email_address: z.nullable(z.string()).optional(),
            phone_number: z.nullable(z.string()).optional(),
            address: z.nullable(z.lazy(() => TransactionAddress$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                buyer_id: "buyerId",
                first_name: "firstName",
                last_name: "lastName",
                email_address: "emailAddress",
                phone_number: "phoneNumber",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        buyer_id?: string | undefined;
        first_name?: string | null | undefined;
        last_name?: string | null | undefined;
        email_address?: string | null | undefined;
        phone_number?: string | null | undefined;
        address?: TransactionAddress$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionShippingDetail> = z
        .object({
            type: TransactionShippingDetailsType$.outboundSchema.optional(),
            id: z.string().optional(),
            buyerId: z.string().optional(),
            firstName: z.nullable(z.string()).optional(),
            lastName: z.nullable(z.string()).optional(),
            emailAddress: z.nullable(z.string()).optional(),
            phoneNumber: z.nullable(z.string()).optional(),
            address: z.nullable(z.lazy(() => TransactionAddress$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                buyerId: "buyer_id",
                firstName: "first_name",
                lastName: "last_name",
                emailAddress: "email_address",
                phoneNumber: "phone_number",
            });
        });
}

/** @internal */
export namespace TransactionStatementDescriptor$ {
    export const inboundSchema: z.ZodType<TransactionStatementDescriptor, z.ZodTypeDef, unknown> = z
        .object({
            name: z.nullable(z.string()).optional(),
            description: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
            phone_number: z.nullable(z.string()).optional(),
            url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                phone_number: "phoneNumber",
            });
        });

    export type Outbound = {
        name?: string | null | undefined;
        description?: string | null | undefined;
        city?: string | null | undefined;
        phone_number?: string | null | undefined;
        url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionStatementDescriptor> =
        z
            .object({
                name: z.nullable(z.string()).optional(),
                description: z.nullable(z.string()).optional(),
                city: z.nullable(z.string()).optional(),
                phoneNumber: z.nullable(z.string()).optional(),
                url: z.nullable(z.string()).optional(),
            })
            .transform((v) => {
                return remap$(v, {
                    phoneNumber: "phone_number",
                });
            });
}

/** @internal */
export namespace TransactionStatus$ {
    export const inboundSchema = z.nativeEnum(TransactionStatus);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Transaction$ {
    export const inboundSchema: z.ZodType<Transaction, z.ZodTypeDef, unknown> = z
        .object({
            type: TransactionType$.inboundSchema.optional(),
            id: z.string().optional(),
            amount: z.number().int().optional(),
            auth_response_code: z.nullable(z.string()).optional(),
            authorized_amount: z.number().int().optional(),
            authorized_at: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
            approval_expires_at: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
            avs_response_code: z.nullable(AvsResponseCode$.inboundSchema).optional(),
            buyer: z.nullable(z.lazy(() => TransactionBuyerSnapshot$.inboundSchema)).optional(),
            captured_amount: z.number().int().optional(),
            captured_at: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
            cart_items: z.array(CartItem$.inboundSchema).optional(),
            checkout_session_id: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            currency: z.string().optional(),
            cvv_response_code: z.nullable(CvvResponseCode$.inboundSchema).optional(),
            error_code: z.nullable(z.string()).optional(),
            external_identifier: z.nullable(z.string()).optional(),
            gift_card_service: GiftCardServiceSnapshot$.inboundSchema.optional(),
            gift_card_redemptions: z.array(GiftCardRedemption$.inboundSchema).optional(),
            instrument_type: z.nullable(TransactionInstrumentType$.inboundSchema).optional(),
            intent: TransactionIntent$.inboundSchema.optional(),
            intent_outcome: IntentOutcome$.inboundSchema.optional(),
            is_subsequent_payment: z.boolean().default(false),
            merchant_account_id: z.string().optional(),
            merchant_initiated: z.boolean().default(false),
            metadata: z.record(z.string()).optional(),
            method: z.nullable(TransactionMethod$.inboundSchema).optional(),
            multi_tender: z.boolean().optional(),
            payment_method: z
                .nullable(z.lazy(() => TransactionPaymentMethodSnapshot$.inboundSchema))
                .optional(),
            payment_service: z
                .nullable(z.lazy(() => TransactionAPaymentService$.inboundSchema))
                .optional(),
            payment_service_transaction_id: z.string().optional(),
            payment_source: TransactionPaymentSource$.inboundSchema.optional(),
            pending_review: z.boolean().optional(),
            raw_response_code: z.nullable(z.string()).optional(),
            raw_response_description: z.nullable(z.string()).optional(),
            reconciliation_id: z.string().optional(),
            refunded_amount: z.number().int().optional(),
            scheme_transaction_id: z.nullable(z.string()).default(null),
            shipping_details: z
                .nullable(z.lazy(() => TransactionShippingDetail$.inboundSchema))
                .optional(),
            statement_descriptor: z
                .nullable(z.lazy(() => TransactionStatementDescriptor$.inboundSchema))
                .optional(),
            status: TransactionStatus$.inboundSchema.optional(),
            three_d_secure: ThreeDSecureSummary$.inboundSchema.optional(),
            updated_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            voided_at: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                auth_response_code: "authResponseCode",
                authorized_amount: "authorizedAmount",
                authorized_at: "authorizedAt",
                approval_expires_at: "approvalExpiresAt",
                avs_response_code: "avsResponseCode",
                captured_amount: "capturedAmount",
                captured_at: "capturedAt",
                cart_items: "cartItems",
                checkout_session_id: "checkoutSessionId",
                created_at: "createdAt",
                cvv_response_code: "cvvResponseCode",
                error_code: "errorCode",
                external_identifier: "externalIdentifier",
                gift_card_service: "giftCardService",
                gift_card_redemptions: "giftCardRedemptions",
                instrument_type: "instrumentType",
                intent_outcome: "intentOutcome",
                is_subsequent_payment: "isSubsequentPayment",
                merchant_account_id: "merchantAccountId",
                merchant_initiated: "merchantInitiated",
                multi_tender: "multiTender",
                payment_method: "paymentMethod",
                payment_service: "paymentService",
                payment_service_transaction_id: "paymentServiceTransactionId",
                payment_source: "paymentSource",
                pending_review: "pendingReview",
                raw_response_code: "rawResponseCode",
                raw_response_description: "rawResponseDescription",
                reconciliation_id: "reconciliationId",
                refunded_amount: "refundedAmount",
                scheme_transaction_id: "schemeTransactionId",
                shipping_details: "shippingDetails",
                statement_descriptor: "statementDescriptor",
                three_d_secure: "threeDSecure",
                updated_at: "updatedAt",
                voided_at: "voidedAt",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        amount?: number | undefined;
        auth_response_code?: string | null | undefined;
        authorized_amount?: number | undefined;
        authorized_at?: string | null | undefined;
        approval_expires_at?: string | null | undefined;
        avs_response_code?: string | null | undefined;
        buyer?: TransactionBuyerSnapshot$.Outbound | null | undefined;
        captured_amount?: number | undefined;
        captured_at?: string | null | undefined;
        cart_items?: Array<CartItem$.Outbound> | undefined;
        checkout_session_id?: string | null | undefined;
        country?: string | null | undefined;
        created_at?: string | undefined;
        currency?: string | undefined;
        cvv_response_code?: string | null | undefined;
        error_code?: string | null | undefined;
        external_identifier?: string | null | undefined;
        gift_card_service?: GiftCardServiceSnapshot$.Outbound | undefined;
        gift_card_redemptions?: Array<GiftCardRedemption$.Outbound> | undefined;
        instrument_type?: string | null | undefined;
        intent?: string | undefined;
        intent_outcome?: string | undefined;
        is_subsequent_payment: boolean;
        merchant_account_id?: string | undefined;
        merchant_initiated: boolean;
        metadata?: { [k: string]: string } | undefined;
        method?: string | null | undefined;
        multi_tender?: boolean | undefined;
        payment_method?: TransactionPaymentMethodSnapshot$.Outbound | null | undefined;
        payment_service?: TransactionAPaymentService$.Outbound | null | undefined;
        payment_service_transaction_id?: string | undefined;
        payment_source?: string | undefined;
        pending_review?: boolean | undefined;
        raw_response_code?: string | null | undefined;
        raw_response_description?: string | null | undefined;
        reconciliation_id?: string | undefined;
        refunded_amount?: number | undefined;
        scheme_transaction_id: string | null;
        shipping_details?: TransactionShippingDetail$.Outbound | null | undefined;
        statement_descriptor?: TransactionStatementDescriptor$.Outbound | null | undefined;
        status?: string | undefined;
        three_d_secure?: ThreeDSecureSummary$.Outbound | undefined;
        updated_at?: string | undefined;
        voided_at?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Transaction> = z
        .object({
            type: TransactionType$.outboundSchema.optional(),
            id: z.string().optional(),
            amount: z.number().int().optional(),
            authResponseCode: z.nullable(z.string()).optional(),
            authorizedAmount: z.number().int().optional(),
            authorizedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            approvalExpiresAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            avsResponseCode: z.nullable(AvsResponseCode$.outboundSchema).optional(),
            buyer: z.nullable(z.lazy(() => TransactionBuyerSnapshot$.outboundSchema)).optional(),
            capturedAmount: z.number().int().optional(),
            capturedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            cartItems: z.array(CartItem$.outboundSchema).optional(),
            checkoutSessionId: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            currency: z.string().optional(),
            cvvResponseCode: z.nullable(CvvResponseCode$.outboundSchema).optional(),
            errorCode: z.nullable(z.string()).optional(),
            externalIdentifier: z.nullable(z.string()).optional(),
            giftCardService: GiftCardServiceSnapshot$.outboundSchema.optional(),
            giftCardRedemptions: z.array(GiftCardRedemption$.outboundSchema).optional(),
            instrumentType: z.nullable(TransactionInstrumentType$.outboundSchema).optional(),
            intent: TransactionIntent$.outboundSchema.optional(),
            intentOutcome: IntentOutcome$.outboundSchema.optional(),
            isSubsequentPayment: z.boolean().default(false),
            merchantAccountId: z.string().optional(),
            merchantInitiated: z.boolean().default(false),
            metadata: z.record(z.string()).optional(),
            method: z.nullable(TransactionMethod$.outboundSchema).optional(),
            multiTender: z.boolean().optional(),
            paymentMethod: z
                .nullable(z.lazy(() => TransactionPaymentMethodSnapshot$.outboundSchema))
                .optional(),
            paymentService: z
                .nullable(z.lazy(() => TransactionAPaymentService$.outboundSchema))
                .optional(),
            paymentServiceTransactionId: z.string().optional(),
            paymentSource: TransactionPaymentSource$.outboundSchema.optional(),
            pendingReview: z.boolean().optional(),
            rawResponseCode: z.nullable(z.string()).optional(),
            rawResponseDescription: z.nullable(z.string()).optional(),
            reconciliationId: z.string().optional(),
            refundedAmount: z.number().int().optional(),
            schemeTransactionId: z.nullable(z.string()).default(null),
            shippingDetails: z
                .nullable(z.lazy(() => TransactionShippingDetail$.outboundSchema))
                .optional(),
            statementDescriptor: z
                .nullable(z.lazy(() => TransactionStatementDescriptor$.outboundSchema))
                .optional(),
            status: TransactionStatus$.outboundSchema.optional(),
            threeDSecure: ThreeDSecureSummary$.outboundSchema.optional(),
            updatedAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            voidedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                authResponseCode: "auth_response_code",
                authorizedAmount: "authorized_amount",
                authorizedAt: "authorized_at",
                approvalExpiresAt: "approval_expires_at",
                avsResponseCode: "avs_response_code",
                capturedAmount: "captured_amount",
                capturedAt: "captured_at",
                cartItems: "cart_items",
                checkoutSessionId: "checkout_session_id",
                createdAt: "created_at",
                cvvResponseCode: "cvv_response_code",
                errorCode: "error_code",
                externalIdentifier: "external_identifier",
                giftCardService: "gift_card_service",
                giftCardRedemptions: "gift_card_redemptions",
                instrumentType: "instrument_type",
                intentOutcome: "intent_outcome",
                isSubsequentPayment: "is_subsequent_payment",
                merchantAccountId: "merchant_account_id",
                merchantInitiated: "merchant_initiated",
                multiTender: "multi_tender",
                paymentMethod: "payment_method",
                paymentService: "payment_service",
                paymentServiceTransactionId: "payment_service_transaction_id",
                paymentSource: "payment_source",
                pendingReview: "pending_review",
                rawResponseCode: "raw_response_code",
                rawResponseDescription: "raw_response_description",
                reconciliationId: "reconciliation_id",
                refundedAmount: "refunded_amount",
                schemeTransactionId: "scheme_transaction_id",
                shippingDetails: "shipping_details",
                statementDescriptor: "statement_descriptor",
                threeDSecure: "three_d_secure",
                updatedAt: "updated_at",
                voidedAt: "voided_at",
            });
        });
}
