/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";
import {
    CartItem,
    CartItem$inboundSchema,
    CartItem$Outbound,
    CartItem$outboundSchema,
} from "./cartitem.js";
import {
    ThreeDSecureDataV1,
    ThreeDSecureDataV1$inboundSchema,
    ThreeDSecureDataV1$Outbound,
    ThreeDSecureDataV1$outboundSchema,
} from "./threedsecuredatav1.js";
import {
    ThreeDSecureDataV2,
    ThreeDSecureDataV2$inboundSchema,
    ThreeDSecureDataV2$Outbound,
    ThreeDSecureDataV2$outboundSchema,
} from "./threedsecuredatav2.js";
import {
    TransactionGiftCardNewRequest,
    TransactionGiftCardNewRequest$inboundSchema,
    TransactionGiftCardNewRequest$Outbound,
    TransactionGiftCardNewRequest$outboundSchema,
} from "./transactiongiftcardnewrequest.js";
import {
    TransactionGiftCardStoredRequest,
    TransactionGiftCardStoredRequest$inboundSchema,
    TransactionGiftCardStoredRequest$Outbound,
    TransactionGiftCardStoredRequest$outboundSchema,
} from "./transactiongiftcardstoredrequest.js";
import * as z from "zod";

/**
 * `network-token`.
 */
export const TransactionNetworkTokenGooglePayRequestPaymentMethodMethod = {
    NetworkToken: "network-token",
} as const;
/**
 * `network-token`.
 */
export type TransactionNetworkTokenGooglePayRequestPaymentMethodMethod = ClosedEnum<
    typeof TransactionNetworkTokenGooglePayRequestPaymentMethodMethod
>;

export const PaymentMethodCardSource = {
    GooglePay: "google-pay",
} as const;
export type PaymentMethodCardSource = ClosedEnum<typeof PaymentMethodCardSource>;

/**
 * Details for a Google Pay decrypted token payment method.
 */
export type GooglePayDecryptedToken = {
    /**
     * `network-token`.
     */
    method: TransactionNetworkTokenGooglePayRequestPaymentMethodMethod;
    /**
     * The value of the decrypted Apple Pay token.
     */
    token: string;
    /**
     * The expiration date of the network token, formatted `MM/YY`.
     */
    expirationDate: string;
    /**
     * The cryptogram of the network token.
     */
    cryptogram?: string | null | undefined;
    /**
     * The electronic commerce indicator for 3D-Secure.
     */
    eci?: string | undefined;
    cardSource: PaymentMethodCardSource;
    /**
     * Last four digits of card PAN.
     */
    cardSuffix?: string | null | undefined;
    /**
     * The scheme/brand of the card.
     */
    cardScheme?: string | null | undefined;
    /**
     * The cardholder name.
     */
    cardholderName?: string | null | undefined;
};

/**
 * `network-token`.
 */
export const TransactionNetworkTokenApplePayRequestPaymentMethodMethod = {
    NetworkToken: "network-token",
} as const;
/**
 * `network-token`.
 */
export type TransactionNetworkTokenApplePayRequestPaymentMethodMethod = ClosedEnum<
    typeof TransactionNetworkTokenApplePayRequestPaymentMethodMethod
>;

export const CardSource = {
    ApplePay: "apple-pay",
} as const;
export type CardSource = ClosedEnum<typeof CardSource>;

/**
 * Details for an Apple Pay decrypted token payment method.
 */
export type ApplePayDecryptedToken = {
    /**
     * `network-token`.
     */
    method: TransactionNetworkTokenApplePayRequestPaymentMethodMethod;
    /**
     * The value of the decrypted Apple Pay token.
     */
    token: string;
    /**
     * The expiration date of the network token, formatted `MM/YY`.
     */
    expirationDate: string;
    /**
     * The cryptogram of the network token.
     */
    cryptogram?: string | null | undefined;
    /**
     * The electronic commerce indicator for 3D-Secure.
     */
    eci?: string | undefined;
    cardSource: CardSource;
    /**
     * Last four digits of card PAN.
     */
    cardSuffix?: string | null | undefined;
    /**
     * The scheme/brand of the card.
     */
    cardScheme?: string | null | undefined;
    /**
     * The cardholder name.
     */
    cardholderName?: string | null | undefined;
};

/**
 * `network-token`.
 */
export const TransactionNetworkTokenRequestPaymentMethodMethod = {
    NetworkToken: "network-token",
} as const;
/**
 * `network-token`.
 */
export type TransactionNetworkTokenRequestPaymentMethodMethod = ClosedEnum<
    typeof TransactionNetworkTokenRequestPaymentMethodMethod
>;

/**
 * Details for a Network Token payment method.
 */
export type NetworkTokenPaymentMethodRequest = {
    /**
     * `network-token`.
     */
    method: TransactionNetworkTokenRequestPaymentMethodMethod;
    /**
     * The value of the network token.
     */
    token: string;
    /**
     * The expiration date of the network token, formatted `MM/YY`.
     */
    expirationDate: string;
    /**
     * The cryptogram of the network token.
     */
    cryptogram?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `checkout-session`.
 */
export const TransactionCheckoutSessionRequestPaymentMethodMethod = {
    CheckoutSession: "checkout-session",
} as const;
/**
 * `checkout-session`.
 */
export type TransactionCheckoutSessionRequestPaymentMethodMethod = ClosedEnum<
    typeof TransactionCheckoutSessionRequestPaymentMethodMethod
>;

/**
 * Checkout Session payment method details to use in a transaction.
 */
export type PaymentMethodCheckoutSession = {
    /**
     * `checkout-session`.
     */
    method: TransactionCheckoutSessionRequestPaymentMethodMethod;
    /**
     * The ID of the Checkout Session.
     */
    id: string;
    /**
     * An external identifier that can be used to match the card against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `googlepay`.
 */
export const GooglePayRequestPaymentMethodMethod = {
    Googlepay: "googlepay",
} as const;
/**
 * `googlepay`.
 */
export type GooglePayRequestPaymentMethodMethod = ClosedEnum<
    typeof GooglePayRequestPaymentMethodMethod
>;

/**
 * Information about the validation performed on the payment data. (See https://developers.google.com/pay/api/web/reference/response-objects#assurance-details-specifications).
 */
export type AssuranceDetails = {
    /**
     * Indicates that card holder possession validation has been performed.
     */
    accountVerified?: boolean | null | undefined;
    /**
     * Indicates that identification and verifications was performed.
     */
    cardHolderAuthenticated?: boolean | null | undefined;
};

/**
 * Details for a Google Pay payment method.
 */
export type GooglePayPaymentMethodRequest = {
    /**
     * `googlepay`.
     */
    method: GooglePayRequestPaymentMethodMethod;
    /**
     * The encrypted (opaque) token returned by the Google Pay API that
     *
     * @remarks
     * represents a payment method.
     */
    token: string;
    /**
     * Last 4 digits of the PAN for identification purposes.
     */
    cardSuffix?: string | null | undefined;
    /**
     * The scheme/brand of the card.
     */
    cardScheme?: string | null | undefined;
    /**
     * The type of card.
     */
    cardType?: string | null | undefined;
    /**
     * Information about the validation performed on the payment data. (See https://developers.google.com/pay/api/web/reference/response-objects#assurance-details-specifications).
     */
    assuranceDetails?: AssuranceDetails | null | undefined;
    /**
     * Name of the card holder.
     */
    cardholderName?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `applepay`.
 */
export const ApplePayRequestPaymentMethodMethod = {
    Applepay: "applepay",
} as const;
/**
 * `applepay`.
 */
export type ApplePayRequestPaymentMethodMethod = ClosedEnum<
    typeof ApplePayRequestPaymentMethodMethod
>;

/**
 * The encrypted (opaque) token that was passed to the `onpaymentauthorized`
 *
 * @remarks
 * callback by the Apple Pay integration.
 */
export type Token = {};

/**
 * Details for a Apple Pay payment method.
 */
export type ApplePayPaymentMethodRequest = {
    /**
     * `applepay`.
     */
    method: ApplePayRequestPaymentMethodMethod;
    /**
     * The encrypted (opaque) token that was passed to the `onpaymentauthorized`
     *
     * @remarks
     * callback by the Apple Pay integration.
     */
    token: Token;
    /**
     * Last 4 digits of the PAN for identification purposes.
     */
    cardSuffix?: string | null | undefined;
    /**
     * The scheme/brand of the card.
     */
    cardScheme?: string | null | undefined;
    /**
     * The type of card.
     */
    cardType?: string | null | undefined;
};

/**
 * `id`.
 */
export const TokenizedRequestPaymentMethodMethod = {
    Id: "id",
} as const;
/**
 * `id`.
 */
export type TokenizedRequestPaymentMethodMethod = ClosedEnum<
    typeof TokenizedRequestPaymentMethodMethod
>;

/**
 * Details for a previously stored payment method.
 */
export type StoredPaymentMethodRequest = {
    /**
     * `id`.
     */
    method: TokenizedRequestPaymentMethodMethod;
    /**
     * A ID that represents a previously stored payment method.
     *
     * @remarks
     * This ID can represent any type of payment method.
     */
    id: string;
    /**
     * This value is mandatory for stored redirect payment methods.
     *
     * @remarks
     * For stored cards, we strongly recommend providing a `redirect_url`
     * either when 3-D Secure is enabled and `three_d_secure_data`
     * is not provided, or when using connections where 3DS is enabled.
     * This value will be appended with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure
     * has completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | undefined;
    /**
     * The 3 or 4 digit security code often found on the card. This often
     *
     * @remarks
     * referred to as the CVV or CVD.
     *
     * The security code can only be set if the stored payment method
     * represents a card.
     */
    securityCode?: string | null | undefined;
};

/**
 * The method to use, this can be any of the methods that
 *
 * @remarks
 * support redirect requests.
 */
export const TransactionRedirectRequestPaymentMethodMethod = {
    Paypal: "paypal",
    Banked: "banked",
    Bitpay: "bitpay",
    Gocardless: "gocardless",
    Stripedd: "stripedd",
} as const;
/**
 * The method to use, this can be any of the methods that
 *
 * @remarks
 * support redirect requests.
 */
export type TransactionRedirectRequestPaymentMethodMethod = ClosedEnum<
    typeof TransactionRedirectRequestPaymentMethodMethod
>;

/**
 * Redirect payment method details to use in a transaction.
 */
export type Redirect = {
    /**
     * The method to use, this can be any of the methods that
     *
     * @remarks
     * support redirect requests.
     */
    method: TransactionRedirectRequestPaymentMethodMethod;
    /**
     * The redirect URL to redirect a buyer to after they have authorized their
     *
     * @remarks
     * transaction.
     */
    redirectUrl: string;
    /**
     * The ISO-4217 currency code to use this payment method for. This is
     *
     * @remarks
     * used to select the payment service to use.
     */
    currency: string;
    /**
     * The 2-letter ISO code of the country to use this payment method for.
     *
     * @remarks
     * This is used to select the payment service to use.
     */
    country: string;
    /**
     * An external identifier that can be used to match the account against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
};

/**
 * `card`.
 */
export const TransactionCardRequestPaymentMethodMethod = {
    Card: "card",
} as const;
/**
 * `card`.
 */
export type TransactionCardRequestPaymentMethodMethod = ClosedEnum<
    typeof TransactionCardRequestPaymentMethodMethod
>;

/**
 * Card payment method details to use in a transaction.
 */
export type PaymentMethodCard = {
    /**
     * `card`.
     */
    method: TransactionCardRequestPaymentMethodMethod;
    /**
     * The 13-19 digit number for this card as it can be found on the
     *
     * @remarks
     * front of the card.
     */
    number: string;
    /**
     * The expiration date of the card, formatted `MM/YY`.
     */
    expirationDate: string;
    /**
     * The 3 or 4 digit security code often found on the card. This often
     *
     * @remarks
     * referred to as the CVV or CVD.
     */
    securityCode?: string | null | undefined;
    /**
     * An external identifier that can be used to match the card against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
 */
export type TransactionRequestPaymentMethod =
    | StoredPaymentMethodRequest
    | PaymentMethodCheckoutSession
    | Redirect
    | ApplePayPaymentMethodRequest
    | NetworkTokenPaymentMethodRequest
    | PaymentMethodCard
    | GooglePayPaymentMethodRequest
    | ApplePayDecryptedToken
    | GooglePayDecryptedToken;

/**
 * The platform that is being used to access the website.
 */
export const UserDevice = {
    Desktop: "desktop",
    Mobile: "mobile",
} as const;
/**
 * The platform that is being used to access the website.
 */
export type UserDevice = ClosedEnum<typeof UserDevice>;

/**
 * Information about the browser used by the buyer.
 */
export type BrowserInfo = {
    /**
     * Indicates whether the client browser supports Java.
     */
    javaEnabled: boolean;
    /**
     * Indicates whether the client browser supports JavaScript.
     */
    javascriptEnabled: boolean;
    /**
     * The preferred language of the buyer,
     *
     * @remarks
     * usually the language of the browser UI.
     */
    language: string;
    /**
     * The color depth of the screen.
     */
    colorDepth: number;
    /**
     * The height of the screen in pixels.
     */
    screenHeight: number;
    /**
     * The width of the screen in pixels.
     */
    screenWidth: number;
    /**
     * Time-zone offset in minutes between UTC and buyer location.
     */
    timeZoneOffset: number;
    /**
     * The platform that is being used to access the website.
     */
    userDevice: UserDevice;
    /**
     * The user agent string for the current browser.
     */
    userAgent: string;
    /**
     * The `Accept` header of the request from the buyer's browser.
     */
    acceptHeader?: string | undefined;
};

/**
 * Additional options for Cybersource payment gateway.
 */
export type CybersourceCard = {
    /**
     * An override for the merchant ID configured for the connector,
     *
     * @remarks
     * used in combination with meta keys.
     */
    metaKeyMerchantId?: string | null | undefined;
    /**
     * This is a key-value object for merchant defined information. Each key needs to be a
     *
     * @remarks
     * numeric string identifying the MDI field to set. For example, for field 1 set
     * the key to "1".
     */
    merchantDefinedInformation?: { [k: string]: string } | undefined;
    /**
     * Shipping method for the order.
     */
    shipToMethod?: string | null | undefined;
};

/**
 * Additional options for Cybersource Decision Manager (anti-fraud).
 */
export type CybersourceAntiFraud = {
    /**
     * An override for the merchant ID configured for the connector,
     *
     * @remarks
     * used in combination with meta keys.
     */
    metaKeyMerchantId?: string | null | undefined;
    /**
     * This is a key-value object for merchant defined data. Each key needs to be a
     *
     * @remarks
     * numeric string identifying the MDD field to set. For example, for field 1 set
     * the key to "1".
     */
    merchantDefinedData?: { [k: string]: string } | undefined;
    /**
     * Shipping method for the order.
     */
    shippingMethod?: string | null | undefined;
};

/**
 * Additional options for Giving Block connector.
 */
export type GivingblockGivingblock = {
    /**
     * The default crypto currency to display on the hosted page
     *
     * @remarks
     * presented by The Giving Block.
     */
    defaultCryptocurrency?: string | undefined;
};

/**
 * Value to populate the `deliveryType` field in `primaryDeliveryDetails`.
 *
 * @remarks
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export const DeliveryType = {
    Physical: "PHYSICAL",
    Digital: "DIGITAL",
    Hybrid: "HYBRID",
} as const;
/**
 * Value to populate the `deliveryType` field in `primaryDeliveryDetails`.
 *
 * @remarks
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export type DeliveryType = ClosedEnum<typeof DeliveryType>;

/**
 * Tangible if physical item, non-tangible if any other product.
 */
export const TransactionRequestType = {
    Tangible: "TANGIBLE",
    NonTangible: "NON_TANGIBLE",
} as const;
/**
 * Tangible if physical item, non-tangible if any other product.
 */
export type TransactionRequestType = ClosedEnum<typeof TransactionRequestType>;

/**
 * General data regarding item such as name, price, etc.
 */
export type BasicItemData = {
    /**
     * Tangible if physical item, non-tangible if any other product.
     */
    type?: TransactionRequestType | undefined;
};

/**
 * Value to populate the `deliveryType` field for this cart item. This overrides
 *
 * @remarks
 * the type set at the wider level.
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export const TransactionRequestDeliveryType = {
    Physical: "PHYSICAL",
    Digital: "DIGITAL",
    Hybrid: "HYBRID",
} as const;
/**
 * Value to populate the `deliveryType` field for this cart item. This overrides
 *
 * @remarks
 * the type set at the wider level.
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export type TransactionRequestDeliveryType = ClosedEnum<typeof TransactionRequestDeliveryType>;

/**
 * General data regarding item such as name, price, etc.
 */
export type DeliveryDetails = {
    /**
     * Value to populate the `deliveryType` field for this cart item. This overrides
     *
     * @remarks
     * the type set at the wider level.
     *
     * Represents the type of delivery. This can be set to `PHYSICAL` for any
     * type of shipped goods, `DIGITAL` for non-shipped goods (services,
     * gift cards etc.), or `HYBRID` for others.
     */
    deliveryType?: TransactionRequestDeliveryType | null | undefined;
    /**
     * Value to populate the `deliveryMethod` field for this cart item. This overrides
     *
     * @remarks
     * the method set at the wider level.
     *
     * Represents the delivery method chosen by customer such as postal service,
     * email, in game transfer, etc.
     */
    deliveryMethod?: string | undefined;
};

/**
 * Personal details are those which contribute to building up a picture
 *
 * @remarks
 * of the person as an individual, such as name, title, etc.
 */
export type PersonalDetails = {
    /**
     * First name.
     */
    firstName?: string | undefined;
    /**
     * Last name.
     */
    lastName?: string | undefined;
    /**
     * Email address.
     */
    email?: string | undefined;
};

/**
 * Address details for the beneficiary.
 */
export type TransactionRequestAddress = {
    /**
     * Country, two-letter ISO 3166-1 alpha 2 country code.
     */
    country: string;
    /**
     * Street-level address. Required when full address details are available.
     */
    address1?: string | null | undefined;
    /**
     * Unit-level address.
     */
    address2?: string | null | undefined;
    /**
     * Zipcode.
     */
    zip?: string | null | undefined;
    /**
     * Top-level administrative subdivision - state/province/department/etc.
     *
     * @remarks
     * Can be either abbreviated format or full name (NY/New York).
     */
    region?: string | null | undefined;
    /**
     * Company name.
     */
    company?: string | null | undefined;
    /**
     * City. Required when full address details are available.
     */
    city?: string | null | undefined;
};

export type Phone = {
    /**
     * Phone number including all country and local access codes.
     */
    phone: string;
};

/**
 * Comments to merchant or beneficiary written by customer.
 */
export type Comments = {
    /**
     * Comments the customer left to the merchant.
     */
    userCommentsToMerchant?: string | null | undefined;
    /**
     * Comments the customer left to the beneficiary of the purchase made.
     */
    messageToBeneficiary?: string | null | undefined;
    /**
     * Comments by the merchant.
     */
    merchantComments?: string | null | undefined;
};

export type Beneficiaries = {
    /**
     * Personal details are those which contribute to building up a picture
     *
     * @remarks
     * of the person as an individual, such as name, title, etc.
     */
    personalDetails: PersonalDetails;
    /**
     * Address details for the beneficiary.
     */
    address?: TransactionRequestAddress | null | undefined;
    /**
     * List of all phone numbers for the beneficiary.
     */
    phone?: Array<Phone> | undefined;
    /**
     * Comments to merchant or beneficiary written by customer.
     */
    comments?: Comments | null | undefined;
};

export type CartItems = {
    /**
     * General data regarding item such as name, price, etc.
     */
    basicItemData?: BasicItemData | undefined;
    /**
     * General data regarding item such as name, price, etc.
     */
    deliveryDetails?: DeliveryDetails | undefined;
    /**
     * List of all entities receiving or using the purchased cart item.
     */
    beneficiaries?: Array<Beneficiaries> | undefined;
};

/**
 * A monetary amount in USD or local currency.
 */
export type CouponDiscountAmount = {
    /**
     * Transaction amount in USD.
     */
    amountUsd?: string | undefined;
    /**
     * Transaction amount in currency chosen by the buyer.
     */
    amountLocalCurrency?: string | undefined;
    /**
     * Transaction currency chosen by the buyer, 3-letter ISO-4217 format currency code.
     */
    currency?: string | undefined;
};

/**
 * The `totalDiscount` object that's sent to Forter's validation API.
 *
 * @remarks
 * It represents the discount that was given to the customer.
 */
export type TotalDiscount = {
    /**
     * The coupon code used.
     */
    couponCodeUsed?: string | undefined;
    /**
     * The discount type.
     */
    discountType: string;
    /**
     * A monetary amount in USD or local currency.
     */
    couponDiscountAmount?: CouponDiscountAmount | null | undefined;
    /**
     * Coupon discount percentage.
     */
    couponDiscountPercent?: string | null | undefined;
};

/**
 * Additional options for Forter (anti-fraud).
 */
export type ForterAntiFraud = {
    /**
     * Value to populate the `deliveryType` field in `primaryDeliveryDetails`.
     *
     * @remarks
     *
     * Represents the type of delivery. This can be set to `PHYSICAL` for any
     * type of shipped goods, `DIGITAL` for non-shipped goods (services,
     * gift cards etc.), or `HYBRID` for others.
     */
    deliveryType?: DeliveryType | null | undefined;
    /**
     * Value to populate the `deliveryMethod` field in `primaryDeliveryDetails`.
     *
     * @remarks
     *
     * Represents the delivery method chosen by customer such as postal service,
     * email, in game transfer, etc.
     */
    deliveryMethod?: string | null | undefined;
    /**
     * Defines if this is a guest check-out. This will redact the `accountId` and
     *
     * @remarks
     * `created` fields from the `accountOwner` details sent to Forter.
     */
    isGuestBuyer?: boolean | undefined;
    /**
     * A list of Forter cart item objects. These will be merged into the `cart_items`
     *
     * @remarks
     * passed to the transaction. Every cart item here will be merged with a cart item
     * on the transaction with the same index.
     *
     * Together, these will augment the `cartItems` values sent to the Forter validation
     * API.
     */
    cartItems?: Array<CartItems> | undefined;
    /**
     * The `totalDiscount` object that's sent to Forter's validation API.
     *
     * @remarks
     * It represents the discount that was given to the customer.
     */
    totalDiscount?: TotalDiscount | null | undefined;
};

/**
 * Additional options to be passed through to Adyen when processing
 *
 * @remarks
 * card transactions.
 */
export type AdyenCard = {
    /**
     * A key-value object representing additional data to be passed
     *
     * @remarks
     * to Adyen.
     */
    additionalData?: { [k: string]: string } | undefined;
};

export type AdditionalData = {
    key?: string | undefined;
    value?: string | undefined;
};

/**
 * Additional options to be passed through to PayPal when processing
 *
 * @remarks
 * transactions.
 */
export type PaypalPaypal = {
    /**
     * An array with key-value objects representing additional
     *
     * @remarks
     * data to be passed to PayPal.
     */
    additionalData?: Array<AdditionalData> | undefined;
};

export type TransactionRequestAdditionalData = {
    key?: string | undefined;
    value?: string | undefined;
};

/**
 * Additional options to be passed through to PayPal when processing
 *
 * @remarks
 * transactions.
 */
export type PaypalPaypalpaylater = {
    /**
     * An array with key-value objects representing additional
     *
     * @remarks
     * data to be passed to PayPal.
     */
    additionalData?: Array<TransactionRequestAdditionalData> | undefined;
};

/**
 * Stripe Connect configuration options.
 */
export type StripeConnect = {
    /**
     * The ID of the connected Stripe account to process for.
     */
    stripeAccount?: string | null | undefined;
    /**
     * The application fee to charge when processing for a connected account.
     */
    applicationFeeAmount?: number | null | undefined;
    /**
     * The Stripe account ID that these funds are intended for.
     */
    onBehalfOf?: string | null | undefined;
};

/**
 * Additional options to be passed through to Stripe when processing
 *
 * @remarks
 * transactions.
 */
export type StripeCard = {
    /**
     * Defines if Stripe should automatically fail the payment if it
     *
     * @remarks
     * requires two-factor authentication from the user.
     */
    errorOnRequiresAction?: boolean | undefined;
    /**
     * Stripe Connect configuration options.
     */
    stripeConnect?: StripeConnect | null | undefined;
};

/**
 * Allows for passing optional configuration per connection to take
 *
 * @remarks
 * advantage of connection specific features. When provided, the data
 * is only passed to the target connection type to prevent sharing
 * configuration across connections.
 *
 * Please note that each of the keys this object are in kebab-case, for
 * example `cybersource-anti-fraud` as they represent the ID of the
 * connector. All the other keys will be snake case, for example
 * `merchant_defined_data` or camel case to match an external API that the
 * connector uses.
 */
export type ConnectionOptions = {
    /**
     * Additional options for Cybersource payment gateway.
     */
    cybersourceCard?: CybersourceCard | null | undefined;
    /**
     * Additional options for Cybersource Decision Manager (anti-fraud).
     */
    cybersourceAntiFraud?: CybersourceAntiFraud | null | undefined;
    /**
     * Additional options for Giving Block connector.
     */
    givingblockGivingblock?: GivingblockGivingblock | null | undefined;
    /**
     * Additional options for Forter (anti-fraud).
     */
    forterAntiFraud?: ForterAntiFraud | null | undefined;
    /**
     * Additional options to be passed through to Adyen when processing
     *
     * @remarks
     * card transactions.
     */
    adyenCard?: AdyenCard | null | undefined;
    /**
     * Additional options to be passed through to PayPal when processing
     *
     * @remarks
     * transactions.
     */
    paypalPaypal?: PaypalPaypal | null | undefined;
    /**
     * Additional options to be passed through to PayPal when processing
     *
     * @remarks
     * transactions.
     */
    paypalPaypalpaylater?: PaypalPaypalpaylater | null | undefined;
    /**
     * Additional options to be passed through to Stripe when processing
     *
     * @remarks
     * transactions.
     */
    stripeCard?: StripeCard | null | undefined;
};

export type TransactionRequestGiftCards =
    | TransactionGiftCardStoredRequest
    | TransactionGiftCardNewRequest;

/**
 * Defines the intent of this API call. This determines the desired initial
 *
 * @remarks
 * state of the transaction.
 *
 * * `authorize` - (Default) Optionally approves and then authorizes a
 * transaction but does not capture the funds.
 * * `capture` - Optionally approves and then authorizes and captures the
 * funds of the transaction.
 */
export const TransactionRequestIntent = {
    Authorize: "authorize",
    Capture: "capture",
} as const;
/**
 * Defines the intent of this API call. This determines the desired initial
 *
 * @remarks
 * state of the transaction.
 *
 * * `authorize` - (Default) Optionally approves and then authorizes a
 * transaction but does not capture the funds.
 * * `capture` - Optionally approves and then authorizes and captures the
 * funds of the transaction.
 */
export type TransactionRequestIntent = ClosedEnum<typeof TransactionRequestIntent>;

/**
 * The source of the transaction. Defaults to `ecommerce`.
 */
export const PaymentSource = {
    Ecommerce: "ecommerce",
    Moto: "moto",
    Recurring: "recurring",
    Installment: "installment",
    CardOnFile: "card_on_file",
} as const;
/**
 * The source of the transaction. Defaults to `ecommerce`.
 */
export type PaymentSource = ClosedEnum<typeof PaymentSource>;

/**
 * The statement descriptor is the text to be shown on the buyer's statements.
 *
 * @remarks
 *
 * The specific usage of these fields will depend on the capabilities of
 * the underlying PSP and bank. As a typical example, 'name' and
 * 'description' could be concatenated using '* ' as a separator, and
 * then the resulting descriptor would be truncated to 22 characters by
 * the issuing bank.
 */
export type StatementDescriptor = {
    /**
     * Reflects your doing business as (DBA) name.
     *
     * @remarks
     *
     * Other validations:
     *
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    name?: string | null | undefined;
    /**
     * A short description about the purchase.
     *
     * @remarks
     *
     * Other validations:
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    description?: string | null | undefined;
    /**
     * City from which the charge originated.
     */
    city?: string | null | undefined;
    /**
     * The value in the phone number field of a customer's statement which
     *
     * @remarks
     * should be formatted according to the
     * [E164 number standard](https://www.twilio.com/docs/glossary/what-e164).
     */
    phoneNumber?: string | null | undefined;
    /**
     * The value in the URL/web address field of a customer's statement.
     */
    url?: string | null | undefined;
};

/**
 * Pass through 3-D Secure data to support external 3-D Secure authorisation.
 *
 * @remarks
 * If using an external 3-D Secure provider, you should not pass
 * a `redirect_url` in the `payment_method` object for a transaction.
 */
export type ThreeDSecureData = ThreeDSecureDataV2 | ThreeDSecureDataV1;

/**
 * A request to create a transaction.
 */
export type TransactionRequest = {
    /**
     * The monetary amount for this transaction, in the smallest
     *
     * @remarks
     * currency unit for the given currency, for example `1299` cents to create
     * an authorization for `$12.99`.
     *
     * If the `intent` is set to `capture`, an amount greater than zero must
     * be supplied.
     *
     * All gift card amounts are subtracted from this amount before the
     * remainder is charged to the provided `payment_method`.
     */
    amount: number;
    /**
     * A supported ISO-4217 currency code.
     *
     * @remarks
     *
     * For redirect requests, this value must match the one specified for
     * `currency` in `payment_method`.
     *
     */
    currency: string;
    /**
     * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
     */
    paymentMethod?:
        | StoredPaymentMethodRequest
        | PaymentMethodCheckoutSession
        | Redirect
        | ApplePayPaymentMethodRequest
        | NetworkTokenPaymentMethodRequest
        | PaymentMethodCard
        | GooglePayPaymentMethodRequest
        | ApplePayDecryptedToken
        | GooglePayDecryptedToken
        | null
        | undefined;
    /**
     * This field represents the fingerprint data to be passed to the active
     *
     * @remarks
     * anti-fraud service.
     */
    antiFraudFingerprint?: string | null | undefined;
    /**
     * Whether to capture the transaction asynchronously.
     *
     * @remarks
     *
     * - When `async_capture` is `false` (default), the transaction is captured
     *   in the same request.
     * - When `async_capture` is `true`, the transaction is automatically
     *   captured at a later time.
     *
     * Redirect transactions are not affected by this flag.
     *
     * This flag can only be set to `true` when `intent` is set to `capture`.
     */
    asyncCapture?: boolean | undefined;
    /**
     * Information about the browser used by the buyer.
     */
    browserInfo?: BrowserInfo | null | undefined;
    /**
     * The `external_identifier` of the buyer to associate this payment method
     *
     * @remarks
     * to. If this field is provided then the `buyer_id` field
     * needs to be unset.
     *
     * If a stored payment method or gift card is provided, then the buyer for
     * that payment method needs to match the buyer for this field.
     */
    buyerExternalIdentifier?: string | undefined;
    /**
     * The ID of the buyer to associate this payment method to. If this field is
     *
     * @remarks
     * provided then the `buyer_external_identifier` field needs to be unset.
     *
     * If a stored payment method or gift card is provided, then the buyer for
     * that payment method needs to match the buyer for this field.
     */
    buyerId?: string | undefined;
    /**
     * An array of cart items that represents the line items of a transaction.
     */
    cartItems?: Array<CartItem> | undefined;
    /**
     * Allows for passing optional configuration per connection to take
     *
     * @remarks
     * advantage of connection specific features. When provided, the data
     * is only passed to the target connection type to prevent sharing
     * configuration across connections.
     *
     * Please note that each of the keys this object are in kebab-case, for
     * example `cybersource-anti-fraud` as they represent the ID of the
     * connector. All the other keys will be snake case, for example
     * `merchant_defined_data` or camel case to match an external API that the
     * connector uses.
     */
    connectionOptions?: ConnectionOptions | null | undefined;
    /**
     * The 2-letter ISO code of the country of the transaction.
     *
     * @remarks
     * This is used to filter the payment services that is used to process the
     * transaction.
     *
     * If this value is provided for redirect requests and it's not `null`, it
     * must match the one specified for `country` in `payment_method`. Otherwise,
     * the value specified for `country` in `payment_method` will be assumed
     * implicitly.
     *
     */
    country?: string | null | undefined;
    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added.
     *
     * @remarks
     * By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
     */
    giftCards?:
        | Array<TransactionGiftCardStoredRequest | TransactionGiftCardNewRequest>
        | null
        | undefined;
    /**
     * Defines the intent of this API call. This determines the desired initial
     *
     * @remarks
     * state of the transaction.
     *
     * * `authorize` - (Default) Optionally approves and then authorizes a
     * transaction but does not capture the funds.
     * * `capture` - Optionally approves and then authorizes and captures the
     * funds of the transaction.
     */
    intent?: TransactionRequestIntent | undefined;
    /**
     * Indicates whether the transaction represents a subsequent payment
     *
     * @remarks
     * coming from a setup recurring payment.
     * Please note there are some restrictions on how this flag may be
     * used.
     *
     * The flag can only be `false` (or not set) when the transaction meets
     * one of the following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     *
     * The flag can only be set to `true` when the transaction meets one of the
     * following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and
     * `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    isSubsequentPayment?: boolean | undefined;
    /**
     * Indicates whether the transaction was initiated by the merchant (true)
     *
     * @remarks
     * or customer (false).
     */
    merchantInitiated?: boolean | undefined;
    /**
     * Any additional information about the transaction that you would like to
     *
     * @remarks
     * store as key-value pairs. This data is passed to payment service
     * providers that support it.
     */
    metadata?: { [k: string]: string } | undefined;
    /**
     * The source of the transaction. Defaults to `ecommerce`.
     */
    paymentSource?: PaymentSource | undefined;
    /**
     * A scheme's transaction identifier to use in connecting a merchant
     *
     * @remarks
     * initiated transaction to a previous customer initiated transaction.
     *
     * If not provided, and a qualifying customer initiated transaction has been
     * previously made, then Gr4vy will populate this value with the identifier
     * returned for that transaction.
     *
     * e.g. the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    previousSchemeTransactionId?: string | null | undefined;
    /**
     * The unique identifier of a set of shipping details stored for the buyer.
     *
     * @remarks
     *
     * If provided, the created transaction will include a copy of the details
     * at the point of transaction creation; i.e. it will not be affected by
     * later changes to the detail in the database.
     */
    shippingDetailsId?: string | null | undefined;
    statementDescriptor?: StatementDescriptor | null | undefined;
    /**
     * Whether or not to also try and store the payment method with us so that
     *
     * @remarks
     * it can be used again for future use. This is only supported for payment
     * methods that support this feature. There are also a few restrictions on
     * how the flag may be set:
     *
     * * The flag has to be set to `true` when the `payment_source` is set to
     * `recurring` or `installment`, and `merchant_initiated` is set to `false`.
     *
     * * The flag has to be set to `false` (or not set) when using a previously
     * vaulted payment method.
     */
    store?: boolean | undefined;
    /**
     * Pass through 3-D Secure data to support external 3-D Secure authorisation.
     *
     * @remarks
     * If using an external 3-D Secure provider, you should not pass
     * a `redirect_url` in the `payment_method` object for a transaction.
     */
    threeDSecureData?: ThreeDSecureDataV2 | ThreeDSecureDataV1 | undefined;
    /**
     * The unique identifier of an existing payment service. When
     *
     * @remarks
     * provided, the created transaction will be processed by the given
     * payment service and any routing rules will be skipped.
     */
    paymentServiceId?: string | null | undefined;
};

/** @internal */
export const TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof TransactionNetworkTokenGooglePayRequestPaymentMethodMethod
> = z.nativeEnum(TransactionNetworkTokenGooglePayRequestPaymentMethodMethod);

/** @internal */
export const TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof TransactionNetworkTokenGooglePayRequestPaymentMethodMethod
> = TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$ {
    /** @deprecated use `TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema =
        TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema =
        TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const PaymentMethodCardSource$inboundSchema: z.ZodNativeEnum<
    typeof PaymentMethodCardSource
> = z.nativeEnum(PaymentMethodCardSource);

/** @internal */
export const PaymentMethodCardSource$outboundSchema: z.ZodNativeEnum<
    typeof PaymentMethodCardSource
> = PaymentMethodCardSource$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentMethodCardSource$ {
    /** @deprecated use `PaymentMethodCardSource$inboundSchema` instead. */
    export const inboundSchema = PaymentMethodCardSource$inboundSchema;
    /** @deprecated use `PaymentMethodCardSource$outboundSchema` instead. */
    export const outboundSchema = PaymentMethodCardSource$outboundSchema;
}

/** @internal */
export const GooglePayDecryptedToken$inboundSchema: z.ZodType<
    GooglePayDecryptedToken,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        method: TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$inboundSchema,
        token: z.string(),
        expiration_date: z.string(),
        cryptogram: z.nullable(z.string()).optional(),
        eci: z.string().optional(),
        card_source: PaymentMethodCardSource$inboundSchema,
        card_suffix: z.nullable(z.string()).optional(),
        card_scheme: z.nullable(z.string()).optional(),
        cardholder_name: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            expiration_date: "expirationDate",
            card_source: "cardSource",
            card_suffix: "cardSuffix",
            card_scheme: "cardScheme",
            cardholder_name: "cardholderName",
        });
    });

/** @internal */
export type GooglePayDecryptedToken$Outbound = {
    method: string;
    token: string;
    expiration_date: string;
    cryptogram?: string | null | undefined;
    eci?: string | undefined;
    card_source: string;
    card_suffix?: string | null | undefined;
    card_scheme?: string | null | undefined;
    cardholder_name?: string | null | undefined;
};

/** @internal */
export const GooglePayDecryptedToken$outboundSchema: z.ZodType<
    GooglePayDecryptedToken$Outbound,
    z.ZodTypeDef,
    GooglePayDecryptedToken
> = z
    .object({
        method: TransactionNetworkTokenGooglePayRequestPaymentMethodMethod$outboundSchema,
        token: z.string(),
        expirationDate: z.string(),
        cryptogram: z.nullable(z.string()).optional(),
        eci: z.string().optional(),
        cardSource: PaymentMethodCardSource$outboundSchema,
        cardSuffix: z.nullable(z.string()).optional(),
        cardScheme: z.nullable(z.string()).optional(),
        cardholderName: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            expirationDate: "expiration_date",
            cardSource: "card_source",
            cardSuffix: "card_suffix",
            cardScheme: "card_scheme",
            cardholderName: "cardholder_name",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GooglePayDecryptedToken$ {
    /** @deprecated use `GooglePayDecryptedToken$inboundSchema` instead. */
    export const inboundSchema = GooglePayDecryptedToken$inboundSchema;
    /** @deprecated use `GooglePayDecryptedToken$outboundSchema` instead. */
    export const outboundSchema = GooglePayDecryptedToken$outboundSchema;
    /** @deprecated use `GooglePayDecryptedToken$Outbound` instead. */
    export type Outbound = GooglePayDecryptedToken$Outbound;
}

/** @internal */
export const TransactionNetworkTokenApplePayRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof TransactionNetworkTokenApplePayRequestPaymentMethodMethod
> = z.nativeEnum(TransactionNetworkTokenApplePayRequestPaymentMethodMethod);

/** @internal */
export const TransactionNetworkTokenApplePayRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof TransactionNetworkTokenApplePayRequestPaymentMethodMethod
> = TransactionNetworkTokenApplePayRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionNetworkTokenApplePayRequestPaymentMethodMethod$ {
    /** @deprecated use `TransactionNetworkTokenApplePayRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema =
        TransactionNetworkTokenApplePayRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `TransactionNetworkTokenApplePayRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema =
        TransactionNetworkTokenApplePayRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const CardSource$inboundSchema: z.ZodNativeEnum<typeof CardSource> =
    z.nativeEnum(CardSource);

/** @internal */
export const CardSource$outboundSchema: z.ZodNativeEnum<typeof CardSource> =
    CardSource$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CardSource$ {
    /** @deprecated use `CardSource$inboundSchema` instead. */
    export const inboundSchema = CardSource$inboundSchema;
    /** @deprecated use `CardSource$outboundSchema` instead. */
    export const outboundSchema = CardSource$outboundSchema;
}

/** @internal */
export const ApplePayDecryptedToken$inboundSchema: z.ZodType<
    ApplePayDecryptedToken,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        method: TransactionNetworkTokenApplePayRequestPaymentMethodMethod$inboundSchema,
        token: z.string(),
        expiration_date: z.string(),
        cryptogram: z.nullable(z.string()).optional(),
        eci: z.string().optional(),
        card_source: CardSource$inboundSchema,
        card_suffix: z.nullable(z.string()).optional(),
        card_scheme: z.nullable(z.string()).optional(),
        cardholder_name: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            expiration_date: "expirationDate",
            card_source: "cardSource",
            card_suffix: "cardSuffix",
            card_scheme: "cardScheme",
            cardholder_name: "cardholderName",
        });
    });

/** @internal */
export type ApplePayDecryptedToken$Outbound = {
    method: string;
    token: string;
    expiration_date: string;
    cryptogram?: string | null | undefined;
    eci?: string | undefined;
    card_source: string;
    card_suffix?: string | null | undefined;
    card_scheme?: string | null | undefined;
    cardholder_name?: string | null | undefined;
};

/** @internal */
export const ApplePayDecryptedToken$outboundSchema: z.ZodType<
    ApplePayDecryptedToken$Outbound,
    z.ZodTypeDef,
    ApplePayDecryptedToken
> = z
    .object({
        method: TransactionNetworkTokenApplePayRequestPaymentMethodMethod$outboundSchema,
        token: z.string(),
        expirationDate: z.string(),
        cryptogram: z.nullable(z.string()).optional(),
        eci: z.string().optional(),
        cardSource: CardSource$outboundSchema,
        cardSuffix: z.nullable(z.string()).optional(),
        cardScheme: z.nullable(z.string()).optional(),
        cardholderName: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            expirationDate: "expiration_date",
            cardSource: "card_source",
            cardSuffix: "card_suffix",
            cardScheme: "card_scheme",
            cardholderName: "cardholder_name",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApplePayDecryptedToken$ {
    /** @deprecated use `ApplePayDecryptedToken$inboundSchema` instead. */
    export const inboundSchema = ApplePayDecryptedToken$inboundSchema;
    /** @deprecated use `ApplePayDecryptedToken$outboundSchema` instead. */
    export const outboundSchema = ApplePayDecryptedToken$outboundSchema;
    /** @deprecated use `ApplePayDecryptedToken$Outbound` instead. */
    export type Outbound = ApplePayDecryptedToken$Outbound;
}

/** @internal */
export const TransactionNetworkTokenRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof TransactionNetworkTokenRequestPaymentMethodMethod
> = z.nativeEnum(TransactionNetworkTokenRequestPaymentMethodMethod);

/** @internal */
export const TransactionNetworkTokenRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof TransactionNetworkTokenRequestPaymentMethodMethod
> = TransactionNetworkTokenRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionNetworkTokenRequestPaymentMethodMethod$ {
    /** @deprecated use `TransactionNetworkTokenRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema = TransactionNetworkTokenRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `TransactionNetworkTokenRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema = TransactionNetworkTokenRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const NetworkTokenPaymentMethodRequest$inboundSchema: z.ZodType<
    NetworkTokenPaymentMethodRequest,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        method: TransactionNetworkTokenRequestPaymentMethodMethod$inboundSchema,
        token: z.string(),
        expiration_date: z.string(),
        cryptogram: z.nullable(z.string()).optional(),
        redirect_url: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            expiration_date: "expirationDate",
            redirect_url: "redirectUrl",
        });
    });

/** @internal */
export type NetworkTokenPaymentMethodRequest$Outbound = {
    method: string;
    token: string;
    expiration_date: string;
    cryptogram?: string | null | undefined;
    redirect_url?: string | null | undefined;
};

/** @internal */
export const NetworkTokenPaymentMethodRequest$outboundSchema: z.ZodType<
    NetworkTokenPaymentMethodRequest$Outbound,
    z.ZodTypeDef,
    NetworkTokenPaymentMethodRequest
> = z
    .object({
        method: TransactionNetworkTokenRequestPaymentMethodMethod$outboundSchema,
        token: z.string(),
        expirationDate: z.string(),
        cryptogram: z.nullable(z.string()).optional(),
        redirectUrl: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            expirationDate: "expiration_date",
            redirectUrl: "redirect_url",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NetworkTokenPaymentMethodRequest$ {
    /** @deprecated use `NetworkTokenPaymentMethodRequest$inboundSchema` instead. */
    export const inboundSchema = NetworkTokenPaymentMethodRequest$inboundSchema;
    /** @deprecated use `NetworkTokenPaymentMethodRequest$outboundSchema` instead. */
    export const outboundSchema = NetworkTokenPaymentMethodRequest$outboundSchema;
    /** @deprecated use `NetworkTokenPaymentMethodRequest$Outbound` instead. */
    export type Outbound = NetworkTokenPaymentMethodRequest$Outbound;
}

/** @internal */
export const TransactionCheckoutSessionRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof TransactionCheckoutSessionRequestPaymentMethodMethod
> = z.nativeEnum(TransactionCheckoutSessionRequestPaymentMethodMethod);

/** @internal */
export const TransactionCheckoutSessionRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof TransactionCheckoutSessionRequestPaymentMethodMethod
> = TransactionCheckoutSessionRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionCheckoutSessionRequestPaymentMethodMethod$ {
    /** @deprecated use `TransactionCheckoutSessionRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema = TransactionCheckoutSessionRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `TransactionCheckoutSessionRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema =
        TransactionCheckoutSessionRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const PaymentMethodCheckoutSession$inboundSchema: z.ZodType<
    PaymentMethodCheckoutSession,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        method: TransactionCheckoutSessionRequestPaymentMethodMethod$inboundSchema,
        id: z.string(),
        external_identifier: z.nullable(z.string()).optional(),
        redirect_url: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            external_identifier: "externalIdentifier",
            redirect_url: "redirectUrl",
        });
    });

/** @internal */
export type PaymentMethodCheckoutSession$Outbound = {
    method: string;
    id: string;
    external_identifier?: string | null | undefined;
    redirect_url?: string | null | undefined;
};

/** @internal */
export const PaymentMethodCheckoutSession$outboundSchema: z.ZodType<
    PaymentMethodCheckoutSession$Outbound,
    z.ZodTypeDef,
    PaymentMethodCheckoutSession
> = z
    .object({
        method: TransactionCheckoutSessionRequestPaymentMethodMethod$outboundSchema,
        id: z.string(),
        externalIdentifier: z.nullable(z.string()).optional(),
        redirectUrl: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            externalIdentifier: "external_identifier",
            redirectUrl: "redirect_url",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentMethodCheckoutSession$ {
    /** @deprecated use `PaymentMethodCheckoutSession$inboundSchema` instead. */
    export const inboundSchema = PaymentMethodCheckoutSession$inboundSchema;
    /** @deprecated use `PaymentMethodCheckoutSession$outboundSchema` instead. */
    export const outboundSchema = PaymentMethodCheckoutSession$outboundSchema;
    /** @deprecated use `PaymentMethodCheckoutSession$Outbound` instead. */
    export type Outbound = PaymentMethodCheckoutSession$Outbound;
}

/** @internal */
export const GooglePayRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof GooglePayRequestPaymentMethodMethod
> = z.nativeEnum(GooglePayRequestPaymentMethodMethod);

/** @internal */
export const GooglePayRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof GooglePayRequestPaymentMethodMethod
> = GooglePayRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GooglePayRequestPaymentMethodMethod$ {
    /** @deprecated use `GooglePayRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema = GooglePayRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `GooglePayRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema = GooglePayRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const AssuranceDetails$inboundSchema: z.ZodType<AssuranceDetails, z.ZodTypeDef, unknown> = z
    .object({
        account_verified: z.nullable(z.boolean()).optional(),
        card_holder_authenticated: z.nullable(z.boolean()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            account_verified: "accountVerified",
            card_holder_authenticated: "cardHolderAuthenticated",
        });
    });

/** @internal */
export type AssuranceDetails$Outbound = {
    account_verified?: boolean | null | undefined;
    card_holder_authenticated?: boolean | null | undefined;
};

/** @internal */
export const AssuranceDetails$outboundSchema: z.ZodType<
    AssuranceDetails$Outbound,
    z.ZodTypeDef,
    AssuranceDetails
> = z
    .object({
        accountVerified: z.nullable(z.boolean()).optional(),
        cardHolderAuthenticated: z.nullable(z.boolean()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            accountVerified: "account_verified",
            cardHolderAuthenticated: "card_holder_authenticated",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssuranceDetails$ {
    /** @deprecated use `AssuranceDetails$inboundSchema` instead. */
    export const inboundSchema = AssuranceDetails$inboundSchema;
    /** @deprecated use `AssuranceDetails$outboundSchema` instead. */
    export const outboundSchema = AssuranceDetails$outboundSchema;
    /** @deprecated use `AssuranceDetails$Outbound` instead. */
    export type Outbound = AssuranceDetails$Outbound;
}

/** @internal */
export const GooglePayPaymentMethodRequest$inboundSchema: z.ZodType<
    GooglePayPaymentMethodRequest,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        method: GooglePayRequestPaymentMethodMethod$inboundSchema,
        token: z.string(),
        card_suffix: z.nullable(z.string()).optional(),
        card_scheme: z.nullable(z.string()).optional(),
        card_type: z.nullable(z.string()).optional(),
        assurance_details: z.nullable(z.lazy(() => AssuranceDetails$inboundSchema)).optional(),
        cardholder_name: z.nullable(z.string()).optional(),
        redirect_url: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            card_suffix: "cardSuffix",
            card_scheme: "cardScheme",
            card_type: "cardType",
            assurance_details: "assuranceDetails",
            cardholder_name: "cardholderName",
            redirect_url: "redirectUrl",
        });
    });

/** @internal */
export type GooglePayPaymentMethodRequest$Outbound = {
    method: string;
    token: string;
    card_suffix?: string | null | undefined;
    card_scheme?: string | null | undefined;
    card_type?: string | null | undefined;
    assurance_details?: AssuranceDetails$Outbound | null | undefined;
    cardholder_name?: string | null | undefined;
    redirect_url?: string | null | undefined;
};

/** @internal */
export const GooglePayPaymentMethodRequest$outboundSchema: z.ZodType<
    GooglePayPaymentMethodRequest$Outbound,
    z.ZodTypeDef,
    GooglePayPaymentMethodRequest
> = z
    .object({
        method: GooglePayRequestPaymentMethodMethod$outboundSchema,
        token: z.string(),
        cardSuffix: z.nullable(z.string()).optional(),
        cardScheme: z.nullable(z.string()).optional(),
        cardType: z.nullable(z.string()).optional(),
        assuranceDetails: z.nullable(z.lazy(() => AssuranceDetails$outboundSchema)).optional(),
        cardholderName: z.nullable(z.string()).optional(),
        redirectUrl: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            cardSuffix: "card_suffix",
            cardScheme: "card_scheme",
            cardType: "card_type",
            assuranceDetails: "assurance_details",
            cardholderName: "cardholder_name",
            redirectUrl: "redirect_url",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GooglePayPaymentMethodRequest$ {
    /** @deprecated use `GooglePayPaymentMethodRequest$inboundSchema` instead. */
    export const inboundSchema = GooglePayPaymentMethodRequest$inboundSchema;
    /** @deprecated use `GooglePayPaymentMethodRequest$outboundSchema` instead. */
    export const outboundSchema = GooglePayPaymentMethodRequest$outboundSchema;
    /** @deprecated use `GooglePayPaymentMethodRequest$Outbound` instead. */
    export type Outbound = GooglePayPaymentMethodRequest$Outbound;
}

/** @internal */
export const ApplePayRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof ApplePayRequestPaymentMethodMethod
> = z.nativeEnum(ApplePayRequestPaymentMethodMethod);

/** @internal */
export const ApplePayRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof ApplePayRequestPaymentMethodMethod
> = ApplePayRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApplePayRequestPaymentMethodMethod$ {
    /** @deprecated use `ApplePayRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema = ApplePayRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `ApplePayRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema = ApplePayRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const Token$inboundSchema: z.ZodType<Token, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Token$Outbound = {};

/** @internal */
export const Token$outboundSchema: z.ZodType<Token$Outbound, z.ZodTypeDef, Token> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Token$ {
    /** @deprecated use `Token$inboundSchema` instead. */
    export const inboundSchema = Token$inboundSchema;
    /** @deprecated use `Token$outboundSchema` instead. */
    export const outboundSchema = Token$outboundSchema;
    /** @deprecated use `Token$Outbound` instead. */
    export type Outbound = Token$Outbound;
}

/** @internal */
export const ApplePayPaymentMethodRequest$inboundSchema: z.ZodType<
    ApplePayPaymentMethodRequest,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        method: ApplePayRequestPaymentMethodMethod$inboundSchema,
        token: z.lazy(() => Token$inboundSchema),
        card_suffix: z.nullable(z.string()).optional(),
        card_scheme: z.nullable(z.string()).optional(),
        card_type: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            card_suffix: "cardSuffix",
            card_scheme: "cardScheme",
            card_type: "cardType",
        });
    });

/** @internal */
export type ApplePayPaymentMethodRequest$Outbound = {
    method: string;
    token: Token$Outbound;
    card_suffix?: string | null | undefined;
    card_scheme?: string | null | undefined;
    card_type?: string | null | undefined;
};

/** @internal */
export const ApplePayPaymentMethodRequest$outboundSchema: z.ZodType<
    ApplePayPaymentMethodRequest$Outbound,
    z.ZodTypeDef,
    ApplePayPaymentMethodRequest
> = z
    .object({
        method: ApplePayRequestPaymentMethodMethod$outboundSchema,
        token: z.lazy(() => Token$outboundSchema),
        cardSuffix: z.nullable(z.string()).optional(),
        cardScheme: z.nullable(z.string()).optional(),
        cardType: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            cardSuffix: "card_suffix",
            cardScheme: "card_scheme",
            cardType: "card_type",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApplePayPaymentMethodRequest$ {
    /** @deprecated use `ApplePayPaymentMethodRequest$inboundSchema` instead. */
    export const inboundSchema = ApplePayPaymentMethodRequest$inboundSchema;
    /** @deprecated use `ApplePayPaymentMethodRequest$outboundSchema` instead. */
    export const outboundSchema = ApplePayPaymentMethodRequest$outboundSchema;
    /** @deprecated use `ApplePayPaymentMethodRequest$Outbound` instead. */
    export type Outbound = ApplePayPaymentMethodRequest$Outbound;
}

/** @internal */
export const TokenizedRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof TokenizedRequestPaymentMethodMethod
> = z.nativeEnum(TokenizedRequestPaymentMethodMethod);

/** @internal */
export const TokenizedRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof TokenizedRequestPaymentMethodMethod
> = TokenizedRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TokenizedRequestPaymentMethodMethod$ {
    /** @deprecated use `TokenizedRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema = TokenizedRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `TokenizedRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema = TokenizedRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const StoredPaymentMethodRequest$inboundSchema: z.ZodType<
    StoredPaymentMethodRequest,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        method: TokenizedRequestPaymentMethodMethod$inboundSchema,
        id: z.string(),
        redirect_url: z.string().optional(),
        security_code: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            redirect_url: "redirectUrl",
            security_code: "securityCode",
        });
    });

/** @internal */
export type StoredPaymentMethodRequest$Outbound = {
    method: string;
    id: string;
    redirect_url?: string | undefined;
    security_code?: string | null | undefined;
};

/** @internal */
export const StoredPaymentMethodRequest$outboundSchema: z.ZodType<
    StoredPaymentMethodRequest$Outbound,
    z.ZodTypeDef,
    StoredPaymentMethodRequest
> = z
    .object({
        method: TokenizedRequestPaymentMethodMethod$outboundSchema,
        id: z.string(),
        redirectUrl: z.string().optional(),
        securityCode: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            redirectUrl: "redirect_url",
            securityCode: "security_code",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StoredPaymentMethodRequest$ {
    /** @deprecated use `StoredPaymentMethodRequest$inboundSchema` instead. */
    export const inboundSchema = StoredPaymentMethodRequest$inboundSchema;
    /** @deprecated use `StoredPaymentMethodRequest$outboundSchema` instead. */
    export const outboundSchema = StoredPaymentMethodRequest$outboundSchema;
    /** @deprecated use `StoredPaymentMethodRequest$Outbound` instead. */
    export type Outbound = StoredPaymentMethodRequest$Outbound;
}

/** @internal */
export const TransactionRedirectRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof TransactionRedirectRequestPaymentMethodMethod
> = z.nativeEnum(TransactionRedirectRequestPaymentMethodMethod);

/** @internal */
export const TransactionRedirectRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof TransactionRedirectRequestPaymentMethodMethod
> = TransactionRedirectRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRedirectRequestPaymentMethodMethod$ {
    /** @deprecated use `TransactionRedirectRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema = TransactionRedirectRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `TransactionRedirectRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema = TransactionRedirectRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const Redirect$inboundSchema: z.ZodType<Redirect, z.ZodTypeDef, unknown> = z
    .object({
        method: TransactionRedirectRequestPaymentMethodMethod$inboundSchema,
        redirect_url: z.string(),
        currency: z.string(),
        country: z.string(),
        external_identifier: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            redirect_url: "redirectUrl",
            external_identifier: "externalIdentifier",
        });
    });

/** @internal */
export type Redirect$Outbound = {
    method: string;
    redirect_url: string;
    currency: string;
    country: string;
    external_identifier?: string | null | undefined;
};

/** @internal */
export const Redirect$outboundSchema: z.ZodType<Redirect$Outbound, z.ZodTypeDef, Redirect> = z
    .object({
        method: TransactionRedirectRequestPaymentMethodMethod$outboundSchema,
        redirectUrl: z.string(),
        currency: z.string(),
        country: z.string(),
        externalIdentifier: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            redirectUrl: "redirect_url",
            externalIdentifier: "external_identifier",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Redirect$ {
    /** @deprecated use `Redirect$inboundSchema` instead. */
    export const inboundSchema = Redirect$inboundSchema;
    /** @deprecated use `Redirect$outboundSchema` instead. */
    export const outboundSchema = Redirect$outboundSchema;
    /** @deprecated use `Redirect$Outbound` instead. */
    export type Outbound = Redirect$Outbound;
}

/** @internal */
export const TransactionCardRequestPaymentMethodMethod$inboundSchema: z.ZodNativeEnum<
    typeof TransactionCardRequestPaymentMethodMethod
> = z.nativeEnum(TransactionCardRequestPaymentMethodMethod);

/** @internal */
export const TransactionCardRequestPaymentMethodMethod$outboundSchema: z.ZodNativeEnum<
    typeof TransactionCardRequestPaymentMethodMethod
> = TransactionCardRequestPaymentMethodMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionCardRequestPaymentMethodMethod$ {
    /** @deprecated use `TransactionCardRequestPaymentMethodMethod$inboundSchema` instead. */
    export const inboundSchema = TransactionCardRequestPaymentMethodMethod$inboundSchema;
    /** @deprecated use `TransactionCardRequestPaymentMethodMethod$outboundSchema` instead. */
    export const outboundSchema = TransactionCardRequestPaymentMethodMethod$outboundSchema;
}

/** @internal */
export const PaymentMethodCard$inboundSchema: z.ZodType<PaymentMethodCard, z.ZodTypeDef, unknown> =
    z
        .object({
            method: TransactionCardRequestPaymentMethodMethod$inboundSchema,
            number: z.string(),
            expiration_date: z.string(),
            security_code: z.nullable(z.string()).optional(),
            external_identifier: z.nullable(z.string()).optional(),
            redirect_url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                expiration_date: "expirationDate",
                security_code: "securityCode",
                external_identifier: "externalIdentifier",
                redirect_url: "redirectUrl",
            });
        });

/** @internal */
export type PaymentMethodCard$Outbound = {
    method: string;
    number: string;
    expiration_date: string;
    security_code?: string | null | undefined;
    external_identifier?: string | null | undefined;
    redirect_url?: string | null | undefined;
};

/** @internal */
export const PaymentMethodCard$outboundSchema: z.ZodType<
    PaymentMethodCard$Outbound,
    z.ZodTypeDef,
    PaymentMethodCard
> = z
    .object({
        method: TransactionCardRequestPaymentMethodMethod$outboundSchema,
        number: z.string(),
        expirationDate: z.string(),
        securityCode: z.nullable(z.string()).optional(),
        externalIdentifier: z.nullable(z.string()).optional(),
        redirectUrl: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            expirationDate: "expiration_date",
            securityCode: "security_code",
            externalIdentifier: "external_identifier",
            redirectUrl: "redirect_url",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentMethodCard$ {
    /** @deprecated use `PaymentMethodCard$inboundSchema` instead. */
    export const inboundSchema = PaymentMethodCard$inboundSchema;
    /** @deprecated use `PaymentMethodCard$outboundSchema` instead. */
    export const outboundSchema = PaymentMethodCard$outboundSchema;
    /** @deprecated use `PaymentMethodCard$Outbound` instead. */
    export type Outbound = PaymentMethodCard$Outbound;
}

/** @internal */
export const TransactionRequestPaymentMethod$inboundSchema: z.ZodType<
    TransactionRequestPaymentMethod,
    z.ZodTypeDef,
    unknown
> = z.union([
    z.lazy(() => StoredPaymentMethodRequest$inboundSchema),
    z.lazy(() => PaymentMethodCheckoutSession$inboundSchema),
    z.lazy(() => Redirect$inboundSchema),
    z.lazy(() => ApplePayPaymentMethodRequest$inboundSchema),
    z.lazy(() => NetworkTokenPaymentMethodRequest$inboundSchema),
    z.lazy(() => PaymentMethodCard$inboundSchema),
    z.lazy(() => GooglePayPaymentMethodRequest$inboundSchema),
    z.lazy(() => ApplePayDecryptedToken$inboundSchema),
    z.lazy(() => GooglePayDecryptedToken$inboundSchema),
]);

/** @internal */
export type TransactionRequestPaymentMethod$Outbound =
    | StoredPaymentMethodRequest$Outbound
    | PaymentMethodCheckoutSession$Outbound
    | Redirect$Outbound
    | ApplePayPaymentMethodRequest$Outbound
    | NetworkTokenPaymentMethodRequest$Outbound
    | PaymentMethodCard$Outbound
    | GooglePayPaymentMethodRequest$Outbound
    | ApplePayDecryptedToken$Outbound
    | GooglePayDecryptedToken$Outbound;

/** @internal */
export const TransactionRequestPaymentMethod$outboundSchema: z.ZodType<
    TransactionRequestPaymentMethod$Outbound,
    z.ZodTypeDef,
    TransactionRequestPaymentMethod
> = z.union([
    z.lazy(() => StoredPaymentMethodRequest$outboundSchema),
    z.lazy(() => PaymentMethodCheckoutSession$outboundSchema),
    z.lazy(() => Redirect$outboundSchema),
    z.lazy(() => ApplePayPaymentMethodRequest$outboundSchema),
    z.lazy(() => NetworkTokenPaymentMethodRequest$outboundSchema),
    z.lazy(() => PaymentMethodCard$outboundSchema),
    z.lazy(() => GooglePayPaymentMethodRequest$outboundSchema),
    z.lazy(() => ApplePayDecryptedToken$outboundSchema),
    z.lazy(() => GooglePayDecryptedToken$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequestPaymentMethod$ {
    /** @deprecated use `TransactionRequestPaymentMethod$inboundSchema` instead. */
    export const inboundSchema = TransactionRequestPaymentMethod$inboundSchema;
    /** @deprecated use `TransactionRequestPaymentMethod$outboundSchema` instead. */
    export const outboundSchema = TransactionRequestPaymentMethod$outboundSchema;
    /** @deprecated use `TransactionRequestPaymentMethod$Outbound` instead. */
    export type Outbound = TransactionRequestPaymentMethod$Outbound;
}

/** @internal */
export const UserDevice$inboundSchema: z.ZodNativeEnum<typeof UserDevice> =
    z.nativeEnum(UserDevice);

/** @internal */
export const UserDevice$outboundSchema: z.ZodNativeEnum<typeof UserDevice> =
    UserDevice$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserDevice$ {
    /** @deprecated use `UserDevice$inboundSchema` instead. */
    export const inboundSchema = UserDevice$inboundSchema;
    /** @deprecated use `UserDevice$outboundSchema` instead. */
    export const outboundSchema = UserDevice$outboundSchema;
}

/** @internal */
export const BrowserInfo$inboundSchema: z.ZodType<BrowserInfo, z.ZodTypeDef, unknown> = z
    .object({
        java_enabled: z.boolean(),
        javascript_enabled: z.boolean(),
        language: z.string(),
        color_depth: z.number(),
        screen_height: z.number(),
        screen_width: z.number(),
        time_zone_offset: z.number(),
        user_device: UserDevice$inboundSchema,
        user_agent: z.string(),
        accept_header: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            java_enabled: "javaEnabled",
            javascript_enabled: "javascriptEnabled",
            color_depth: "colorDepth",
            screen_height: "screenHeight",
            screen_width: "screenWidth",
            time_zone_offset: "timeZoneOffset",
            user_device: "userDevice",
            user_agent: "userAgent",
            accept_header: "acceptHeader",
        });
    });

/** @internal */
export type BrowserInfo$Outbound = {
    java_enabled: boolean;
    javascript_enabled: boolean;
    language: string;
    color_depth: number;
    screen_height: number;
    screen_width: number;
    time_zone_offset: number;
    user_device: string;
    user_agent: string;
    accept_header?: string | undefined;
};

/** @internal */
export const BrowserInfo$outboundSchema: z.ZodType<
    BrowserInfo$Outbound,
    z.ZodTypeDef,
    BrowserInfo
> = z
    .object({
        javaEnabled: z.boolean(),
        javascriptEnabled: z.boolean(),
        language: z.string(),
        colorDepth: z.number(),
        screenHeight: z.number(),
        screenWidth: z.number(),
        timeZoneOffset: z.number(),
        userDevice: UserDevice$outboundSchema,
        userAgent: z.string(),
        acceptHeader: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            javaEnabled: "java_enabled",
            javascriptEnabled: "javascript_enabled",
            colorDepth: "color_depth",
            screenHeight: "screen_height",
            screenWidth: "screen_width",
            timeZoneOffset: "time_zone_offset",
            userDevice: "user_device",
            userAgent: "user_agent",
            acceptHeader: "accept_header",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BrowserInfo$ {
    /** @deprecated use `BrowserInfo$inboundSchema` instead. */
    export const inboundSchema = BrowserInfo$inboundSchema;
    /** @deprecated use `BrowserInfo$outboundSchema` instead. */
    export const outboundSchema = BrowserInfo$outboundSchema;
    /** @deprecated use `BrowserInfo$Outbound` instead. */
    export type Outbound = BrowserInfo$Outbound;
}

/** @internal */
export const CybersourceCard$inboundSchema: z.ZodType<CybersourceCard, z.ZodTypeDef, unknown> = z
    .object({
        meta_key_merchant_id: z.nullable(z.string()).optional(),
        merchant_defined_information: z.record(z.string()).optional(),
        ship_to_method: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            meta_key_merchant_id: "metaKeyMerchantId",
            merchant_defined_information: "merchantDefinedInformation",
            ship_to_method: "shipToMethod",
        });
    });

/** @internal */
export type CybersourceCard$Outbound = {
    meta_key_merchant_id?: string | null | undefined;
    merchant_defined_information?: { [k: string]: string } | undefined;
    ship_to_method?: string | null | undefined;
};

/** @internal */
export const CybersourceCard$outboundSchema: z.ZodType<
    CybersourceCard$Outbound,
    z.ZodTypeDef,
    CybersourceCard
> = z
    .object({
        metaKeyMerchantId: z.nullable(z.string()).optional(),
        merchantDefinedInformation: z.record(z.string()).optional(),
        shipToMethod: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            metaKeyMerchantId: "meta_key_merchant_id",
            merchantDefinedInformation: "merchant_defined_information",
            shipToMethod: "ship_to_method",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CybersourceCard$ {
    /** @deprecated use `CybersourceCard$inboundSchema` instead. */
    export const inboundSchema = CybersourceCard$inboundSchema;
    /** @deprecated use `CybersourceCard$outboundSchema` instead. */
    export const outboundSchema = CybersourceCard$outboundSchema;
    /** @deprecated use `CybersourceCard$Outbound` instead. */
    export type Outbound = CybersourceCard$Outbound;
}

/** @internal */
export const CybersourceAntiFraud$inboundSchema: z.ZodType<
    CybersourceAntiFraud,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        meta_key_merchant_id: z.nullable(z.string()).optional(),
        merchant_defined_data: z.record(z.string()).optional(),
        shipping_method: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            meta_key_merchant_id: "metaKeyMerchantId",
            merchant_defined_data: "merchantDefinedData",
            shipping_method: "shippingMethod",
        });
    });

/** @internal */
export type CybersourceAntiFraud$Outbound = {
    meta_key_merchant_id?: string | null | undefined;
    merchant_defined_data?: { [k: string]: string } | undefined;
    shipping_method?: string | null | undefined;
};

/** @internal */
export const CybersourceAntiFraud$outboundSchema: z.ZodType<
    CybersourceAntiFraud$Outbound,
    z.ZodTypeDef,
    CybersourceAntiFraud
> = z
    .object({
        metaKeyMerchantId: z.nullable(z.string()).optional(),
        merchantDefinedData: z.record(z.string()).optional(),
        shippingMethod: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            metaKeyMerchantId: "meta_key_merchant_id",
            merchantDefinedData: "merchant_defined_data",
            shippingMethod: "shipping_method",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CybersourceAntiFraud$ {
    /** @deprecated use `CybersourceAntiFraud$inboundSchema` instead. */
    export const inboundSchema = CybersourceAntiFraud$inboundSchema;
    /** @deprecated use `CybersourceAntiFraud$outboundSchema` instead. */
    export const outboundSchema = CybersourceAntiFraud$outboundSchema;
    /** @deprecated use `CybersourceAntiFraud$Outbound` instead. */
    export type Outbound = CybersourceAntiFraud$Outbound;
}

/** @internal */
export const GivingblockGivingblock$inboundSchema: z.ZodType<
    GivingblockGivingblock,
    z.ZodTypeDef,
    unknown
> = z.object({
    defaultCryptocurrency: z.string().optional(),
});

/** @internal */
export type GivingblockGivingblock$Outbound = {
    defaultCryptocurrency?: string | undefined;
};

/** @internal */
export const GivingblockGivingblock$outboundSchema: z.ZodType<
    GivingblockGivingblock$Outbound,
    z.ZodTypeDef,
    GivingblockGivingblock
> = z.object({
    defaultCryptocurrency: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GivingblockGivingblock$ {
    /** @deprecated use `GivingblockGivingblock$inboundSchema` instead. */
    export const inboundSchema = GivingblockGivingblock$inboundSchema;
    /** @deprecated use `GivingblockGivingblock$outboundSchema` instead. */
    export const outboundSchema = GivingblockGivingblock$outboundSchema;
    /** @deprecated use `GivingblockGivingblock$Outbound` instead. */
    export type Outbound = GivingblockGivingblock$Outbound;
}

/** @internal */
export const DeliveryType$inboundSchema: z.ZodNativeEnum<typeof DeliveryType> =
    z.nativeEnum(DeliveryType);

/** @internal */
export const DeliveryType$outboundSchema: z.ZodNativeEnum<typeof DeliveryType> =
    DeliveryType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeliveryType$ {
    /** @deprecated use `DeliveryType$inboundSchema` instead. */
    export const inboundSchema = DeliveryType$inboundSchema;
    /** @deprecated use `DeliveryType$outboundSchema` instead. */
    export const outboundSchema = DeliveryType$outboundSchema;
}

/** @internal */
export const TransactionRequestType$inboundSchema: z.ZodNativeEnum<typeof TransactionRequestType> =
    z.nativeEnum(TransactionRequestType);

/** @internal */
export const TransactionRequestType$outboundSchema: z.ZodNativeEnum<typeof TransactionRequestType> =
    TransactionRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequestType$ {
    /** @deprecated use `TransactionRequestType$inboundSchema` instead. */
    export const inboundSchema = TransactionRequestType$inboundSchema;
    /** @deprecated use `TransactionRequestType$outboundSchema` instead. */
    export const outboundSchema = TransactionRequestType$outboundSchema;
}

/** @internal */
export const BasicItemData$inboundSchema: z.ZodType<BasicItemData, z.ZodTypeDef, unknown> =
    z.object({
        type: TransactionRequestType$inboundSchema.optional(),
    });

/** @internal */
export type BasicItemData$Outbound = {
    type?: string | undefined;
};

/** @internal */
export const BasicItemData$outboundSchema: z.ZodType<
    BasicItemData$Outbound,
    z.ZodTypeDef,
    BasicItemData
> = z.object({
    type: TransactionRequestType$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BasicItemData$ {
    /** @deprecated use `BasicItemData$inboundSchema` instead. */
    export const inboundSchema = BasicItemData$inboundSchema;
    /** @deprecated use `BasicItemData$outboundSchema` instead. */
    export const outboundSchema = BasicItemData$outboundSchema;
    /** @deprecated use `BasicItemData$Outbound` instead. */
    export type Outbound = BasicItemData$Outbound;
}

/** @internal */
export const TransactionRequestDeliveryType$inboundSchema: z.ZodNativeEnum<
    typeof TransactionRequestDeliveryType
> = z.nativeEnum(TransactionRequestDeliveryType);

/** @internal */
export const TransactionRequestDeliveryType$outboundSchema: z.ZodNativeEnum<
    typeof TransactionRequestDeliveryType
> = TransactionRequestDeliveryType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequestDeliveryType$ {
    /** @deprecated use `TransactionRequestDeliveryType$inboundSchema` instead. */
    export const inboundSchema = TransactionRequestDeliveryType$inboundSchema;
    /** @deprecated use `TransactionRequestDeliveryType$outboundSchema` instead. */
    export const outboundSchema = TransactionRequestDeliveryType$outboundSchema;
}

/** @internal */
export const DeliveryDetails$inboundSchema: z.ZodType<DeliveryDetails, z.ZodTypeDef, unknown> = z
    .object({
        delivery_type: z.nullable(TransactionRequestDeliveryType$inboundSchema).optional(),
        delivery_method: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            delivery_type: "deliveryType",
            delivery_method: "deliveryMethod",
        });
    });

/** @internal */
export type DeliveryDetails$Outbound = {
    delivery_type?: string | null | undefined;
    delivery_method?: string | undefined;
};

/** @internal */
export const DeliveryDetails$outboundSchema: z.ZodType<
    DeliveryDetails$Outbound,
    z.ZodTypeDef,
    DeliveryDetails
> = z
    .object({
        deliveryType: z.nullable(TransactionRequestDeliveryType$outboundSchema).optional(),
        deliveryMethod: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            deliveryType: "delivery_type",
            deliveryMethod: "delivery_method",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeliveryDetails$ {
    /** @deprecated use `DeliveryDetails$inboundSchema` instead. */
    export const inboundSchema = DeliveryDetails$inboundSchema;
    /** @deprecated use `DeliveryDetails$outboundSchema` instead. */
    export const outboundSchema = DeliveryDetails$outboundSchema;
    /** @deprecated use `DeliveryDetails$Outbound` instead. */
    export type Outbound = DeliveryDetails$Outbound;
}

/** @internal */
export const PersonalDetails$inboundSchema: z.ZodType<PersonalDetails, z.ZodTypeDef, unknown> = z
    .object({
        first_name: z.string().optional(),
        last_name: z.string().optional(),
        email: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            first_name: "firstName",
            last_name: "lastName",
        });
    });

/** @internal */
export type PersonalDetails$Outbound = {
    first_name?: string | undefined;
    last_name?: string | undefined;
    email?: string | undefined;
};

/** @internal */
export const PersonalDetails$outboundSchema: z.ZodType<
    PersonalDetails$Outbound,
    z.ZodTypeDef,
    PersonalDetails
> = z
    .object({
        firstName: z.string().optional(),
        lastName: z.string().optional(),
        email: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            firstName: "first_name",
            lastName: "last_name",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PersonalDetails$ {
    /** @deprecated use `PersonalDetails$inboundSchema` instead. */
    export const inboundSchema = PersonalDetails$inboundSchema;
    /** @deprecated use `PersonalDetails$outboundSchema` instead. */
    export const outboundSchema = PersonalDetails$outboundSchema;
    /** @deprecated use `PersonalDetails$Outbound` instead. */
    export type Outbound = PersonalDetails$Outbound;
}

/** @internal */
export const TransactionRequestAddress$inboundSchema: z.ZodType<
    TransactionRequestAddress,
    z.ZodTypeDef,
    unknown
> = z.object({
    country: z.string(),
    address1: z.nullable(z.string()).optional(),
    address2: z.nullable(z.string()).optional(),
    zip: z.nullable(z.string()).optional(),
    region: z.nullable(z.string()).optional(),
    company: z.nullable(z.string()).optional(),
    city: z.nullable(z.string()).optional(),
});

/** @internal */
export type TransactionRequestAddress$Outbound = {
    country: string;
    address1?: string | null | undefined;
    address2?: string | null | undefined;
    zip?: string | null | undefined;
    region?: string | null | undefined;
    company?: string | null | undefined;
    city?: string | null | undefined;
};

/** @internal */
export const TransactionRequestAddress$outboundSchema: z.ZodType<
    TransactionRequestAddress$Outbound,
    z.ZodTypeDef,
    TransactionRequestAddress
> = z.object({
    country: z.string(),
    address1: z.nullable(z.string()).optional(),
    address2: z.nullable(z.string()).optional(),
    zip: z.nullable(z.string()).optional(),
    region: z.nullable(z.string()).optional(),
    company: z.nullable(z.string()).optional(),
    city: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequestAddress$ {
    /** @deprecated use `TransactionRequestAddress$inboundSchema` instead. */
    export const inboundSchema = TransactionRequestAddress$inboundSchema;
    /** @deprecated use `TransactionRequestAddress$outboundSchema` instead. */
    export const outboundSchema = TransactionRequestAddress$outboundSchema;
    /** @deprecated use `TransactionRequestAddress$Outbound` instead. */
    export type Outbound = TransactionRequestAddress$Outbound;
}

/** @internal */
export const Phone$inboundSchema: z.ZodType<Phone, z.ZodTypeDef, unknown> = z.object({
    phone: z.string(),
});

/** @internal */
export type Phone$Outbound = {
    phone: string;
};

/** @internal */
export const Phone$outboundSchema: z.ZodType<Phone$Outbound, z.ZodTypeDef, Phone> = z.object({
    phone: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Phone$ {
    /** @deprecated use `Phone$inboundSchema` instead. */
    export const inboundSchema = Phone$inboundSchema;
    /** @deprecated use `Phone$outboundSchema` instead. */
    export const outboundSchema = Phone$outboundSchema;
    /** @deprecated use `Phone$Outbound` instead. */
    export type Outbound = Phone$Outbound;
}

/** @internal */
export const Comments$inboundSchema: z.ZodType<Comments, z.ZodTypeDef, unknown> = z
    .object({
        user_comments_to_merchant: z.nullable(z.string()).optional(),
        message_to_beneficiary: z.nullable(z.string()).optional(),
        merchant_comments: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            user_comments_to_merchant: "userCommentsToMerchant",
            message_to_beneficiary: "messageToBeneficiary",
            merchant_comments: "merchantComments",
        });
    });

/** @internal */
export type Comments$Outbound = {
    user_comments_to_merchant?: string | null | undefined;
    message_to_beneficiary?: string | null | undefined;
    merchant_comments?: string | null | undefined;
};

/** @internal */
export const Comments$outboundSchema: z.ZodType<Comments$Outbound, z.ZodTypeDef, Comments> = z
    .object({
        userCommentsToMerchant: z.nullable(z.string()).optional(),
        messageToBeneficiary: z.nullable(z.string()).optional(),
        merchantComments: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            userCommentsToMerchant: "user_comments_to_merchant",
            messageToBeneficiary: "message_to_beneficiary",
            merchantComments: "merchant_comments",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Comments$ {
    /** @deprecated use `Comments$inboundSchema` instead. */
    export const inboundSchema = Comments$inboundSchema;
    /** @deprecated use `Comments$outboundSchema` instead. */
    export const outboundSchema = Comments$outboundSchema;
    /** @deprecated use `Comments$Outbound` instead. */
    export type Outbound = Comments$Outbound;
}

/** @internal */
export const Beneficiaries$inboundSchema: z.ZodType<Beneficiaries, z.ZodTypeDef, unknown> = z
    .object({
        personal_details: z.lazy(() => PersonalDetails$inboundSchema),
        address: z.nullable(z.lazy(() => TransactionRequestAddress$inboundSchema)).optional(),
        phone: z.array(z.lazy(() => Phone$inboundSchema)).optional(),
        comments: z.nullable(z.lazy(() => Comments$inboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            personal_details: "personalDetails",
        });
    });

/** @internal */
export type Beneficiaries$Outbound = {
    personal_details: PersonalDetails$Outbound;
    address?: TransactionRequestAddress$Outbound | null | undefined;
    phone?: Array<Phone$Outbound> | undefined;
    comments?: Comments$Outbound | null | undefined;
};

/** @internal */
export const Beneficiaries$outboundSchema: z.ZodType<
    Beneficiaries$Outbound,
    z.ZodTypeDef,
    Beneficiaries
> = z
    .object({
        personalDetails: z.lazy(() => PersonalDetails$outboundSchema),
        address: z.nullable(z.lazy(() => TransactionRequestAddress$outboundSchema)).optional(),
        phone: z.array(z.lazy(() => Phone$outboundSchema)).optional(),
        comments: z.nullable(z.lazy(() => Comments$outboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            personalDetails: "personal_details",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Beneficiaries$ {
    /** @deprecated use `Beneficiaries$inboundSchema` instead. */
    export const inboundSchema = Beneficiaries$inboundSchema;
    /** @deprecated use `Beneficiaries$outboundSchema` instead. */
    export const outboundSchema = Beneficiaries$outboundSchema;
    /** @deprecated use `Beneficiaries$Outbound` instead. */
    export type Outbound = Beneficiaries$Outbound;
}

/** @internal */
export const CartItems$inboundSchema: z.ZodType<CartItems, z.ZodTypeDef, unknown> = z
    .object({
        basic_item_data: z.lazy(() => BasicItemData$inboundSchema).optional(),
        delivery_details: z.lazy(() => DeliveryDetails$inboundSchema).optional(),
        beneficiaries: z.array(z.lazy(() => Beneficiaries$inboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            basic_item_data: "basicItemData",
            delivery_details: "deliveryDetails",
        });
    });

/** @internal */
export type CartItems$Outbound = {
    basic_item_data?: BasicItemData$Outbound | undefined;
    delivery_details?: DeliveryDetails$Outbound | undefined;
    beneficiaries?: Array<Beneficiaries$Outbound> | undefined;
};

/** @internal */
export const CartItems$outboundSchema: z.ZodType<CartItems$Outbound, z.ZodTypeDef, CartItems> = z
    .object({
        basicItemData: z.lazy(() => BasicItemData$outboundSchema).optional(),
        deliveryDetails: z.lazy(() => DeliveryDetails$outboundSchema).optional(),
        beneficiaries: z.array(z.lazy(() => Beneficiaries$outboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            basicItemData: "basic_item_data",
            deliveryDetails: "delivery_details",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CartItems$ {
    /** @deprecated use `CartItems$inboundSchema` instead. */
    export const inboundSchema = CartItems$inboundSchema;
    /** @deprecated use `CartItems$outboundSchema` instead. */
    export const outboundSchema = CartItems$outboundSchema;
    /** @deprecated use `CartItems$Outbound` instead. */
    export type Outbound = CartItems$Outbound;
}

/** @internal */
export const CouponDiscountAmount$inboundSchema: z.ZodType<
    CouponDiscountAmount,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        amount_usd: z.string().optional(),
        amount_local_currency: z.string().optional(),
        currency: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            amount_usd: "amountUsd",
            amount_local_currency: "amountLocalCurrency",
        });
    });

/** @internal */
export type CouponDiscountAmount$Outbound = {
    amount_usd?: string | undefined;
    amount_local_currency?: string | undefined;
    currency?: string | undefined;
};

/** @internal */
export const CouponDiscountAmount$outboundSchema: z.ZodType<
    CouponDiscountAmount$Outbound,
    z.ZodTypeDef,
    CouponDiscountAmount
> = z
    .object({
        amountUsd: z.string().optional(),
        amountLocalCurrency: z.string().optional(),
        currency: z.string().optional(),
    })
    .transform((v) => {
        return remap$(v, {
            amountUsd: "amount_usd",
            amountLocalCurrency: "amount_local_currency",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CouponDiscountAmount$ {
    /** @deprecated use `CouponDiscountAmount$inboundSchema` instead. */
    export const inboundSchema = CouponDiscountAmount$inboundSchema;
    /** @deprecated use `CouponDiscountAmount$outboundSchema` instead. */
    export const outboundSchema = CouponDiscountAmount$outboundSchema;
    /** @deprecated use `CouponDiscountAmount$Outbound` instead. */
    export type Outbound = CouponDiscountAmount$Outbound;
}

/** @internal */
export const TotalDiscount$inboundSchema: z.ZodType<TotalDiscount, z.ZodTypeDef, unknown> = z
    .object({
        coupon_code_used: z.string().optional(),
        discount_type: z.string(),
        coupon_discount_amount: z
            .nullable(z.lazy(() => CouponDiscountAmount$inboundSchema))
            .optional(),
        coupon_discount_percent: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            coupon_code_used: "couponCodeUsed",
            discount_type: "discountType",
            coupon_discount_amount: "couponDiscountAmount",
            coupon_discount_percent: "couponDiscountPercent",
        });
    });

/** @internal */
export type TotalDiscount$Outbound = {
    coupon_code_used?: string | undefined;
    discount_type: string;
    coupon_discount_amount?: CouponDiscountAmount$Outbound | null | undefined;
    coupon_discount_percent?: string | null | undefined;
};

/** @internal */
export const TotalDiscount$outboundSchema: z.ZodType<
    TotalDiscount$Outbound,
    z.ZodTypeDef,
    TotalDiscount
> = z
    .object({
        couponCodeUsed: z.string().optional(),
        discountType: z.string(),
        couponDiscountAmount: z
            .nullable(z.lazy(() => CouponDiscountAmount$outboundSchema))
            .optional(),
        couponDiscountPercent: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            couponCodeUsed: "coupon_code_used",
            discountType: "discount_type",
            couponDiscountAmount: "coupon_discount_amount",
            couponDiscountPercent: "coupon_discount_percent",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TotalDiscount$ {
    /** @deprecated use `TotalDiscount$inboundSchema` instead. */
    export const inboundSchema = TotalDiscount$inboundSchema;
    /** @deprecated use `TotalDiscount$outboundSchema` instead. */
    export const outboundSchema = TotalDiscount$outboundSchema;
    /** @deprecated use `TotalDiscount$Outbound` instead. */
    export type Outbound = TotalDiscount$Outbound;
}

/** @internal */
export const ForterAntiFraud$inboundSchema: z.ZodType<ForterAntiFraud, z.ZodTypeDef, unknown> = z
    .object({
        delivery_type: z.nullable(DeliveryType$inboundSchema).optional(),
        delivery_method: z.nullable(z.string()).optional(),
        is_guest_buyer: z.boolean().default(false),
        cart_items: z.array(z.lazy(() => CartItems$inboundSchema)).optional(),
        total_discount: z.nullable(z.lazy(() => TotalDiscount$inboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            delivery_type: "deliveryType",
            delivery_method: "deliveryMethod",
            is_guest_buyer: "isGuestBuyer",
            cart_items: "cartItems",
            total_discount: "totalDiscount",
        });
    });

/** @internal */
export type ForterAntiFraud$Outbound = {
    delivery_type?: string | null | undefined;
    delivery_method?: string | null | undefined;
    is_guest_buyer: boolean;
    cart_items?: Array<CartItems$Outbound> | undefined;
    total_discount?: TotalDiscount$Outbound | null | undefined;
};

/** @internal */
export const ForterAntiFraud$outboundSchema: z.ZodType<
    ForterAntiFraud$Outbound,
    z.ZodTypeDef,
    ForterAntiFraud
> = z
    .object({
        deliveryType: z.nullable(DeliveryType$outboundSchema).optional(),
        deliveryMethod: z.nullable(z.string()).optional(),
        isGuestBuyer: z.boolean().default(false),
        cartItems: z.array(z.lazy(() => CartItems$outboundSchema)).optional(),
        totalDiscount: z.nullable(z.lazy(() => TotalDiscount$outboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            deliveryType: "delivery_type",
            deliveryMethod: "delivery_method",
            isGuestBuyer: "is_guest_buyer",
            cartItems: "cart_items",
            totalDiscount: "total_discount",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ForterAntiFraud$ {
    /** @deprecated use `ForterAntiFraud$inboundSchema` instead. */
    export const inboundSchema = ForterAntiFraud$inboundSchema;
    /** @deprecated use `ForterAntiFraud$outboundSchema` instead. */
    export const outboundSchema = ForterAntiFraud$outboundSchema;
    /** @deprecated use `ForterAntiFraud$Outbound` instead. */
    export type Outbound = ForterAntiFraud$Outbound;
}

/** @internal */
export const AdyenCard$inboundSchema: z.ZodType<AdyenCard, z.ZodTypeDef, unknown> = z.object({
    additionalData: z.record(z.string()).optional(),
});

/** @internal */
export type AdyenCard$Outbound = {
    additionalData?: { [k: string]: string } | undefined;
};

/** @internal */
export const AdyenCard$outboundSchema: z.ZodType<AdyenCard$Outbound, z.ZodTypeDef, AdyenCard> =
    z.object({
        additionalData: z.record(z.string()).optional(),
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdyenCard$ {
    /** @deprecated use `AdyenCard$inboundSchema` instead. */
    export const inboundSchema = AdyenCard$inboundSchema;
    /** @deprecated use `AdyenCard$outboundSchema` instead. */
    export const outboundSchema = AdyenCard$outboundSchema;
    /** @deprecated use `AdyenCard$Outbound` instead. */
    export type Outbound = AdyenCard$Outbound;
}

/** @internal */
export const AdditionalData$inboundSchema: z.ZodType<AdditionalData, z.ZodTypeDef, unknown> =
    z.object({
        key: z.string().optional(),
        value: z.string().optional(),
    });

/** @internal */
export type AdditionalData$Outbound = {
    key?: string | undefined;
    value?: string | undefined;
};

/** @internal */
export const AdditionalData$outboundSchema: z.ZodType<
    AdditionalData$Outbound,
    z.ZodTypeDef,
    AdditionalData
> = z.object({
    key: z.string().optional(),
    value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdditionalData$ {
    /** @deprecated use `AdditionalData$inboundSchema` instead. */
    export const inboundSchema = AdditionalData$inboundSchema;
    /** @deprecated use `AdditionalData$outboundSchema` instead. */
    export const outboundSchema = AdditionalData$outboundSchema;
    /** @deprecated use `AdditionalData$Outbound` instead. */
    export type Outbound = AdditionalData$Outbound;
}

/** @internal */
export const PaypalPaypal$inboundSchema: z.ZodType<PaypalPaypal, z.ZodTypeDef, unknown> = z
    .object({
        additional_data: z.array(z.lazy(() => AdditionalData$inboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            additional_data: "additionalData",
        });
    });

/** @internal */
export type PaypalPaypal$Outbound = {
    additional_data?: Array<AdditionalData$Outbound> | undefined;
};

/** @internal */
export const PaypalPaypal$outboundSchema: z.ZodType<
    PaypalPaypal$Outbound,
    z.ZodTypeDef,
    PaypalPaypal
> = z
    .object({
        additionalData: z.array(z.lazy(() => AdditionalData$outboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            additionalData: "additional_data",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaypalPaypal$ {
    /** @deprecated use `PaypalPaypal$inboundSchema` instead. */
    export const inboundSchema = PaypalPaypal$inboundSchema;
    /** @deprecated use `PaypalPaypal$outboundSchema` instead. */
    export const outboundSchema = PaypalPaypal$outboundSchema;
    /** @deprecated use `PaypalPaypal$Outbound` instead. */
    export type Outbound = PaypalPaypal$Outbound;
}

/** @internal */
export const TransactionRequestAdditionalData$inboundSchema: z.ZodType<
    TransactionRequestAdditionalData,
    z.ZodTypeDef,
    unknown
> = z.object({
    key: z.string().optional(),
    value: z.string().optional(),
});

/** @internal */
export type TransactionRequestAdditionalData$Outbound = {
    key?: string | undefined;
    value?: string | undefined;
};

/** @internal */
export const TransactionRequestAdditionalData$outboundSchema: z.ZodType<
    TransactionRequestAdditionalData$Outbound,
    z.ZodTypeDef,
    TransactionRequestAdditionalData
> = z.object({
    key: z.string().optional(),
    value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequestAdditionalData$ {
    /** @deprecated use `TransactionRequestAdditionalData$inboundSchema` instead. */
    export const inboundSchema = TransactionRequestAdditionalData$inboundSchema;
    /** @deprecated use `TransactionRequestAdditionalData$outboundSchema` instead. */
    export const outboundSchema = TransactionRequestAdditionalData$outboundSchema;
    /** @deprecated use `TransactionRequestAdditionalData$Outbound` instead. */
    export type Outbound = TransactionRequestAdditionalData$Outbound;
}

/** @internal */
export const PaypalPaypalpaylater$inboundSchema: z.ZodType<
    PaypalPaypalpaylater,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        additional_data: z
            .array(z.lazy(() => TransactionRequestAdditionalData$inboundSchema))
            .optional(),
    })
    .transform((v) => {
        return remap$(v, {
            additional_data: "additionalData",
        });
    });

/** @internal */
export type PaypalPaypalpaylater$Outbound = {
    additional_data?: Array<TransactionRequestAdditionalData$Outbound> | undefined;
};

/** @internal */
export const PaypalPaypalpaylater$outboundSchema: z.ZodType<
    PaypalPaypalpaylater$Outbound,
    z.ZodTypeDef,
    PaypalPaypalpaylater
> = z
    .object({
        additionalData: z
            .array(z.lazy(() => TransactionRequestAdditionalData$outboundSchema))
            .optional(),
    })
    .transform((v) => {
        return remap$(v, {
            additionalData: "additional_data",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaypalPaypalpaylater$ {
    /** @deprecated use `PaypalPaypalpaylater$inboundSchema` instead. */
    export const inboundSchema = PaypalPaypalpaylater$inboundSchema;
    /** @deprecated use `PaypalPaypalpaylater$outboundSchema` instead. */
    export const outboundSchema = PaypalPaypalpaylater$outboundSchema;
    /** @deprecated use `PaypalPaypalpaylater$Outbound` instead. */
    export type Outbound = PaypalPaypalpaylater$Outbound;
}

/** @internal */
export const StripeConnect$inboundSchema: z.ZodType<StripeConnect, z.ZodTypeDef, unknown> = z
    .object({
        stripe_account: z.nullable(z.string()).optional(),
        application_fee_amount: z.nullable(z.number()).optional(),
        on_behalf_of: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            stripe_account: "stripeAccount",
            application_fee_amount: "applicationFeeAmount",
            on_behalf_of: "onBehalfOf",
        });
    });

/** @internal */
export type StripeConnect$Outbound = {
    stripe_account?: string | null | undefined;
    application_fee_amount?: number | null | undefined;
    on_behalf_of?: string | null | undefined;
};

/** @internal */
export const StripeConnect$outboundSchema: z.ZodType<
    StripeConnect$Outbound,
    z.ZodTypeDef,
    StripeConnect
> = z
    .object({
        stripeAccount: z.nullable(z.string()).optional(),
        applicationFeeAmount: z.nullable(z.number()).optional(),
        onBehalfOf: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            stripeAccount: "stripe_account",
            applicationFeeAmount: "application_fee_amount",
            onBehalfOf: "on_behalf_of",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StripeConnect$ {
    /** @deprecated use `StripeConnect$inboundSchema` instead. */
    export const inboundSchema = StripeConnect$inboundSchema;
    /** @deprecated use `StripeConnect$outboundSchema` instead. */
    export const outboundSchema = StripeConnect$outboundSchema;
    /** @deprecated use `StripeConnect$Outbound` instead. */
    export type Outbound = StripeConnect$Outbound;
}

/** @internal */
export const StripeCard$inboundSchema: z.ZodType<StripeCard, z.ZodTypeDef, unknown> = z
    .object({
        error_on_requires_action: z.boolean().default(false),
        stripe_connect: z.nullable(z.lazy(() => StripeConnect$inboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            error_on_requires_action: "errorOnRequiresAction",
            stripe_connect: "stripeConnect",
        });
    });

/** @internal */
export type StripeCard$Outbound = {
    error_on_requires_action: boolean;
    stripe_connect?: StripeConnect$Outbound | null | undefined;
};

/** @internal */
export const StripeCard$outboundSchema: z.ZodType<StripeCard$Outbound, z.ZodTypeDef, StripeCard> = z
    .object({
        errorOnRequiresAction: z.boolean().default(false),
        stripeConnect: z.nullable(z.lazy(() => StripeConnect$outboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            errorOnRequiresAction: "error_on_requires_action",
            stripeConnect: "stripe_connect",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StripeCard$ {
    /** @deprecated use `StripeCard$inboundSchema` instead. */
    export const inboundSchema = StripeCard$inboundSchema;
    /** @deprecated use `StripeCard$outboundSchema` instead. */
    export const outboundSchema = StripeCard$outboundSchema;
    /** @deprecated use `StripeCard$Outbound` instead. */
    export type Outbound = StripeCard$Outbound;
}

/** @internal */
export const ConnectionOptions$inboundSchema: z.ZodType<ConnectionOptions, z.ZodTypeDef, unknown> =
    z
        .object({
            "cybersource-card": z.nullable(z.lazy(() => CybersourceCard$inboundSchema)).optional(),
            "cybersource-anti-fraud": z
                .nullable(z.lazy(() => CybersourceAntiFraud$inboundSchema))
                .optional(),
            "givingblock-givingblock": z
                .nullable(z.lazy(() => GivingblockGivingblock$inboundSchema))
                .optional(),
            "forter-anti-fraud": z.nullable(z.lazy(() => ForterAntiFraud$inboundSchema)).optional(),
            "adyen-card": z.nullable(z.lazy(() => AdyenCard$inboundSchema)).optional(),
            "paypal-paypal": z.nullable(z.lazy(() => PaypalPaypal$inboundSchema)).optional(),
            "paypal-paypalpaylater": z
                .nullable(z.lazy(() => PaypalPaypalpaylater$inboundSchema))
                .optional(),
            "stripe-card": z.nullable(z.lazy(() => StripeCard$inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                "cybersource-card": "cybersourceCard",
                "cybersource-anti-fraud": "cybersourceAntiFraud",
                "givingblock-givingblock": "givingblockGivingblock",
                "forter-anti-fraud": "forterAntiFraud",
                "adyen-card": "adyenCard",
                "paypal-paypal": "paypalPaypal",
                "paypal-paypalpaylater": "paypalPaypalpaylater",
                "stripe-card": "stripeCard",
            });
        });

/** @internal */
export type ConnectionOptions$Outbound = {
    "cybersource-card"?: CybersourceCard$Outbound | null | undefined;
    "cybersource-anti-fraud"?: CybersourceAntiFraud$Outbound | null | undefined;
    "givingblock-givingblock"?: GivingblockGivingblock$Outbound | null | undefined;
    "forter-anti-fraud"?: ForterAntiFraud$Outbound | null | undefined;
    "adyen-card"?: AdyenCard$Outbound | null | undefined;
    "paypal-paypal"?: PaypalPaypal$Outbound | null | undefined;
    "paypal-paypalpaylater"?: PaypalPaypalpaylater$Outbound | null | undefined;
    "stripe-card"?: StripeCard$Outbound | null | undefined;
};

/** @internal */
export const ConnectionOptions$outboundSchema: z.ZodType<
    ConnectionOptions$Outbound,
    z.ZodTypeDef,
    ConnectionOptions
> = z
    .object({
        cybersourceCard: z.nullable(z.lazy(() => CybersourceCard$outboundSchema)).optional(),
        cybersourceAntiFraud: z
            .nullable(z.lazy(() => CybersourceAntiFraud$outboundSchema))
            .optional(),
        givingblockGivingblock: z
            .nullable(z.lazy(() => GivingblockGivingblock$outboundSchema))
            .optional(),
        forterAntiFraud: z.nullable(z.lazy(() => ForterAntiFraud$outboundSchema)).optional(),
        adyenCard: z.nullable(z.lazy(() => AdyenCard$outboundSchema)).optional(),
        paypalPaypal: z.nullable(z.lazy(() => PaypalPaypal$outboundSchema)).optional(),
        paypalPaypalpaylater: z
            .nullable(z.lazy(() => PaypalPaypalpaylater$outboundSchema))
            .optional(),
        stripeCard: z.nullable(z.lazy(() => StripeCard$outboundSchema)).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            cybersourceCard: "cybersource-card",
            cybersourceAntiFraud: "cybersource-anti-fraud",
            givingblockGivingblock: "givingblock-givingblock",
            forterAntiFraud: "forter-anti-fraud",
            adyenCard: "adyen-card",
            paypalPaypal: "paypal-paypal",
            paypalPaypalpaylater: "paypal-paypalpaylater",
            stripeCard: "stripe-card",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionOptions$ {
    /** @deprecated use `ConnectionOptions$inboundSchema` instead. */
    export const inboundSchema = ConnectionOptions$inboundSchema;
    /** @deprecated use `ConnectionOptions$outboundSchema` instead. */
    export const outboundSchema = ConnectionOptions$outboundSchema;
    /** @deprecated use `ConnectionOptions$Outbound` instead. */
    export type Outbound = ConnectionOptions$Outbound;
}

/** @internal */
export const TransactionRequestGiftCards$inboundSchema: z.ZodType<
    TransactionRequestGiftCards,
    z.ZodTypeDef,
    unknown
> = z.union([
    TransactionGiftCardStoredRequest$inboundSchema,
    TransactionGiftCardNewRequest$inboundSchema,
]);

/** @internal */
export type TransactionRequestGiftCards$Outbound =
    | TransactionGiftCardStoredRequest$Outbound
    | TransactionGiftCardNewRequest$Outbound;

/** @internal */
export const TransactionRequestGiftCards$outboundSchema: z.ZodType<
    TransactionRequestGiftCards$Outbound,
    z.ZodTypeDef,
    TransactionRequestGiftCards
> = z.union([
    TransactionGiftCardStoredRequest$outboundSchema,
    TransactionGiftCardNewRequest$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequestGiftCards$ {
    /** @deprecated use `TransactionRequestGiftCards$inboundSchema` instead. */
    export const inboundSchema = TransactionRequestGiftCards$inboundSchema;
    /** @deprecated use `TransactionRequestGiftCards$outboundSchema` instead. */
    export const outboundSchema = TransactionRequestGiftCards$outboundSchema;
    /** @deprecated use `TransactionRequestGiftCards$Outbound` instead. */
    export type Outbound = TransactionRequestGiftCards$Outbound;
}

/** @internal */
export const TransactionRequestIntent$inboundSchema: z.ZodNativeEnum<
    typeof TransactionRequestIntent
> = z.nativeEnum(TransactionRequestIntent);

/** @internal */
export const TransactionRequestIntent$outboundSchema: z.ZodNativeEnum<
    typeof TransactionRequestIntent
> = TransactionRequestIntent$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequestIntent$ {
    /** @deprecated use `TransactionRequestIntent$inboundSchema` instead. */
    export const inboundSchema = TransactionRequestIntent$inboundSchema;
    /** @deprecated use `TransactionRequestIntent$outboundSchema` instead. */
    export const outboundSchema = TransactionRequestIntent$outboundSchema;
}

/** @internal */
export const PaymentSource$inboundSchema: z.ZodNativeEnum<typeof PaymentSource> =
    z.nativeEnum(PaymentSource);

/** @internal */
export const PaymentSource$outboundSchema: z.ZodNativeEnum<typeof PaymentSource> =
    PaymentSource$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentSource$ {
    /** @deprecated use `PaymentSource$inboundSchema` instead. */
    export const inboundSchema = PaymentSource$inboundSchema;
    /** @deprecated use `PaymentSource$outboundSchema` instead. */
    export const outboundSchema = PaymentSource$outboundSchema;
}

/** @internal */
export const StatementDescriptor$inboundSchema: z.ZodType<
    StatementDescriptor,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        name: z.nullable(z.string()).optional(),
        description: z.nullable(z.string()).optional(),
        city: z.nullable(z.string()).optional(),
        phone_number: z.nullable(z.string()).optional(),
        url: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            phone_number: "phoneNumber",
        });
    });

/** @internal */
export type StatementDescriptor$Outbound = {
    name?: string | null | undefined;
    description?: string | null | undefined;
    city?: string | null | undefined;
    phone_number?: string | null | undefined;
    url?: string | null | undefined;
};

/** @internal */
export const StatementDescriptor$outboundSchema: z.ZodType<
    StatementDescriptor$Outbound,
    z.ZodTypeDef,
    StatementDescriptor
> = z
    .object({
        name: z.nullable(z.string()).optional(),
        description: z.nullable(z.string()).optional(),
        city: z.nullable(z.string()).optional(),
        phoneNumber: z.nullable(z.string()).optional(),
        url: z.nullable(z.string()).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            phoneNumber: "phone_number",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StatementDescriptor$ {
    /** @deprecated use `StatementDescriptor$inboundSchema` instead. */
    export const inboundSchema = StatementDescriptor$inboundSchema;
    /** @deprecated use `StatementDescriptor$outboundSchema` instead. */
    export const outboundSchema = StatementDescriptor$outboundSchema;
    /** @deprecated use `StatementDescriptor$Outbound` instead. */
    export type Outbound = StatementDescriptor$Outbound;
}

/** @internal */
export const ThreeDSecureData$inboundSchema: z.ZodType<ThreeDSecureData, z.ZodTypeDef, unknown> =
    z.union([ThreeDSecureDataV2$inboundSchema, ThreeDSecureDataV1$inboundSchema]);

/** @internal */
export type ThreeDSecureData$Outbound = ThreeDSecureDataV2$Outbound | ThreeDSecureDataV1$Outbound;

/** @internal */
export const ThreeDSecureData$outboundSchema: z.ZodType<
    ThreeDSecureData$Outbound,
    z.ZodTypeDef,
    ThreeDSecureData
> = z.union([ThreeDSecureDataV2$outboundSchema, ThreeDSecureDataV1$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThreeDSecureData$ {
    /** @deprecated use `ThreeDSecureData$inboundSchema` instead. */
    export const inboundSchema = ThreeDSecureData$inboundSchema;
    /** @deprecated use `ThreeDSecureData$outboundSchema` instead. */
    export const outboundSchema = ThreeDSecureData$outboundSchema;
    /** @deprecated use `ThreeDSecureData$Outbound` instead. */
    export type Outbound = ThreeDSecureData$Outbound;
}

/** @internal */
export const TransactionRequest$inboundSchema: z.ZodType<
    TransactionRequest,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        amount: z.number().int(),
        currency: z.string(),
        payment_method: z
            .nullable(
                z.union([
                    z.lazy(() => StoredPaymentMethodRequest$inboundSchema),
                    z.lazy(() => PaymentMethodCheckoutSession$inboundSchema),
                    z.lazy(() => Redirect$inboundSchema),
                    z.lazy(() => ApplePayPaymentMethodRequest$inboundSchema),
                    z.lazy(() => NetworkTokenPaymentMethodRequest$inboundSchema),
                    z.lazy(() => PaymentMethodCard$inboundSchema),
                    z.lazy(() => GooglePayPaymentMethodRequest$inboundSchema),
                    z.lazy(() => ApplePayDecryptedToken$inboundSchema),
                    z.lazy(() => GooglePayDecryptedToken$inboundSchema),
                ])
            )
            .optional(),
        anti_fraud_fingerprint: z.nullable(z.string()).default(null),
        async_capture: z.boolean().default(false),
        browser_info: z.nullable(z.lazy(() => BrowserInfo$inboundSchema)).optional(),
        buyer_external_identifier: z.string().optional(),
        buyer_id: z.string().optional(),
        cart_items: z.array(CartItem$inboundSchema).optional(),
        connection_options: z.nullable(z.lazy(() => ConnectionOptions$inboundSchema)).optional(),
        country: z.nullable(z.string()).optional(),
        external_identifier: z.nullable(z.string()).optional(),
        gift_cards: z
            .nullable(
                z.array(
                    z.union([
                        TransactionGiftCardStoredRequest$inboundSchema,
                        TransactionGiftCardNewRequest$inboundSchema,
                    ])
                )
            )
            .optional(),
        intent: TransactionRequestIntent$inboundSchema.default("authorize"),
        is_subsequent_payment: z.boolean().default(false),
        merchant_initiated: z.boolean().default(false),
        metadata: z.record(z.string()).optional(),
        payment_source: PaymentSource$inboundSchema.optional(),
        previous_scheme_transaction_id: z.nullable(z.string()).default(null),
        shipping_details_id: z.nullable(z.string()).default(null),
        statement_descriptor: z
            .nullable(z.lazy(() => StatementDescriptor$inboundSchema))
            .optional(),
        store: z.boolean().default(false),
        three_d_secure_data: z
            .union([ThreeDSecureDataV2$inboundSchema, ThreeDSecureDataV1$inboundSchema])
            .optional(),
        payment_service_id: z.nullable(z.string()).default(null),
    })
    .transform((v) => {
        return remap$(v, {
            payment_method: "paymentMethod",
            anti_fraud_fingerprint: "antiFraudFingerprint",
            async_capture: "asyncCapture",
            browser_info: "browserInfo",
            buyer_external_identifier: "buyerExternalIdentifier",
            buyer_id: "buyerId",
            cart_items: "cartItems",
            connection_options: "connectionOptions",
            external_identifier: "externalIdentifier",
            gift_cards: "giftCards",
            is_subsequent_payment: "isSubsequentPayment",
            merchant_initiated: "merchantInitiated",
            payment_source: "paymentSource",
            previous_scheme_transaction_id: "previousSchemeTransactionId",
            shipping_details_id: "shippingDetailsId",
            statement_descriptor: "statementDescriptor",
            three_d_secure_data: "threeDSecureData",
            payment_service_id: "paymentServiceId",
        });
    });

/** @internal */
export type TransactionRequest$Outbound = {
    amount: number;
    currency: string;
    payment_method?:
        | StoredPaymentMethodRequest$Outbound
        | PaymentMethodCheckoutSession$Outbound
        | Redirect$Outbound
        | ApplePayPaymentMethodRequest$Outbound
        | NetworkTokenPaymentMethodRequest$Outbound
        | PaymentMethodCard$Outbound
        | GooglePayPaymentMethodRequest$Outbound
        | ApplePayDecryptedToken$Outbound
        | GooglePayDecryptedToken$Outbound
        | null
        | undefined;
    anti_fraud_fingerprint: string | null;
    async_capture: boolean;
    browser_info?: BrowserInfo$Outbound | null | undefined;
    buyer_external_identifier?: string | undefined;
    buyer_id?: string | undefined;
    cart_items?: Array<CartItem$Outbound> | undefined;
    connection_options?: ConnectionOptions$Outbound | null | undefined;
    country?: string | null | undefined;
    external_identifier?: string | null | undefined;
    gift_cards?:
        | Array<TransactionGiftCardStoredRequest$Outbound | TransactionGiftCardNewRequest$Outbound>
        | null
        | undefined;
    intent: string;
    is_subsequent_payment: boolean;
    merchant_initiated: boolean;
    metadata?: { [k: string]: string } | undefined;
    payment_source?: string | undefined;
    previous_scheme_transaction_id: string | null;
    shipping_details_id: string | null;
    statement_descriptor?: StatementDescriptor$Outbound | null | undefined;
    store: boolean;
    three_d_secure_data?: ThreeDSecureDataV2$Outbound | ThreeDSecureDataV1$Outbound | undefined;
    payment_service_id: string | null;
};

/** @internal */
export const TransactionRequest$outboundSchema: z.ZodType<
    TransactionRequest$Outbound,
    z.ZodTypeDef,
    TransactionRequest
> = z
    .object({
        amount: z.number().int(),
        currency: z.string(),
        paymentMethod: z
            .nullable(
                z.union([
                    z.lazy(() => StoredPaymentMethodRequest$outboundSchema),
                    z.lazy(() => PaymentMethodCheckoutSession$outboundSchema),
                    z.lazy(() => Redirect$outboundSchema),
                    z.lazy(() => ApplePayPaymentMethodRequest$outboundSchema),
                    z.lazy(() => NetworkTokenPaymentMethodRequest$outboundSchema),
                    z.lazy(() => PaymentMethodCard$outboundSchema),
                    z.lazy(() => GooglePayPaymentMethodRequest$outboundSchema),
                    z.lazy(() => ApplePayDecryptedToken$outboundSchema),
                    z.lazy(() => GooglePayDecryptedToken$outboundSchema),
                ])
            )
            .optional(),
        antiFraudFingerprint: z.nullable(z.string()).default(null),
        asyncCapture: z.boolean().default(false),
        browserInfo: z.nullable(z.lazy(() => BrowserInfo$outboundSchema)).optional(),
        buyerExternalIdentifier: z.string().optional(),
        buyerId: z.string().optional(),
        cartItems: z.array(CartItem$outboundSchema).optional(),
        connectionOptions: z.nullable(z.lazy(() => ConnectionOptions$outboundSchema)).optional(),
        country: z.nullable(z.string()).optional(),
        externalIdentifier: z.nullable(z.string()).optional(),
        giftCards: z
            .nullable(
                z.array(
                    z.union([
                        TransactionGiftCardStoredRequest$outboundSchema,
                        TransactionGiftCardNewRequest$outboundSchema,
                    ])
                )
            )
            .optional(),
        intent: TransactionRequestIntent$outboundSchema.default("authorize"),
        isSubsequentPayment: z.boolean().default(false),
        merchantInitiated: z.boolean().default(false),
        metadata: z.record(z.string()).optional(),
        paymentSource: PaymentSource$outboundSchema.optional(),
        previousSchemeTransactionId: z.nullable(z.string()).default(null),
        shippingDetailsId: z.nullable(z.string()).default(null),
        statementDescriptor: z
            .nullable(z.lazy(() => StatementDescriptor$outboundSchema))
            .optional(),
        store: z.boolean().default(false),
        threeDSecureData: z
            .union([ThreeDSecureDataV2$outboundSchema, ThreeDSecureDataV1$outboundSchema])
            .optional(),
        paymentServiceId: z.nullable(z.string()).default(null),
    })
    .transform((v) => {
        return remap$(v, {
            paymentMethod: "payment_method",
            antiFraudFingerprint: "anti_fraud_fingerprint",
            asyncCapture: "async_capture",
            browserInfo: "browser_info",
            buyerExternalIdentifier: "buyer_external_identifier",
            buyerId: "buyer_id",
            cartItems: "cart_items",
            connectionOptions: "connection_options",
            externalIdentifier: "external_identifier",
            giftCards: "gift_cards",
            isSubsequentPayment: "is_subsequent_payment",
            merchantInitiated: "merchant_initiated",
            paymentSource: "payment_source",
            previousSchemeTransactionId: "previous_scheme_transaction_id",
            shippingDetailsId: "shipping_details_id",
            statementDescriptor: "statement_descriptor",
            threeDSecureData: "three_d_secure_data",
            paymentServiceId: "payment_service_id",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionRequest$ {
    /** @deprecated use `TransactionRequest$inboundSchema` instead. */
    export const inboundSchema = TransactionRequest$inboundSchema;
    /** @deprecated use `TransactionRequest$outboundSchema` instead. */
    export const outboundSchema = TransactionRequest$outboundSchema;
    /** @deprecated use `TransactionRequest$Outbound` instead. */
    export type Outbound = TransactionRequest$Outbound;
}
