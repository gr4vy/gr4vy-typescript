/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { CartItem, CartItem$ } from "./cartitem";
import { ThreeDSecureDataV1, ThreeDSecureDataV1$ } from "./threedsecuredatav1";
import { ThreeDSecureDataV2, ThreeDSecureDataV2$ } from "./threedsecuredatav2";
import {
    TransactionGiftCardNewRequest,
    TransactionGiftCardNewRequest$,
} from "./transactiongiftcardnewrequest";
import {
    TransactionGiftCardStoredRequest,
    TransactionGiftCardStoredRequest$,
} from "./transactiongiftcardstoredrequest";
import * as z from "zod";

/**
 * `network-token`.
 */
export enum TransactionNetworkTokenRequestPaymentMethodMethod {
    NetworkToken = "network-token",
}

/**
 * Details for a Network Token payment method.
 */
export type NetworkTokenPaymentMethodRequest = {
    /**
     * `network-token`.
     */
    method: TransactionNetworkTokenRequestPaymentMethodMethod;
    /**
     * The value of the network token.
     */
    token: string;
    /**
     * The expiration date of the network token, formatted `MM/YY`.
     */
    expirationDate: string;
    /**
     * The cryptogram of the network token.
     */
    cryptogram?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `checkout-session`.
 */
export enum TransactionCheckoutSessionRequestPaymentMethodMethod {
    CheckoutSession = "checkout-session",
}

/**
 * Checkout Session payment method details to use in a transaction.
 */
export type PaymentMethodCheckoutSession = {
    /**
     * `checkout-session`.
     */
    method: TransactionCheckoutSessionRequestPaymentMethodMethod;
    /**
     * The ID of the Checkout Session.
     */
    id: string;
    /**
     * An external identifier that can be used to match the card against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `googlepay`.
 */
export enum GooglePayRequestPaymentMethodMethod {
    Googlepay = "googlepay",
}

/**
 * Information about the validation performed on the payment data. (See https://developers.google.com/pay/api/web/reference/response-objects#assurance-details-specifications).
 */
export type AssuranceDetails = {
    /**
     * Indicates that card holder possession validation has been performed.
     */
    accountVerified?: boolean | null | undefined;
    /**
     * Indicates that identification and verifications was performed.
     */
    cardHolderAuthenticated?: boolean | null | undefined;
};

/**
 * Details for a Google Pay payment method.
 */
export type GooglePayPaymentMethodRequest = {
    /**
     * `googlepay`.
     */
    method: GooglePayRequestPaymentMethodMethod;
    /**
     * The encrypted (opaque) token returned by the Google Pay API that
     *
     * @remarks
     * represents a payment method.
     */
    token: string;
    /**
     * Last 4 digits of the PAN for identification purposes.
     */
    cardSuffix?: string | null | undefined;
    /**
     * The scheme/brand of the card.
     */
    cardScheme?: string | null | undefined;
    /**
     * The type of card.
     */
    cardType?: string | null | undefined;
    /**
     * Information about the validation performed on the payment data. (See https://developers.google.com/pay/api/web/reference/response-objects#assurance-details-specifications).
     */
    assuranceDetails?: AssuranceDetails | null | undefined;
    /**
     * Name of the card holder.
     */
    cardholderName?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `applepay`.
 */
export enum ApplePayRequestPaymentMethodMethod {
    Applepay = "applepay",
}

/**
 * The encrypted (opaque) token that was passed to the `onpaymentauthorized`
 *
 * @remarks
 * callback by the Apple Pay integration.
 */
export type Token = {};

/**
 * Details for a Apple Pay payment method.
 */
export type ApplePayPaymentMethodRequest = {
    /**
     * `applepay`.
     */
    method: ApplePayRequestPaymentMethodMethod;
    /**
     * The encrypted (opaque) token that was passed to the `onpaymentauthorized`
     *
     * @remarks
     * callback by the Apple Pay integration.
     */
    token: Token;
    /**
     * Last 4 digits of the PAN for identification purposes.
     */
    cardSuffix?: string | null | undefined;
    /**
     * The scheme/brand of the card.
     */
    cardScheme?: string | null | undefined;
    /**
     * The type of card.
     */
    cardType?: string | null | undefined;
};

/**
 * `id`.
 */
export enum TokenizedRequestPaymentMethodMethod {
    Id = "id",
}

/**
 * Details for a previously stored payment method.
 */
export type StoredPaymentMethodRequest = {
    /**
     * `id`.
     */
    method: TokenizedRequestPaymentMethodMethod;
    /**
     * A ID that represents a previously stored payment method.
     *
     * @remarks
     * This ID can represent any type of payment method.
     */
    id: string;
    /**
     * This value is mandatory for stored redirect payment methods.
     *
     * @remarks
     * For stored cards, we strongly recommend providing a `redirect_url`
     * either when 3-D Secure is enabled and `three_d_secure_data`
     * is not provided, or when using connections where 3DS is enabled.
     * This value will be appended with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure
     * has completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | undefined;
    /**
     * The 3 or 4 digit security code often found on the card. This often
     *
     * @remarks
     * referred to as the CVV or CVD.
     *
     * The security code can only be set if the stored payment method
     * represents a card.
     */
    securityCode?: string | undefined;
};

/**
 * The method to use, this can be any of the methods that
 *
 * @remarks
 * support redirect requests.
 *
 * When storing a new payment method, only `gocardless` and `stripedd`
 * are currently supported.
 */
export enum TransactionRedirectRequestPaymentMethodMethod {
    Paypal = "paypal",
    Banked = "banked",
    Bitpay = "bitpay",
    Gocardless = "gocardless",
    Stripedd = "stripedd",
}

/**
 * Redirect payment method details to use in a transaction.
 */
export type Redirect = {
    /**
     * The method to use, this can be any of the methods that
     *
     * @remarks
     * support redirect requests.
     *
     * When storing a new payment method, only `gocardless` and `stripedd`
     * are currently supported.
     */
    method: TransactionRedirectRequestPaymentMethodMethod;
    /**
     * The redirect URL to redirect a buyer to after they have authorized their
     *
     * @remarks
     * transaction.
     */
    redirectUrl: string;
    /**
     * The ISO-4217 currency code to use this payment method for. This is
     *
     * @remarks
     * used to select the payment service to use.
     */
    currency: string;
    /**
     * The 2-letter ISO code of the country to use this payment method for.
     *
     * @remarks
     * This is used to select the payment service to use.
     */
    country: string;
    /**
     * An external identifier that can be used to match the account against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
};

/**
 * `card`.
 */
export enum TransactionCardRequestPaymentMethodMethod {
    Card = "card",
}

/**
 * Card payment method details to use in a transaction.
 */
export type PaymentMethodCard = {
    /**
     * `card`.
     */
    method: TransactionCardRequestPaymentMethodMethod;
    /**
     * The 13-19 digit number for this card as it can be found on the
     *
     * @remarks
     * front of the card.
     */
    number: string;
    /**
     * The expiration date of the card, formatted `MM/YY`.
     */
    expirationDate: string;
    /**
     * The 3 or 4 digit security code often found on the card. This often
     *
     * @remarks
     * referred to as the CVV or CVD.
     */
    securityCode: string;
    /**
     * An external identifier that can be used to match the card against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
 */
export type TransactionRequestPaymentMethod =
    | StoredPaymentMethodRequest
    | PaymentMethodCheckoutSession
    | Redirect
    | ApplePayPaymentMethodRequest
    | NetworkTokenPaymentMethodRequest
    | PaymentMethodCard
    | GooglePayPaymentMethodRequest;

/**
 * The platform that is being used to access the website.
 */
export enum UserDevice {
    Desktop = "desktop",
    Mobile = "mobile",
}

/**
 * Information about the browser used by the buyer.
 */
export type BrowserInfo = {
    /**
     * Indicates whether the client browser supports Java.
     */
    javaEnabled: boolean;
    /**
     * Indicates whether the client browser supports JavaScript.
     */
    javascriptEnabled: boolean;
    /**
     * The preferred language of the buyer,
     *
     * @remarks
     * usually the language of the browser UI.
     */
    language: string;
    /**
     * The color depth of the screen.
     */
    colorDepth: number;
    /**
     * The height of the screen in pixels.
     */
    screenHeight: number;
    /**
     * The width of the screen in pixels.
     */
    screenWidth: number;
    /**
     * Time-zone offset in minutes between UTC and buyer location.
     */
    timeZoneOffset: number;
    /**
     * The platform that is being used to access the website.
     */
    userDevice: UserDevice;
    /**
     * The user agent string for the current browser.
     */
    userAgent: string;
    /**
     * The `Accept` header of the request from the buyer's browser.
     */
    acceptHeader?: string | undefined;
};

/**
 * Additional options for Cybersource payment gateway.
 */
export type CybersourceCard = {
    /**
     * An override for the merchant ID configured for the connector,
     *
     * @remarks
     * used in combination with meta keys.
     */
    metaKeyMerchantId?: string | null | undefined;
};

/**
 * Additional options for Cybersource Decision Manager (anti-fraud).
 */
export type CybersourceAntiFraud = {
    /**
     * An override for the merchant ID configured for the connector,
     *
     * @remarks
     * used in combination with meta keys.
     */
    metaKeyMerchantId?: string | null | undefined;
    /**
     * This is a key-value object for merchant defined data. Each key needs to be a
     *
     * @remarks
     * numeric string identifying the MDD field to set. For example, for field 1 set
     * the key to "1".
     */
    merchantDefinedData?: { [k: string]: string } | undefined;
};

/**
 * Additional options for Giving Block connector.
 */
export type GivingblockGivingblock = {
    /**
     * The default crypto currency to display on the hosted page
     *
     * @remarks
     * presented by The Giving Block.
     */
    defaultCryptocurrency?: string | undefined;
};

/**
 * Value to populate the `deliveryType` field in `primaryDeliveryDetails`.
 *
 * @remarks
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export enum DeliveryType {
    Physical = "PHYSICAL",
    Digital = "DIGITAL",
    Hybrid = "HYBRID",
}

/**
 * Tangible if physical item, non-tangible if any other product.
 */
export enum TransactionRequestType {
    Tangible = "TANGIBLE",
    NonTangible = "NON_TANGIBLE",
}

/**
 * General data regarding item such as name, price, etc.
 */
export type BasicItemData = {
    /**
     * Tangible if physical item, non-tangible if any other product.
     */
    type?: TransactionRequestType | undefined;
};

/**
 * Value to populate the `deliveryType` field for this cart item. This overrides
 *
 * @remarks
 * the type set at the wider level.
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export enum TransactionRequestDeliveryType {
    Physical = "PHYSICAL",
    Digital = "DIGITAL",
    Hybrid = "HYBRID",
}

/**
 * General data regarding item such as name, price, etc.
 */
export type DeliveryDetails = {
    /**
     * Value to populate the `deliveryType` field for this cart item. This overrides
     *
     * @remarks
     * the type set at the wider level.
     *
     * Represents the type of delivery. This can be set to `PHYSICAL` for any
     * type of shipped goods, `DIGITAL` for non-shipped goods (services,
     * gift cards etc.), or `HYBRID` for others.
     */
    deliveryType?: TransactionRequestDeliveryType | null | undefined;
    /**
     * Value to populate the `deliveryMethod` field for this cart item. This overrides
     *
     * @remarks
     * the method set at the wider level.
     *
     * Represents the delivery method chosen by customer such as postal service,
     * email, in game transfer, etc.
     */
    deliveryMethod?: string | undefined;
};

/**
 * Personal details are those which contribute to building up a picture
 *
 * @remarks
 * of the person as an individual, such as name, title, etc.
 */
export type PersonalDetails = {
    /**
     * First name.
     */
    firstName?: string | undefined;
    /**
     * Last name.
     */
    lastName?: string | undefined;
    /**
     * Email address.
     */
    email?: string | undefined;
};

/**
 * Address details for the beneficiary.
 */
export type TransactionRequestAddress = {
    /**
     * Country, two-letter ISO 3166-1 alpha 2 country code.
     */
    country: string;
    /**
     * Street-level address. Required when full address details are available.
     */
    address1?: string | null | undefined;
    /**
     * Unit-level address.
     */
    address2?: string | null | undefined;
    /**
     * Zipcode.
     */
    zip?: string | null | undefined;
    /**
     * Top-level administrative subdivision - state/province/department/etc.
     *
     * @remarks
     * Can be either abbreviated format or full name (NY/New York).
     */
    region?: string | null | undefined;
    /**
     * Company name.
     */
    company?: string | null | undefined;
    /**
     * City. Required when full address details are available.
     */
    city?: string | null | undefined;
};

export type Phone = {
    /**
     * Phone number including all country and local access codes.
     */
    phone: string;
};

/**
 * Comments to merchant or beneficiary written by customer.
 */
export type Comments = {
    /**
     * Comments the customer left to the merchant.
     */
    userCommentsToMerchant?: string | null | undefined;
    /**
     * Comments the customer left to the beneficiary of the purchase made.
     */
    messageToBeneficiary?: string | null | undefined;
    /**
     * Comments by the merchant.
     */
    merchantComments?: string | null | undefined;
};

export type Beneficiaries = {
    /**
     * Personal details are those which contribute to building up a picture
     *
     * @remarks
     * of the person as an individual, such as name, title, etc.
     */
    personalDetails: PersonalDetails;
    /**
     * Address details for the beneficiary.
     */
    address?: TransactionRequestAddress | null | undefined;
    /**
     * List of all phone numbers for the beneficiary.
     */
    phone?: Array<Phone> | undefined;
    /**
     * Comments to merchant or beneficiary written by customer.
     */
    comments?: Comments | null | undefined;
};

export type CartItems = {
    /**
     * General data regarding item such as name, price, etc.
     */
    basicItemData?: BasicItemData | undefined;
    /**
     * General data regarding item such as name, price, etc.
     */
    deliveryDetails?: DeliveryDetails | undefined;
    /**
     * List of all entities receiving or using the purchased cart item.
     */
    beneficiaries?: Array<Beneficiaries> | undefined;
};

/**
 * A monetary amount in USD or local currency.
 */
export type CouponDiscountAmount = {
    /**
     * Transaction amount in USD.
     */
    amountUsd?: string | undefined;
    /**
     * Transaction amount in currency chosen by the buyer.
     */
    amountLocalCurrency?: string | undefined;
    /**
     * Transaction currency chosen by the buyer, 3-letter ISO-4217 format currency code.
     */
    currency?: string | undefined;
};

/**
 * The `totalDiscount` object that's sent to Forter's validation API.
 *
 * @remarks
 * It represents the discount that was given to the customer.
 */
export type TotalDiscount = {
    /**
     * The coupon code used.
     */
    couponCodeUsed?: string | undefined;
    /**
     * The discount type.
     */
    discountType: string;
    /**
     * A monetary amount in USD or local currency.
     */
    couponDiscountAmount?: CouponDiscountAmount | null | undefined;
    /**
     * Coupon discount percentage.
     */
    couponDiscountPercent?: string | null | undefined;
};

/**
 * Additional options for Forter (anti-fraud).
 */
export type ForterAntiFraud = {
    /**
     * Value to populate the `deliveryType` field in `primaryDeliveryDetails`.
     *
     * @remarks
     *
     * Represents the type of delivery. This can be set to `PHYSICAL` for any
     * type of shipped goods, `DIGITAL` for non-shipped goods (services,
     * gift cards etc.), or `HYBRID` for others.
     */
    deliveryType?: DeliveryType | null | undefined;
    /**
     * Value to populate the `deliveryMethod` field in `primaryDeliveryDetails`.
     *
     * @remarks
     *
     * Represents the delivery method chosen by customer such as postal service,
     * email, in game transfer, etc.
     */
    deliveryMethod?: string | null | undefined;
    /**
     * Defines if this is a guest check-out. This will redact the `accountId` and
     *
     * @remarks
     * `created` fields from the `accountOwner` details sent to Forter.
     */
    isGuestBuyer?: boolean | undefined;
    /**
     * A list of Forter cart item objects. These will be merged into the `cart_items`
     *
     * @remarks
     * passed to the transaction. Every cart item here will be merged with a cart item
     * on the transaction with the same index.
     *
     * Together, these will augment the `cartItems` values sent to the Forter validation
     * API.
     */
    cartItems?: Array<CartItems> | undefined;
    /**
     * The `totalDiscount` object that's sent to Forter's validation API.
     *
     * @remarks
     * It represents the discount that was given to the customer.
     */
    totalDiscount?: TotalDiscount | null | undefined;
};

/**
 * Additional options to be passed through to Adyen when processing
 *
 * @remarks
 * card transactions.
 */
export type AdyenCard = {
    /**
     * A key-value object representing additional data to be passed
     *
     * @remarks
     * to Adyen.
     */
    additionalData?: { [k: string]: string } | undefined;
};

export type AdditionalData = {
    key?: string | undefined;
    value?: string | undefined;
};

/**
 * Additional options to be passed through to PayPal when processing
 *
 * @remarks
 * transactions.
 */
export type PaypalPaypal = {
    /**
     * An array with key-value objects representing additional
     *
     * @remarks
     * data to be passed to PayPal.
     */
    additionalData?: Array<AdditionalData> | undefined;
};

export type TransactionRequestAdditionalData = {
    key?: string | undefined;
    value?: string | undefined;
};

/**
 * Additional options to be passed through to PayPal when processing
 *
 * @remarks
 * transactions.
 */
export type PaypalPaypalpaylater = {
    /**
     * An array with key-value objects representing additional
     *
     * @remarks
     * data to be passed to PayPal.
     */
    additionalData?: Array<TransactionRequestAdditionalData> | undefined;
};

/**
 * Stripe Connect configuration options.
 */
export type StripeConnect = {
    /**
     * The ID of the connected Stripe account to process for.
     */
    stripeAccount?: string | null | undefined;
    /**
     * The application fee to charge when processing for a connected account.
     */
    applicationFeeAmount?: number | null | undefined;
    /**
     * The Stripe account ID that these funds are intended for.
     */
    onBehalfOf?: string | null | undefined;
};

/**
 * Additional options to be passed through to Stripe when processing
 *
 * @remarks
 * transactions.
 */
export type StripeCard = {
    /**
     * Defines if Stripe should automatically fail the payment if it
     *
     * @remarks
     * requires two-factor authentication from the user.
     */
    errorOnRequiresAction?: boolean | undefined;
    /**
     * Stripe Connect configuration options.
     */
    stripeConnect?: StripeConnect | null | undefined;
};

/**
 * Allows for passing optional configuration per connection to take
 *
 * @remarks
 * advantage of connection specific features. When provided, the data
 * is only passed to the target connection type to prevent sharing
 * configuration across connections.
 *
 * Please note that each of the keys this object are in kebab-case, for
 * example `cybersource-anti-fraud` as they represent the ID of the
 * connector. All the other keys will be snake case, for example
 * `merchant_defined_data` or camel case to match an external API that the
 * connector uses.
 */
export type ConnectionOptions = {
    /**
     * Additional options for Cybersource payment gateway.
     */
    cybersourceCard?: CybersourceCard | null | undefined;
    /**
     * Additional options for Cybersource Decision Manager (anti-fraud).
     */
    cybersourceAntiFraud?: CybersourceAntiFraud | null | undefined;
    /**
     * Additional options for Giving Block connector.
     */
    givingblockGivingblock?: GivingblockGivingblock | null | undefined;
    /**
     * Additional options for Forter (anti-fraud).
     */
    forterAntiFraud?: ForterAntiFraud | null | undefined;
    /**
     * Additional options to be passed through to Adyen when processing
     *
     * @remarks
     * card transactions.
     */
    adyenCard?: AdyenCard | null | undefined;
    /**
     * Additional options to be passed through to PayPal when processing
     *
     * @remarks
     * transactions.
     */
    paypalPaypal?: PaypalPaypal | null | undefined;
    /**
     * Additional options to be passed through to PayPal when processing
     *
     * @remarks
     * transactions.
     */
    paypalPaypalpaylater?: PaypalPaypalpaylater | null | undefined;
    /**
     * Additional options to be passed through to Stripe when processing
     *
     * @remarks
     * transactions.
     */
    stripeCard?: StripeCard | null | undefined;
};

export type TransactionRequestGiftCards =
    | TransactionGiftCardStoredRequest
    | TransactionGiftCardNewRequest;

/**
 * Defines the intent of this API call. This determines the desired initial
 *
 * @remarks
 * state of the transaction.
 *
 * * `authorize` - (Default) Optionally approves and then authorizes a
 * transaction but does not capture the funds.
 * * `capture` - Optionally approves and then authorizes and captures the
 * funds of the transaction.
 */
export enum TransactionRequestIntent {
    Authorize = "authorize",
    Capture = "capture",
}

/**
 * The source of the transaction. Defaults to `ecommerce`.
 */
export enum PaymentSource {
    Ecommerce = "ecommerce",
    Moto = "moto",
    Recurring = "recurring",
    Installment = "installment",
    CardOnFile = "card_on_file",
}

/**
 * The statement descriptor is the text to be shown on the buyer's statements.
 *
 * @remarks
 *
 * The specific usage of these fields will depend on the capabilities of
 * the underlying PSP and bank. As a typical example, 'name' and
 * 'description' could be concatenated using '* ' as a separator, and
 * then the resulting descriptor would be truncated to 22 characters by
 * the issuing bank.
 */
export type StatementDescriptor = {
    /**
     * Reflects your doing business as (DBA) name.
     *
     * @remarks
     *
     * Other validations:
     *
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    name?: string | null | undefined;
    /**
     * A short description about the purchase.
     *
     * @remarks
     *
     * Other validations:
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    description?: string | null | undefined;
    /**
     * City from which the charge originated.
     */
    city?: string | null | undefined;
    /**
     * The value in the phone number field of a customer's statement which
     *
     * @remarks
     * should be formatted according to the
     * [E164 number standard](https://www.twilio.com/docs/glossary/what-e164).
     */
    phoneNumber?: string | null | undefined;
    /**
     * The value in the URL/web address field of a customer's statement.
     */
    url?: string | null | undefined;
};

/**
 * Pass through 3-D Secure data to support external 3-D Secure authorisation.
 *
 * @remarks
 * If using an external 3-D Secure provider, you should not pass
 * a `redirect_url` in the `payment_method` object for a transaction.
 */
export type ThreeDSecureData = ThreeDSecureDataV2 | ThreeDSecureDataV1;

/**
 * A request to create a transaction.
 */
export type TransactionRequest = {
    /**
     * The monetary amount for this transaction, in the smallest
     *
     * @remarks
     * currency unit for the given currency, for example `1299` cents to create
     * an authorization for `$12.99`.
     *
     * If the `intent` is set to `capture`, an amount greater than zero must
     * be supplied.
     *
     * All gift card amounts are subtracted from this amount before the
     * remainder is charged to the provided `payment_method`.
     */
    amount: number;
    /**
     * A supported ISO-4217 currency code.
     *
     * @remarks
     *
     * For redirect requests, this value must match the one specified for
     * `currency` in `payment_method`.
     *
     */
    currency: string;
    /**
     * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
     */
    paymentMethod?:
        | StoredPaymentMethodRequest
        | PaymentMethodCheckoutSession
        | Redirect
        | ApplePayPaymentMethodRequest
        | NetworkTokenPaymentMethodRequest
        | PaymentMethodCard
        | GooglePayPaymentMethodRequest
        | null
        | undefined;
    /**
     * This field represents the fingerprint data to be passed to the active
     *
     * @remarks
     * anti-fraud service.
     */
    antiFraudFingerprint?: string | null | undefined;
    /**
     * Whether to capture the transaction asynchronously.
     *
     * @remarks
     *
     * - When `async_capture` is `false` (default), the transaction is captured
     *   in the same request.
     * - When `async_capture` is `true`, the transaction is automatically
     *   captured at a later time.
     *
     * Redirect transactions are not affected by this flag.
     *
     * This flag can only be set to `true` when `intent` is set to `capture`.
     */
    asyncCapture?: boolean | undefined;
    /**
     * Information about the browser used by the buyer.
     */
    browserInfo?: BrowserInfo | null | undefined;
    /**
     * The `external_identifier` of the buyer to associate this payment method
     *
     * @remarks
     * to. If this field is provided then the `buyer_id` field
     * needs to be unset.
     *
     * If a stored payment method or gift card is provided, then the buyer for
     * that payment method needs to match the buyer for this field.
     */
    buyerExternalIdentifier?: string | undefined;
    /**
     * The ID of the buyer to associate this payment method to. If this field is
     *
     * @remarks
     * provided then the `buyer_external_identifier` field needs to be unset.
     *
     * If a stored payment method or gift card is provided, then the buyer for
     * that payment method needs to match the buyer for this field.
     */
    buyerId?: string | undefined;
    /**
     * An array of cart items that represents the line items of a transaction.
     */
    cartItems?: Array<CartItem> | undefined;
    /**
     * Allows for passing optional configuration per connection to take
     *
     * @remarks
     * advantage of connection specific features. When provided, the data
     * is only passed to the target connection type to prevent sharing
     * configuration across connections.
     *
     * Please note that each of the keys this object are in kebab-case, for
     * example `cybersource-anti-fraud` as they represent the ID of the
     * connector. All the other keys will be snake case, for example
     * `merchant_defined_data` or camel case to match an external API that the
     * connector uses.
     */
    connectionOptions?: ConnectionOptions | null | undefined;
    /**
     * The 2-letter ISO code of the country of the transaction.
     *
     * @remarks
     * This is used to filter the payment services that is used to process the
     * transaction.
     *
     * If this value is provided for redirect requests and it's not `null`, it
     * must match the one specified for `country` in `payment_method`. Otherwise,
     * the value specified for `country` in `payment_method` will be assumed
     * implicitly.
     *
     */
    country?: string | null | undefined;
    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added.
     *
     * @remarks
     * By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
     */
    giftCards?:
        | Array<TransactionGiftCardStoredRequest | TransactionGiftCardNewRequest>
        | null
        | undefined;
    /**
     * Defines the intent of this API call. This determines the desired initial
     *
     * @remarks
     * state of the transaction.
     *
     * * `authorize` - (Default) Optionally approves and then authorizes a
     * transaction but does not capture the funds.
     * * `capture` - Optionally approves and then authorizes and captures the
     * funds of the transaction.
     */
    intent?: TransactionRequestIntent | undefined;
    /**
     * Indicates whether the transaction represents a subsequent payment
     *
     * @remarks
     * coming from a setup recurring payment.
     * Please note there are some restrictions on how this flag may be
     * used.
     *
     * The flag can only be `false` (or not set) when the transaction meets
     * one of the following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     *
     * The flag can only be set to `true` when the transaction meets one of the
     * following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and
     * `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    isSubsequentPayment?: boolean | undefined;
    /**
     * Indicates whether the transaction was initiated by the merchant (true)
     *
     * @remarks
     * or customer (false).
     */
    merchantInitiated?: boolean | undefined;
    /**
     * Any additional information about the transaction that you would like to
     *
     * @remarks
     * store as key-value pairs. This data is passed to payment service
     * providers that support it.
     */
    metadata?: { [k: string]: string } | undefined;
    /**
     * The source of the transaction. Defaults to `ecommerce`.
     */
    paymentSource?: PaymentSource | undefined;
    /**
     * A scheme's transaction identifier to use in connecting a merchant
     *
     * @remarks
     * initiated transaction to a previous customer initiated transaction.
     *
     * If not provided, and a qualifying customer initiated transaction has been
     * previously made, then Gr4vy will populate this value with the identifier
     * returned for that transaction.
     *
     * e.g. the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    previousSchemeTransactionId?: string | null | undefined;
    /**
     * The unique identifier of a set of shipping details stored for the buyer.
     *
     * @remarks
     *
     * If provided, the created transaction will include a copy of the details
     * at the point of transaction creation; i.e. it will not be affected by
     * later changes to the detail in the database.
     */
    shippingDetailsId?: string | null | undefined;
    statementDescriptor?: StatementDescriptor | null | undefined;
    /**
     * Whether or not to also try and store the payment method with us so that
     *
     * @remarks
     * it can be used again for future use. This is only supported for payment
     * methods that support this feature. There are also a few restrictions on
     * how the flag may be set:
     *
     * * The flag has to be set to `true` when the `payment_source` is set to
     * `recurring` or `installment`, and `merchant_initiated` is set to `false`.
     *
     * * The flag has to be set to `false` (or not set) when using a previously
     * vaulted payment method.
     */
    store?: boolean | undefined;
    /**
     * Pass through 3-D Secure data to support external 3-D Secure authorisation.
     *
     * @remarks
     * If using an external 3-D Secure provider, you should not pass
     * a `redirect_url` in the `payment_method` object for a transaction.
     */
    threeDSecureData?: ThreeDSecureDataV2 | ThreeDSecureDataV1 | undefined;
    /**
     * The unique identifier of an existing payment service. When
     *
     * @remarks
     * provided, the created transaction will be processed by the given
     * payment service and any routing rules will be skipped.
     */
    paymentServiceId?: string | null | undefined;
};

/** @internal */
export namespace TransactionNetworkTokenRequestPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(TransactionNetworkTokenRequestPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace NetworkTokenPaymentMethodRequest$ {
    export const inboundSchema: z.ZodType<NetworkTokenPaymentMethodRequest, z.ZodTypeDef, unknown> =
        z
            .object({
                method: TransactionNetworkTokenRequestPaymentMethodMethod$.inboundSchema,
                token: z.string(),
                expiration_date: z.string(),
                cryptogram: z.nullable(z.string()).optional(),
                redirect_url: z.nullable(z.string()).optional(),
            })
            .transform((v) => {
                return remap$(v, {
                    expiration_date: "expirationDate",
                    redirect_url: "redirectUrl",
                });
            });

    export type Outbound = {
        method: string;
        token: string;
        expiration_date: string;
        cryptogram?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        NetworkTokenPaymentMethodRequest
    > = z
        .object({
            method: TransactionNetworkTokenRequestPaymentMethodMethod$.outboundSchema,
            token: z.string(),
            expirationDate: z.string(),
            cryptogram: z.nullable(z.string()).optional(),
            redirectUrl: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                expirationDate: "expiration_date",
                redirectUrl: "redirect_url",
            });
        });
}

/** @internal */
export namespace TransactionCheckoutSessionRequestPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(TransactionCheckoutSessionRequestPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodCheckoutSession$ {
    export const inboundSchema: z.ZodType<PaymentMethodCheckoutSession, z.ZodTypeDef, unknown> = z
        .object({
            method: TransactionCheckoutSessionRequestPaymentMethodMethod$.inboundSchema,
            id: z.string(),
            external_identifier: z.nullable(z.string()).optional(),
            redirect_url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                external_identifier: "externalIdentifier",
                redirect_url: "redirectUrl",
            });
        });

    export type Outbound = {
        method: string;
        id: string;
        external_identifier?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodCheckoutSession> = z
        .object({
            method: TransactionCheckoutSessionRequestPaymentMethodMethod$.outboundSchema,
            id: z.string(),
            externalIdentifier: z.nullable(z.string()).optional(),
            redirectUrl: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                externalIdentifier: "external_identifier",
                redirectUrl: "redirect_url",
            });
        });
}

/** @internal */
export namespace GooglePayRequestPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(GooglePayRequestPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace AssuranceDetails$ {
    export const inboundSchema: z.ZodType<AssuranceDetails, z.ZodTypeDef, unknown> = z
        .object({
            account_verified: z.nullable(z.boolean()).optional(),
            card_holder_authenticated: z.nullable(z.boolean()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                account_verified: "accountVerified",
                card_holder_authenticated: "cardHolderAuthenticated",
            });
        });

    export type Outbound = {
        account_verified?: boolean | null | undefined;
        card_holder_authenticated?: boolean | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssuranceDetails> = z
        .object({
            accountVerified: z.nullable(z.boolean()).optional(),
            cardHolderAuthenticated: z.nullable(z.boolean()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                accountVerified: "account_verified",
                cardHolderAuthenticated: "card_holder_authenticated",
            });
        });
}

/** @internal */
export namespace GooglePayPaymentMethodRequest$ {
    export const inboundSchema: z.ZodType<GooglePayPaymentMethodRequest, z.ZodTypeDef, unknown> = z
        .object({
            method: GooglePayRequestPaymentMethodMethod$.inboundSchema,
            token: z.string(),
            card_suffix: z.nullable(z.string()).optional(),
            card_scheme: z.nullable(z.string()).optional(),
            card_type: z.nullable(z.string()).optional(),
            assurance_details: z.nullable(z.lazy(() => AssuranceDetails$.inboundSchema)).optional(),
            cardholder_name: z.nullable(z.string()).optional(),
            redirect_url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                card_suffix: "cardSuffix",
                card_scheme: "cardScheme",
                card_type: "cardType",
                assurance_details: "assuranceDetails",
                cardholder_name: "cardholderName",
                redirect_url: "redirectUrl",
            });
        });

    export type Outbound = {
        method: string;
        token: string;
        card_suffix?: string | null | undefined;
        card_scheme?: string | null | undefined;
        card_type?: string | null | undefined;
        assurance_details?: AssuranceDetails$.Outbound | null | undefined;
        cardholder_name?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GooglePayPaymentMethodRequest> =
        z
            .object({
                method: GooglePayRequestPaymentMethodMethod$.outboundSchema,
                token: z.string(),
                cardSuffix: z.nullable(z.string()).optional(),
                cardScheme: z.nullable(z.string()).optional(),
                cardType: z.nullable(z.string()).optional(),
                assuranceDetails: z
                    .nullable(z.lazy(() => AssuranceDetails$.outboundSchema))
                    .optional(),
                cardholderName: z.nullable(z.string()).optional(),
                redirectUrl: z.nullable(z.string()).optional(),
            })
            .transform((v) => {
                return remap$(v, {
                    cardSuffix: "card_suffix",
                    cardScheme: "card_scheme",
                    cardType: "card_type",
                    assuranceDetails: "assurance_details",
                    cardholderName: "cardholder_name",
                    redirectUrl: "redirect_url",
                });
            });
}

/** @internal */
export namespace ApplePayRequestPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(ApplePayRequestPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Token$ {
    export const inboundSchema: z.ZodType<Token, z.ZodTypeDef, unknown> = z.object({});

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Token> = z.object({});
}

/** @internal */
export namespace ApplePayPaymentMethodRequest$ {
    export const inboundSchema: z.ZodType<ApplePayPaymentMethodRequest, z.ZodTypeDef, unknown> = z
        .object({
            method: ApplePayRequestPaymentMethodMethod$.inboundSchema,
            token: z.lazy(() => Token$.inboundSchema),
            card_suffix: z.nullable(z.string()).optional(),
            card_scheme: z.nullable(z.string()).optional(),
            card_type: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                card_suffix: "cardSuffix",
                card_scheme: "cardScheme",
                card_type: "cardType",
            });
        });

    export type Outbound = {
        method: string;
        token: Token$.Outbound;
        card_suffix?: string | null | undefined;
        card_scheme?: string | null | undefined;
        card_type?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ApplePayPaymentMethodRequest> = z
        .object({
            method: ApplePayRequestPaymentMethodMethod$.outboundSchema,
            token: z.lazy(() => Token$.outboundSchema),
            cardSuffix: z.nullable(z.string()).optional(),
            cardScheme: z.nullable(z.string()).optional(),
            cardType: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                cardSuffix: "card_suffix",
                cardScheme: "card_scheme",
                cardType: "card_type",
            });
        });
}

/** @internal */
export namespace TokenizedRequestPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(TokenizedRequestPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace StoredPaymentMethodRequest$ {
    export const inboundSchema: z.ZodType<StoredPaymentMethodRequest, z.ZodTypeDef, unknown> = z
        .object({
            method: TokenizedRequestPaymentMethodMethod$.inboundSchema,
            id: z.string(),
            redirect_url: z.string().optional(),
            security_code: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                redirect_url: "redirectUrl",
                security_code: "securityCode",
            });
        });

    export type Outbound = {
        method: string;
        id: string;
        redirect_url?: string | undefined;
        security_code?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StoredPaymentMethodRequest> = z
        .object({
            method: TokenizedRequestPaymentMethodMethod$.outboundSchema,
            id: z.string(),
            redirectUrl: z.string().optional(),
            securityCode: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                redirectUrl: "redirect_url",
                securityCode: "security_code",
            });
        });
}

/** @internal */
export namespace TransactionRedirectRequestPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(TransactionRedirectRequestPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Redirect$ {
    export const inboundSchema: z.ZodType<Redirect, z.ZodTypeDef, unknown> = z
        .object({
            method: TransactionRedirectRequestPaymentMethodMethod$.inboundSchema,
            redirect_url: z.string(),
            currency: z.string(),
            country: z.string(),
            external_identifier: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                redirect_url: "redirectUrl",
                external_identifier: "externalIdentifier",
            });
        });

    export type Outbound = {
        method: string;
        redirect_url: string;
        currency: string;
        country: string;
        external_identifier?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Redirect> = z
        .object({
            method: TransactionRedirectRequestPaymentMethodMethod$.outboundSchema,
            redirectUrl: z.string(),
            currency: z.string(),
            country: z.string(),
            externalIdentifier: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                redirectUrl: "redirect_url",
                externalIdentifier: "external_identifier",
            });
        });
}

/** @internal */
export namespace TransactionCardRequestPaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(TransactionCardRequestPaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodCard$ {
    export const inboundSchema: z.ZodType<PaymentMethodCard, z.ZodTypeDef, unknown> = z
        .object({
            method: TransactionCardRequestPaymentMethodMethod$.inboundSchema,
            number: z.string(),
            expiration_date: z.string(),
            security_code: z.string(),
            external_identifier: z.nullable(z.string()).optional(),
            redirect_url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                expiration_date: "expirationDate",
                security_code: "securityCode",
                external_identifier: "externalIdentifier",
                redirect_url: "redirectUrl",
            });
        });

    export type Outbound = {
        method: string;
        number: string;
        expiration_date: string;
        security_code: string;
        external_identifier?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodCard> = z
        .object({
            method: TransactionCardRequestPaymentMethodMethod$.outboundSchema,
            number: z.string(),
            expirationDate: z.string(),
            securityCode: z.string(),
            externalIdentifier: z.nullable(z.string()).optional(),
            redirectUrl: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                expirationDate: "expiration_date",
                securityCode: "security_code",
                externalIdentifier: "external_identifier",
                redirectUrl: "redirect_url",
            });
        });
}

/** @internal */
export namespace TransactionRequestPaymentMethod$ {
    export const inboundSchema: z.ZodType<TransactionRequestPaymentMethod, z.ZodTypeDef, unknown> =
        z.union([
            z.lazy(() => StoredPaymentMethodRequest$.inboundSchema),
            z.lazy(() => PaymentMethodCheckoutSession$.inboundSchema),
            z.lazy(() => Redirect$.inboundSchema),
            z.lazy(() => ApplePayPaymentMethodRequest$.inboundSchema),
            z.lazy(() => NetworkTokenPaymentMethodRequest$.inboundSchema),
            z.lazy(() => PaymentMethodCard$.inboundSchema),
            z.lazy(() => GooglePayPaymentMethodRequest$.inboundSchema),
        ]);

    export type Outbound =
        | StoredPaymentMethodRequest$.Outbound
        | PaymentMethodCheckoutSession$.Outbound
        | Redirect$.Outbound
        | ApplePayPaymentMethodRequest$.Outbound
        | NetworkTokenPaymentMethodRequest$.Outbound
        | PaymentMethodCard$.Outbound
        | GooglePayPaymentMethodRequest$.Outbound;
    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        TransactionRequestPaymentMethod
    > = z.union([
        z.lazy(() => StoredPaymentMethodRequest$.outboundSchema),
        z.lazy(() => PaymentMethodCheckoutSession$.outboundSchema),
        z.lazy(() => Redirect$.outboundSchema),
        z.lazy(() => ApplePayPaymentMethodRequest$.outboundSchema),
        z.lazy(() => NetworkTokenPaymentMethodRequest$.outboundSchema),
        z.lazy(() => PaymentMethodCard$.outboundSchema),
        z.lazy(() => GooglePayPaymentMethodRequest$.outboundSchema),
    ]);
}

/** @internal */
export namespace UserDevice$ {
    export const inboundSchema = z.nativeEnum(UserDevice);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace BrowserInfo$ {
    export const inboundSchema: z.ZodType<BrowserInfo, z.ZodTypeDef, unknown> = z
        .object({
            java_enabled: z.boolean(),
            javascript_enabled: z.boolean(),
            language: z.string(),
            color_depth: z.number(),
            screen_height: z.number(),
            screen_width: z.number(),
            time_zone_offset: z.number(),
            user_device: UserDevice$.inboundSchema,
            user_agent: z.string(),
            accept_header: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                java_enabled: "javaEnabled",
                javascript_enabled: "javascriptEnabled",
                color_depth: "colorDepth",
                screen_height: "screenHeight",
                screen_width: "screenWidth",
                time_zone_offset: "timeZoneOffset",
                user_device: "userDevice",
                user_agent: "userAgent",
                accept_header: "acceptHeader",
            });
        });

    export type Outbound = {
        java_enabled: boolean;
        javascript_enabled: boolean;
        language: string;
        color_depth: number;
        screen_height: number;
        screen_width: number;
        time_zone_offset: number;
        user_device: string;
        user_agent: string;
        accept_header?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BrowserInfo> = z
        .object({
            javaEnabled: z.boolean(),
            javascriptEnabled: z.boolean(),
            language: z.string(),
            colorDepth: z.number(),
            screenHeight: z.number(),
            screenWidth: z.number(),
            timeZoneOffset: z.number(),
            userDevice: UserDevice$.outboundSchema,
            userAgent: z.string(),
            acceptHeader: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                javaEnabled: "java_enabled",
                javascriptEnabled: "javascript_enabled",
                colorDepth: "color_depth",
                screenHeight: "screen_height",
                screenWidth: "screen_width",
                timeZoneOffset: "time_zone_offset",
                userDevice: "user_device",
                userAgent: "user_agent",
                acceptHeader: "accept_header",
            });
        });
}

/** @internal */
export namespace CybersourceCard$ {
    export const inboundSchema: z.ZodType<CybersourceCard, z.ZodTypeDef, unknown> = z
        .object({
            meta_key_merchant_id: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                meta_key_merchant_id: "metaKeyMerchantId",
            });
        });

    export type Outbound = {
        meta_key_merchant_id?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CybersourceCard> = z
        .object({
            metaKeyMerchantId: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                metaKeyMerchantId: "meta_key_merchant_id",
            });
        });
}

/** @internal */
export namespace CybersourceAntiFraud$ {
    export const inboundSchema: z.ZodType<CybersourceAntiFraud, z.ZodTypeDef, unknown> = z
        .object({
            meta_key_merchant_id: z.nullable(z.string()).optional(),
            merchant_defined_data: z.record(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                meta_key_merchant_id: "metaKeyMerchantId",
                merchant_defined_data: "merchantDefinedData",
            });
        });

    export type Outbound = {
        meta_key_merchant_id?: string | null | undefined;
        merchant_defined_data?: { [k: string]: string } | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CybersourceAntiFraud> = z
        .object({
            metaKeyMerchantId: z.nullable(z.string()).optional(),
            merchantDefinedData: z.record(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                metaKeyMerchantId: "meta_key_merchant_id",
                merchantDefinedData: "merchant_defined_data",
            });
        });
}

/** @internal */
export namespace GivingblockGivingblock$ {
    export const inboundSchema: z.ZodType<GivingblockGivingblock, z.ZodTypeDef, unknown> = z.object(
        {
            defaultCryptocurrency: z.string().optional(),
        }
    );

    export type Outbound = {
        defaultCryptocurrency?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GivingblockGivingblock> =
        z.object({
            defaultCryptocurrency: z.string().optional(),
        });
}

/** @internal */
export namespace DeliveryType$ {
    export const inboundSchema = z.nativeEnum(DeliveryType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace TransactionRequestType$ {
    export const inboundSchema = z.nativeEnum(TransactionRequestType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace BasicItemData$ {
    export const inboundSchema: z.ZodType<BasicItemData, z.ZodTypeDef, unknown> = z.object({
        type: TransactionRequestType$.inboundSchema.optional(),
    });

    export type Outbound = {
        type?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BasicItemData> = z.object({
        type: TransactionRequestType$.outboundSchema.optional(),
    });
}

/** @internal */
export namespace TransactionRequestDeliveryType$ {
    export const inboundSchema = z.nativeEnum(TransactionRequestDeliveryType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace DeliveryDetails$ {
    export const inboundSchema: z.ZodType<DeliveryDetails, z.ZodTypeDef, unknown> = z
        .object({
            delivery_type: z.nullable(TransactionRequestDeliveryType$.inboundSchema).optional(),
            delivery_method: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                delivery_type: "deliveryType",
                delivery_method: "deliveryMethod",
            });
        });

    export type Outbound = {
        delivery_type?: string | null | undefined;
        delivery_method?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, DeliveryDetails> = z
        .object({
            deliveryType: z.nullable(TransactionRequestDeliveryType$.outboundSchema).optional(),
            deliveryMethod: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                deliveryType: "delivery_type",
                deliveryMethod: "delivery_method",
            });
        });
}

/** @internal */
export namespace PersonalDetails$ {
    export const inboundSchema: z.ZodType<PersonalDetails, z.ZodTypeDef, unknown> = z
        .object({
            first_name: z.string().optional(),
            last_name: z.string().optional(),
            email: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                first_name: "firstName",
                last_name: "lastName",
            });
        });

    export type Outbound = {
        first_name?: string | undefined;
        last_name?: string | undefined;
        email?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PersonalDetails> = z
        .object({
            firstName: z.string().optional(),
            lastName: z.string().optional(),
            email: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                firstName: "first_name",
                lastName: "last_name",
            });
        });
}

/** @internal */
export namespace TransactionRequestAddress$ {
    export const inboundSchema: z.ZodType<TransactionRequestAddress, z.ZodTypeDef, unknown> =
        z.object({
            country: z.string(),
            address1: z.nullable(z.string()).optional(),
            address2: z.nullable(z.string()).optional(),
            zip: z.nullable(z.string()).optional(),
            region: z.nullable(z.string()).optional(),
            company: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
        });

    export type Outbound = {
        country: string;
        address1?: string | null | undefined;
        address2?: string | null | undefined;
        zip?: string | null | undefined;
        region?: string | null | undefined;
        company?: string | null | undefined;
        city?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionRequestAddress> =
        z.object({
            country: z.string(),
            address1: z.nullable(z.string()).optional(),
            address2: z.nullable(z.string()).optional(),
            zip: z.nullable(z.string()).optional(),
            region: z.nullable(z.string()).optional(),
            company: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
        });
}

/** @internal */
export namespace Phone$ {
    export const inboundSchema: z.ZodType<Phone, z.ZodTypeDef, unknown> = z.object({
        phone: z.string(),
    });

    export type Outbound = {
        phone: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Phone> = z.object({
        phone: z.string(),
    });
}

/** @internal */
export namespace Comments$ {
    export const inboundSchema: z.ZodType<Comments, z.ZodTypeDef, unknown> = z
        .object({
            user_comments_to_merchant: z.nullable(z.string()).optional(),
            message_to_beneficiary: z.nullable(z.string()).optional(),
            merchant_comments: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                user_comments_to_merchant: "userCommentsToMerchant",
                message_to_beneficiary: "messageToBeneficiary",
                merchant_comments: "merchantComments",
            });
        });

    export type Outbound = {
        user_comments_to_merchant?: string | null | undefined;
        message_to_beneficiary?: string | null | undefined;
        merchant_comments?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Comments> = z
        .object({
            userCommentsToMerchant: z.nullable(z.string()).optional(),
            messageToBeneficiary: z.nullable(z.string()).optional(),
            merchantComments: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                userCommentsToMerchant: "user_comments_to_merchant",
                messageToBeneficiary: "message_to_beneficiary",
                merchantComments: "merchant_comments",
            });
        });
}

/** @internal */
export namespace Beneficiaries$ {
    export const inboundSchema: z.ZodType<Beneficiaries, z.ZodTypeDef, unknown> = z
        .object({
            personal_details: z.lazy(() => PersonalDetails$.inboundSchema),
            address: z.nullable(z.lazy(() => TransactionRequestAddress$.inboundSchema)).optional(),
            phone: z.array(z.lazy(() => Phone$.inboundSchema)).optional(),
            comments: z.nullable(z.lazy(() => Comments$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                personal_details: "personalDetails",
            });
        });

    export type Outbound = {
        personal_details: PersonalDetails$.Outbound;
        address?: TransactionRequestAddress$.Outbound | null | undefined;
        phone?: Array<Phone$.Outbound> | undefined;
        comments?: Comments$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Beneficiaries> = z
        .object({
            personalDetails: z.lazy(() => PersonalDetails$.outboundSchema),
            address: z.nullable(z.lazy(() => TransactionRequestAddress$.outboundSchema)).optional(),
            phone: z.array(z.lazy(() => Phone$.outboundSchema)).optional(),
            comments: z.nullable(z.lazy(() => Comments$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                personalDetails: "personal_details",
            });
        });
}

/** @internal */
export namespace CartItems$ {
    export const inboundSchema: z.ZodType<CartItems, z.ZodTypeDef, unknown> = z
        .object({
            basic_item_data: z.lazy(() => BasicItemData$.inboundSchema).optional(),
            delivery_details: z.lazy(() => DeliveryDetails$.inboundSchema).optional(),
            beneficiaries: z.array(z.lazy(() => Beneficiaries$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                basic_item_data: "basicItemData",
                delivery_details: "deliveryDetails",
            });
        });

    export type Outbound = {
        basic_item_data?: BasicItemData$.Outbound | undefined;
        delivery_details?: DeliveryDetails$.Outbound | undefined;
        beneficiaries?: Array<Beneficiaries$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CartItems> = z
        .object({
            basicItemData: z.lazy(() => BasicItemData$.outboundSchema).optional(),
            deliveryDetails: z.lazy(() => DeliveryDetails$.outboundSchema).optional(),
            beneficiaries: z.array(z.lazy(() => Beneficiaries$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                basicItemData: "basic_item_data",
                deliveryDetails: "delivery_details",
            });
        });
}

/** @internal */
export namespace CouponDiscountAmount$ {
    export const inboundSchema: z.ZodType<CouponDiscountAmount, z.ZodTypeDef, unknown> = z
        .object({
            amount_usd: z.string().optional(),
            amount_local_currency: z.string().optional(),
            currency: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                amount_usd: "amountUsd",
                amount_local_currency: "amountLocalCurrency",
            });
        });

    export type Outbound = {
        amount_usd?: string | undefined;
        amount_local_currency?: string | undefined;
        currency?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CouponDiscountAmount> = z
        .object({
            amountUsd: z.string().optional(),
            amountLocalCurrency: z.string().optional(),
            currency: z.string().optional(),
        })
        .transform((v) => {
            return remap$(v, {
                amountUsd: "amount_usd",
                amountLocalCurrency: "amount_local_currency",
            });
        });
}

/** @internal */
export namespace TotalDiscount$ {
    export const inboundSchema: z.ZodType<TotalDiscount, z.ZodTypeDef, unknown> = z
        .object({
            coupon_code_used: z.string().optional(),
            discount_type: z.string(),
            coupon_discount_amount: z
                .nullable(z.lazy(() => CouponDiscountAmount$.inboundSchema))
                .optional(),
            coupon_discount_percent: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                coupon_code_used: "couponCodeUsed",
                discount_type: "discountType",
                coupon_discount_amount: "couponDiscountAmount",
                coupon_discount_percent: "couponDiscountPercent",
            });
        });

    export type Outbound = {
        coupon_code_used?: string | undefined;
        discount_type: string;
        coupon_discount_amount?: CouponDiscountAmount$.Outbound | null | undefined;
        coupon_discount_percent?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TotalDiscount> = z
        .object({
            couponCodeUsed: z.string().optional(),
            discountType: z.string(),
            couponDiscountAmount: z
                .nullable(z.lazy(() => CouponDiscountAmount$.outboundSchema))
                .optional(),
            couponDiscountPercent: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                couponCodeUsed: "coupon_code_used",
                discountType: "discount_type",
                couponDiscountAmount: "coupon_discount_amount",
                couponDiscountPercent: "coupon_discount_percent",
            });
        });
}

/** @internal */
export namespace ForterAntiFraud$ {
    export const inboundSchema: z.ZodType<ForterAntiFraud, z.ZodTypeDef, unknown> = z
        .object({
            delivery_type: z.nullable(DeliveryType$.inboundSchema).optional(),
            delivery_method: z.nullable(z.string()).optional(),
            is_guest_buyer: z.boolean().default(false),
            cart_items: z.array(z.lazy(() => CartItems$.inboundSchema)).optional(),
            total_discount: z.nullable(z.lazy(() => TotalDiscount$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                delivery_type: "deliveryType",
                delivery_method: "deliveryMethod",
                is_guest_buyer: "isGuestBuyer",
                cart_items: "cartItems",
                total_discount: "totalDiscount",
            });
        });

    export type Outbound = {
        delivery_type?: string | null | undefined;
        delivery_method?: string | null | undefined;
        is_guest_buyer: boolean;
        cart_items?: Array<CartItems$.Outbound> | undefined;
        total_discount?: TotalDiscount$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ForterAntiFraud> = z
        .object({
            deliveryType: z.nullable(DeliveryType$.outboundSchema).optional(),
            deliveryMethod: z.nullable(z.string()).optional(),
            isGuestBuyer: z.boolean().default(false),
            cartItems: z.array(z.lazy(() => CartItems$.outboundSchema)).optional(),
            totalDiscount: z.nullable(z.lazy(() => TotalDiscount$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                deliveryType: "delivery_type",
                deliveryMethod: "delivery_method",
                isGuestBuyer: "is_guest_buyer",
                cartItems: "cart_items",
                totalDiscount: "total_discount",
            });
        });
}

/** @internal */
export namespace AdyenCard$ {
    export const inboundSchema: z.ZodType<AdyenCard, z.ZodTypeDef, unknown> = z.object({
        additionalData: z.record(z.string()).optional(),
    });

    export type Outbound = {
        additionalData?: { [k: string]: string } | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AdyenCard> = z.object({
        additionalData: z.record(z.string()).optional(),
    });
}

/** @internal */
export namespace AdditionalData$ {
    export const inboundSchema: z.ZodType<AdditionalData, z.ZodTypeDef, unknown> = z.object({
        key: z.string().optional(),
        value: z.string().optional(),
    });

    export type Outbound = {
        key?: string | undefined;
        value?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AdditionalData> = z.object({
        key: z.string().optional(),
        value: z.string().optional(),
    });
}

/** @internal */
export namespace PaypalPaypal$ {
    export const inboundSchema: z.ZodType<PaypalPaypal, z.ZodTypeDef, unknown> = z
        .object({
            additional_data: z.array(z.lazy(() => AdditionalData$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                additional_data: "additionalData",
            });
        });

    export type Outbound = {
        additional_data?: Array<AdditionalData$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaypalPaypal> = z
        .object({
            additionalData: z.array(z.lazy(() => AdditionalData$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                additionalData: "additional_data",
            });
        });
}

/** @internal */
export namespace TransactionRequestAdditionalData$ {
    export const inboundSchema: z.ZodType<TransactionRequestAdditionalData, z.ZodTypeDef, unknown> =
        z.object({
            key: z.string().optional(),
            value: z.string().optional(),
        });

    export type Outbound = {
        key?: string | undefined;
        value?: string | undefined;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        TransactionRequestAdditionalData
    > = z.object({
        key: z.string().optional(),
        value: z.string().optional(),
    });
}

/** @internal */
export namespace PaypalPaypalpaylater$ {
    export const inboundSchema: z.ZodType<PaypalPaypalpaylater, z.ZodTypeDef, unknown> = z
        .object({
            additional_data: z
                .array(z.lazy(() => TransactionRequestAdditionalData$.inboundSchema))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                additional_data: "additionalData",
            });
        });

    export type Outbound = {
        additional_data?: Array<TransactionRequestAdditionalData$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaypalPaypalpaylater> = z
        .object({
            additionalData: z
                .array(z.lazy(() => TransactionRequestAdditionalData$.outboundSchema))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                additionalData: "additional_data",
            });
        });
}

/** @internal */
export namespace StripeConnect$ {
    export const inboundSchema: z.ZodType<StripeConnect, z.ZodTypeDef, unknown> = z
        .object({
            stripe_account: z.nullable(z.string()).optional(),
            application_fee_amount: z.nullable(z.number()).optional(),
            on_behalf_of: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                stripe_account: "stripeAccount",
                application_fee_amount: "applicationFeeAmount",
                on_behalf_of: "onBehalfOf",
            });
        });

    export type Outbound = {
        stripe_account?: string | null | undefined;
        application_fee_amount?: number | null | undefined;
        on_behalf_of?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StripeConnect> = z
        .object({
            stripeAccount: z.nullable(z.string()).optional(),
            applicationFeeAmount: z.nullable(z.number()).optional(),
            onBehalfOf: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                stripeAccount: "stripe_account",
                applicationFeeAmount: "application_fee_amount",
                onBehalfOf: "on_behalf_of",
            });
        });
}

/** @internal */
export namespace StripeCard$ {
    export const inboundSchema: z.ZodType<StripeCard, z.ZodTypeDef, unknown> = z
        .object({
            error_on_requires_action: z.boolean().default(false),
            stripe_connect: z.nullable(z.lazy(() => StripeConnect$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                error_on_requires_action: "errorOnRequiresAction",
                stripe_connect: "stripeConnect",
            });
        });

    export type Outbound = {
        error_on_requires_action: boolean;
        stripe_connect?: StripeConnect$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StripeCard> = z
        .object({
            errorOnRequiresAction: z.boolean().default(false),
            stripeConnect: z.nullable(z.lazy(() => StripeConnect$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                errorOnRequiresAction: "error_on_requires_action",
                stripeConnect: "stripe_connect",
            });
        });
}

/** @internal */
export namespace ConnectionOptions$ {
    export const inboundSchema: z.ZodType<ConnectionOptions, z.ZodTypeDef, unknown> = z
        .object({
            "cybersource-card": z.nullable(z.lazy(() => CybersourceCard$.inboundSchema)).optional(),
            "cybersource-anti-fraud": z
                .nullable(z.lazy(() => CybersourceAntiFraud$.inboundSchema))
                .optional(),
            "givingblock-givingblock": z
                .nullable(z.lazy(() => GivingblockGivingblock$.inboundSchema))
                .optional(),
            "forter-anti-fraud": z
                .nullable(z.lazy(() => ForterAntiFraud$.inboundSchema))
                .optional(),
            "adyen-card": z.nullable(z.lazy(() => AdyenCard$.inboundSchema)).optional(),
            "paypal-paypal": z.nullable(z.lazy(() => PaypalPaypal$.inboundSchema)).optional(),
            "paypal-paypalpaylater": z
                .nullable(z.lazy(() => PaypalPaypalpaylater$.inboundSchema))
                .optional(),
            "stripe-card": z.nullable(z.lazy(() => StripeCard$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                "cybersource-card": "cybersourceCard",
                "cybersource-anti-fraud": "cybersourceAntiFraud",
                "givingblock-givingblock": "givingblockGivingblock",
                "forter-anti-fraud": "forterAntiFraud",
                "adyen-card": "adyenCard",
                "paypal-paypal": "paypalPaypal",
                "paypal-paypalpaylater": "paypalPaypalpaylater",
                "stripe-card": "stripeCard",
            });
        });

    export type Outbound = {
        "cybersource-card"?: CybersourceCard$.Outbound | null | undefined;
        "cybersource-anti-fraud"?: CybersourceAntiFraud$.Outbound | null | undefined;
        "givingblock-givingblock"?: GivingblockGivingblock$.Outbound | null | undefined;
        "forter-anti-fraud"?: ForterAntiFraud$.Outbound | null | undefined;
        "adyen-card"?: AdyenCard$.Outbound | null | undefined;
        "paypal-paypal"?: PaypalPaypal$.Outbound | null | undefined;
        "paypal-paypalpaylater"?: PaypalPaypalpaylater$.Outbound | null | undefined;
        "stripe-card"?: StripeCard$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ConnectionOptions> = z
        .object({
            cybersourceCard: z.nullable(z.lazy(() => CybersourceCard$.outboundSchema)).optional(),
            cybersourceAntiFraud: z
                .nullable(z.lazy(() => CybersourceAntiFraud$.outboundSchema))
                .optional(),
            givingblockGivingblock: z
                .nullable(z.lazy(() => GivingblockGivingblock$.outboundSchema))
                .optional(),
            forterAntiFraud: z.nullable(z.lazy(() => ForterAntiFraud$.outboundSchema)).optional(),
            adyenCard: z.nullable(z.lazy(() => AdyenCard$.outboundSchema)).optional(),
            paypalPaypal: z.nullable(z.lazy(() => PaypalPaypal$.outboundSchema)).optional(),
            paypalPaypalpaylater: z
                .nullable(z.lazy(() => PaypalPaypalpaylater$.outboundSchema))
                .optional(),
            stripeCard: z.nullable(z.lazy(() => StripeCard$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                cybersourceCard: "cybersource-card",
                cybersourceAntiFraud: "cybersource-anti-fraud",
                givingblockGivingblock: "givingblock-givingblock",
                forterAntiFraud: "forter-anti-fraud",
                adyenCard: "adyen-card",
                paypalPaypal: "paypal-paypal",
                paypalPaypalpaylater: "paypal-paypalpaylater",
                stripeCard: "stripe-card",
            });
        });
}

/** @internal */
export namespace TransactionRequestGiftCards$ {
    export const inboundSchema: z.ZodType<TransactionRequestGiftCards, z.ZodTypeDef, unknown> =
        z.union([
            TransactionGiftCardStoredRequest$.inboundSchema,
            TransactionGiftCardNewRequest$.inboundSchema,
        ]);

    export type Outbound =
        | TransactionGiftCardStoredRequest$.Outbound
        | TransactionGiftCardNewRequest$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionRequestGiftCards> =
        z.union([
            TransactionGiftCardStoredRequest$.outboundSchema,
            TransactionGiftCardNewRequest$.outboundSchema,
        ]);
}

/** @internal */
export namespace TransactionRequestIntent$ {
    export const inboundSchema = z.nativeEnum(TransactionRequestIntent);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentSource$ {
    export const inboundSchema = z.nativeEnum(PaymentSource);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace StatementDescriptor$ {
    export const inboundSchema: z.ZodType<StatementDescriptor, z.ZodTypeDef, unknown> = z
        .object({
            name: z.nullable(z.string()).optional(),
            description: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
            phone_number: z.nullable(z.string()).optional(),
            url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                phone_number: "phoneNumber",
            });
        });

    export type Outbound = {
        name?: string | null | undefined;
        description?: string | null | undefined;
        city?: string | null | undefined;
        phone_number?: string | null | undefined;
        url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StatementDescriptor> = z
        .object({
            name: z.nullable(z.string()).optional(),
            description: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
            phoneNumber: z.nullable(z.string()).optional(),
            url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                phoneNumber: "phone_number",
            });
        });
}

/** @internal */
export namespace ThreeDSecureData$ {
    export const inboundSchema: z.ZodType<ThreeDSecureData, z.ZodTypeDef, unknown> = z.union([
        ThreeDSecureDataV2$.inboundSchema,
        ThreeDSecureDataV1$.inboundSchema,
    ]);

    export type Outbound = ThreeDSecureDataV2$.Outbound | ThreeDSecureDataV1$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ThreeDSecureData> = z.union([
        ThreeDSecureDataV2$.outboundSchema,
        ThreeDSecureDataV1$.outboundSchema,
    ]);
}

/** @internal */
export namespace TransactionRequest$ {
    export const inboundSchema: z.ZodType<TransactionRequest, z.ZodTypeDef, unknown> = z
        .object({
            amount: z.number().int(),
            currency: z.string(),
            payment_method: z
                .nullable(
                    z.union([
                        z.lazy(() => StoredPaymentMethodRequest$.inboundSchema),
                        z.lazy(() => PaymentMethodCheckoutSession$.inboundSchema),
                        z.lazy(() => Redirect$.inboundSchema),
                        z.lazy(() => ApplePayPaymentMethodRequest$.inboundSchema),
                        z.lazy(() => NetworkTokenPaymentMethodRequest$.inboundSchema),
                        z.lazy(() => PaymentMethodCard$.inboundSchema),
                        z.lazy(() => GooglePayPaymentMethodRequest$.inboundSchema),
                    ])
                )
                .optional(),
            anti_fraud_fingerprint: z.nullable(z.string()).default(null),
            async_capture: z.boolean().default(false),
            browser_info: z.nullable(z.lazy(() => BrowserInfo$.inboundSchema)).optional(),
            buyer_external_identifier: z.string().optional(),
            buyer_id: z.string().optional(),
            cart_items: z.array(CartItem$.inboundSchema).optional(),
            connection_options: z
                .nullable(z.lazy(() => ConnectionOptions$.inboundSchema))
                .optional(),
            country: z.nullable(z.string()).optional(),
            external_identifier: z.nullable(z.string()).optional(),
            gift_cards: z
                .nullable(
                    z.array(
                        z.union([
                            TransactionGiftCardStoredRequest$.inboundSchema,
                            TransactionGiftCardNewRequest$.inboundSchema,
                        ])
                    )
                )
                .optional(),
            intent: TransactionRequestIntent$.inboundSchema.default(
                TransactionRequestIntent.Authorize
            ),
            is_subsequent_payment: z.boolean().default(false),
            merchant_initiated: z.boolean().default(false),
            metadata: z.record(z.string()).optional(),
            payment_source: PaymentSource$.inboundSchema.optional(),
            previous_scheme_transaction_id: z.nullable(z.string()).default(null),
            shipping_details_id: z.nullable(z.string()).default(null),
            statement_descriptor: z
                .nullable(z.lazy(() => StatementDescriptor$.inboundSchema))
                .optional(),
            store: z.boolean().default(false),
            three_d_secure_data: z
                .union([ThreeDSecureDataV2$.inboundSchema, ThreeDSecureDataV1$.inboundSchema])
                .optional(),
            payment_service_id: z.nullable(z.string()).default(null),
        })
        .transform((v) => {
            return remap$(v, {
                payment_method: "paymentMethod",
                anti_fraud_fingerprint: "antiFraudFingerprint",
                async_capture: "asyncCapture",
                browser_info: "browserInfo",
                buyer_external_identifier: "buyerExternalIdentifier",
                buyer_id: "buyerId",
                cart_items: "cartItems",
                connection_options: "connectionOptions",
                external_identifier: "externalIdentifier",
                gift_cards: "giftCards",
                is_subsequent_payment: "isSubsequentPayment",
                merchant_initiated: "merchantInitiated",
                payment_source: "paymentSource",
                previous_scheme_transaction_id: "previousSchemeTransactionId",
                shipping_details_id: "shippingDetailsId",
                statement_descriptor: "statementDescriptor",
                three_d_secure_data: "threeDSecureData",
                payment_service_id: "paymentServiceId",
            });
        });

    export type Outbound = {
        amount: number;
        currency: string;
        payment_method?:
            | StoredPaymentMethodRequest$.Outbound
            | PaymentMethodCheckoutSession$.Outbound
            | Redirect$.Outbound
            | ApplePayPaymentMethodRequest$.Outbound
            | NetworkTokenPaymentMethodRequest$.Outbound
            | PaymentMethodCard$.Outbound
            | GooglePayPaymentMethodRequest$.Outbound
            | null
            | undefined;
        anti_fraud_fingerprint: string | null;
        async_capture: boolean;
        browser_info?: BrowserInfo$.Outbound | null | undefined;
        buyer_external_identifier?: string | undefined;
        buyer_id?: string | undefined;
        cart_items?: Array<CartItem$.Outbound> | undefined;
        connection_options?: ConnectionOptions$.Outbound | null | undefined;
        country?: string | null | undefined;
        external_identifier?: string | null | undefined;
        gift_cards?:
            | Array<
                  | TransactionGiftCardStoredRequest$.Outbound
                  | TransactionGiftCardNewRequest$.Outbound
              >
            | null
            | undefined;
        intent: string;
        is_subsequent_payment: boolean;
        merchant_initiated: boolean;
        metadata?: { [k: string]: string } | undefined;
        payment_source?: string | undefined;
        previous_scheme_transaction_id: string | null;
        shipping_details_id: string | null;
        statement_descriptor?: StatementDescriptor$.Outbound | null | undefined;
        store: boolean;
        three_d_secure_data?:
            | ThreeDSecureDataV2$.Outbound
            | ThreeDSecureDataV1$.Outbound
            | undefined;
        payment_service_id: string | null;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionRequest> = z
        .object({
            amount: z.number().int(),
            currency: z.string(),
            paymentMethod: z
                .nullable(
                    z.union([
                        z.lazy(() => StoredPaymentMethodRequest$.outboundSchema),
                        z.lazy(() => PaymentMethodCheckoutSession$.outboundSchema),
                        z.lazy(() => Redirect$.outboundSchema),
                        z.lazy(() => ApplePayPaymentMethodRequest$.outboundSchema),
                        z.lazy(() => NetworkTokenPaymentMethodRequest$.outboundSchema),
                        z.lazy(() => PaymentMethodCard$.outboundSchema),
                        z.lazy(() => GooglePayPaymentMethodRequest$.outboundSchema),
                    ])
                )
                .optional(),
            antiFraudFingerprint: z.nullable(z.string()).default(null),
            asyncCapture: z.boolean().default(false),
            browserInfo: z.nullable(z.lazy(() => BrowserInfo$.outboundSchema)).optional(),
            buyerExternalIdentifier: z.string().optional(),
            buyerId: z.string().optional(),
            cartItems: z.array(CartItem$.outboundSchema).optional(),
            connectionOptions: z
                .nullable(z.lazy(() => ConnectionOptions$.outboundSchema))
                .optional(),
            country: z.nullable(z.string()).optional(),
            externalIdentifier: z.nullable(z.string()).optional(),
            giftCards: z
                .nullable(
                    z.array(
                        z.union([
                            TransactionGiftCardStoredRequest$.outboundSchema,
                            TransactionGiftCardNewRequest$.outboundSchema,
                        ])
                    )
                )
                .optional(),
            intent: TransactionRequestIntent$.outboundSchema.default(
                TransactionRequestIntent.Authorize
            ),
            isSubsequentPayment: z.boolean().default(false),
            merchantInitiated: z.boolean().default(false),
            metadata: z.record(z.string()).optional(),
            paymentSource: PaymentSource$.outboundSchema.optional(),
            previousSchemeTransactionId: z.nullable(z.string()).default(null),
            shippingDetailsId: z.nullable(z.string()).default(null),
            statementDescriptor: z
                .nullable(z.lazy(() => StatementDescriptor$.outboundSchema))
                .optional(),
            store: z.boolean().default(false),
            threeDSecureData: z
                .union([ThreeDSecureDataV2$.outboundSchema, ThreeDSecureDataV1$.outboundSchema])
                .optional(),
            paymentServiceId: z.nullable(z.string()).default(null),
        })
        .transform((v) => {
            return remap$(v, {
                paymentMethod: "payment_method",
                antiFraudFingerprint: "anti_fraud_fingerprint",
                asyncCapture: "async_capture",
                browserInfo: "browser_info",
                buyerExternalIdentifier: "buyer_external_identifier",
                buyerId: "buyer_id",
                cartItems: "cart_items",
                connectionOptions: "connection_options",
                externalIdentifier: "external_identifier",
                giftCards: "gift_cards",
                isSubsequentPayment: "is_subsequent_payment",
                merchantInitiated: "merchant_initiated",
                paymentSource: "payment_source",
                previousSchemeTransactionId: "previous_scheme_transaction_id",
                shippingDetailsId: "shipping_details_id",
                statementDescriptor: "statement_descriptor",
                threeDSecureData: "three_d_secure_data",
                paymentServiceId: "payment_service_id",
            });
        });
}
