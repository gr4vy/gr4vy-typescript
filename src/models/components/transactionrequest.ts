/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { CartItem, CartItem$ } from "./cartitem";
import { ThreeDSecureDataV1, ThreeDSecureDataV1$ } from "./threedsecuredatav1";
import { ThreeDSecureDataV2, ThreeDSecureDataV2$ } from "./threedsecuredatav2";
import {
    TransactionGiftCardNewRequest,
    TransactionGiftCardNewRequest$,
} from "./transactiongiftcardnewrequest";
import {
    TransactionGiftCardStoredRequest,
    TransactionGiftCardStoredRequest$,
} from "./transactiongiftcardstoredrequest";
import * as z from "zod";

/**
 * `checkout-session`.
 */
export enum TransactionCheckoutSessionRequestPaymentMethodMethod {
    CheckoutSession = "checkout-session",
}

/**
 * Checkout Session payment method details to use in a transaction.
 */
export type PaymentMethodCheckoutSession = {
    /**
     * `checkout-session`.
     */
    method: TransactionCheckoutSessionRequestPaymentMethodMethod;
    /**
     * The ID of the Checkout Session.
     */
    id: string;
    /**
     * An external identifier that can be used to match the card against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `googlepay`.
 */
export enum GooglePayRequestPaymentMethodMethod {
    Googlepay = "googlepay",
}

/**
 * Information about the validation performed on the payment data. (See https://developers.google.com/pay/api/web/reference/response-objects#assurance-details-specifications).
 */
export type AssuranceDetails = {
    /**
     * Indicates that card holder possession validation has been performed.
     */
    accountVerified?: boolean | null | undefined;
    /**
     * Indicates that identification and verifications was performed.
     */
    cardHolderAuthenticated?: boolean | null | undefined;
};

/**
 * Details for a Google Pay payment method.
 */
export type GooglePayPaymentMethodRequest = {
    /**
     * `googlepay`.
     */
    method: GooglePayRequestPaymentMethodMethod;
    /**
     * The encrypted (opaque) token returned by the Google Pay API that
     *
     * @remarks
     * represents a payment method.
     */
    token: string;
    /**
     * Information about the validation performed on the payment data. (See https://developers.google.com/pay/api/web/reference/response-objects#assurance-details-specifications).
     */
    assuranceDetails?: AssuranceDetails | null | undefined;
    /**
     * Name of the card holder.
     */
    cardHolderName?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * `applepay`.
 */
export enum ApplePayRequestPaymentMethodMethod {
    Applepay = "applepay",
}

/**
 * The encrypted (opaque) token that was passed to the `onpaymentauthorized`
 *
 * @remarks
 * callback by the Apple Pay integration.
 */
export type Token = {};

/**
 * Details for a Apple Pay payment method.
 */
export type ApplePayPaymentMethodRequest = {
    /**
     * `applepay`.
     */
    method: ApplePayRequestPaymentMethodMethod;
    /**
     * The encrypted (opaque) token that was passed to the `onpaymentauthorized`
     *
     * @remarks
     * callback by the Apple Pay integration.
     */
    token: Token;
};

/**
 * `id`.
 */
export enum TokenizedRequestPaymentMethodMethod {
    Id = "id",
}

/**
 * Details for a previously stored payment method.
 */
export type StoredPaymentMethodRequest = {
    /**
     * `id`.
     */
    method: TokenizedRequestPaymentMethodMethod;
    /**
     * A ID that represents a previously stored payment method.
     *
     * @remarks
     * This ID can represent any type of payment method.
     */
    id: string;
    /**
     * This value is mandatory for stored redirect payment methods.
     *
     * @remarks
     * For stored cards, we strongly recommend providing a `redirect_url`
     * either when 3-D Secure is enabled and `three_d_secure_data`
     * is not provided, or when using connections where 3DS is enabled.
     * This value will be appended with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure
     * has completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | undefined;
    /**
     * The 3 or 4 digit security code often found on the card. This often
     *
     * @remarks
     * referred to as the CVV or CVD.
     *
     * The security code can only be set if the stored payment method
     * represents a card.
     */
    securityCode?: string | undefined;
};

/**
 * The method to use, this can be any of the methods that
 *
 * @remarks
 * support redirect requests.
 *
 * When storing a new payment method, only `gocardless` and `stripedd`
 * are currently supported.
 */
export enum TransactionRedirectRequestPaymentMethodMethod {
    Paypal = "paypal",
    Banked = "banked",
    Bitpay = "bitpay",
    Gocardless = "gocardless",
    Stripedd = "stripedd",
}

/**
 * Redirect payment method details to use in a transaction.
 */
export type Redirect = {
    /**
     * The method to use, this can be any of the methods that
     *
     * @remarks
     * support redirect requests.
     *
     * When storing a new payment method, only `gocardless` and `stripedd`
     * are currently supported.
     */
    method: TransactionRedirectRequestPaymentMethodMethod;
    /**
     * The redirect URL to redirect a buyer to after they have authorized their
     *
     * @remarks
     * transaction.
     */
    redirectUrl: string;
    /**
     * The ISO-4217 currency code to use this payment method for. This is
     *
     * @remarks
     * used to select the payment service to use.
     */
    currency: string;
    /**
     * The 2-letter ISO code of the country to use this payment method for.
     *
     * @remarks
     * This is used to select the payment service to use.
     */
    country: string;
    /**
     * An external identifier that can be used to match the account against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
};

/**
 * `card`.
 */
export enum TransactionCardRequestPaymentMethodMethod {
    Card = "card",
}

/**
 * Card payment method details to use in a transaction.
 */
export type PaymentMethodCard = {
    /**
     * `card`.
     */
    method: TransactionCardRequestPaymentMethodMethod;
    /**
     * The 13-19 digit number for this card as it can be found on the
     *
     * @remarks
     * front of the card.
     */
    number: string;
    /**
     * The expiration date of the card, formatted `MM/YY`.
     */
    expirationDate: string;
    /**
     * The 3 or 4 digit security code often found on the card. This often
     *
     * @remarks
     * referred to as the CVV or CVD.
     */
    securityCode: string;
    /**
     * An external identifier that can be used to match the card against your own records. This can only be set if the `store` flag is set to `true`.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * We strongly recommend providing a `redirect_url` either when 3-D
     *
     * @remarks
     * Secure is enabled and `three_d_secure_data` is not provided, or when
     * using connections where 3DS is enabled. This value will be appended
     * with both a transaction ID and status
     * (e.g. `https://example.com/callback?gr4vy_transaction_id=123
     * &gr4vy_transaction_status=capture_succeeded`) after 3-D Secure has
     * completed. For those cases, if the value is not present, the
     * transaction will be marked as failed.
     */
    redirectUrl?: string | null | undefined;
};

/**
 * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
 */
export type TransactionRequestPaymentMethod =
    | ApplePayPaymentMethodRequest
    | StoredPaymentMethodRequest
    | PaymentMethodCheckoutSession
    | Redirect
    | GooglePayPaymentMethodRequest
    | PaymentMethodCard;

/**
 * The platform that is being used to access the website.
 */
export enum UserDevice {
    Desktop = "desktop",
    Mobile = "mobile",
}

/**
 * Information about the browser used by the buyer.
 */
export type BrowserInfo = {
    /**
     * Indicates whether the client browser supports Java.
     */
    javaEnabled: boolean;
    /**
     * Indicates whether the client browser supports JavaScript.
     */
    javascriptEnabled: boolean;
    /**
     * The preferred language of the buyer,
     *
     * @remarks
     * usually the language of the browser UI.
     */
    language: string;
    /**
     * The color depth of the screen.
     */
    colorDepth: number;
    /**
     * The height of the screen in pixels.
     */
    screenHeight: number;
    /**
     * The width of the screen in pixels.
     */
    screenWidth: number;
    /**
     * Time-zone offset in minutes between UTC and buyer location.
     */
    timeZoneOffset: number;
    /**
     * The platform that is being used to access the website.
     */
    userDevice: UserDevice;
    /**
     * The user agent string for the current browser.
     */
    userAgent: string;
    /**
     * The `Accept` header of the request from the buyer's browser.
     */
    acceptHeader?: string | undefined;
};

/**
 * Additional options for Cybersource payment gateway.
 */
export type CybersourceCard = {
    /**
     * An override for the merchant ID configured for the connector,
     *
     * @remarks
     * used in combination with meta keys.
     */
    metaKeyMerchantId?: string | null | undefined;
};

/**
 * Additional options for Cybersource Decision Manager (anti-fraud).
 */
export type CybersourceAntiFraud = {
    /**
     * An override for the merchant ID configured for the connector,
     *
     * @remarks
     * used in combination with meta keys.
     */
    metaKeyMerchantId?: string | null | undefined;
    /**
     * This is a key-value object for merchant defined data. Each key needs to be a
     *
     * @remarks
     * numeric string identifying the MDD field to set. For example, for field 1 set
     * the key to "1".
     */
    merchantDefinedData?: Record<string, string> | undefined;
};

/**
 * Value to populate the `deliveryType` field in `primaryDeliveryDetails`.
 *
 * @remarks
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export enum DeliveryType {
    Physical = "PHYSICAL",
    Digital = "DIGITAL",
    Hybrid = "HYBRID",
}

/**
 * Tangible if physical item, non-tangible if any other product.
 */
export enum TransactionRequestType {
    Tangible = "TANGIBLE",
    NonTangible = "NON_TANGIBLE",
}

/**
 * General data regarding item such as name, price, etc.
 */
export type BasicItemData = {
    /**
     * Tangible if physical item, non-tangible if any other product.
     */
    type?: TransactionRequestType | undefined;
};

/**
 * Value to populate the `deliveryType` field for this cart item. This overrides
 *
 * @remarks
 * the type set at the wider level.
 *
 * Represents the type of delivery. This can be set to `PHYSICAL` for any
 * type of shipped goods, `DIGITAL` for non-shipped goods (services,
 * gift cards etc.), or `HYBRID` for others.
 */
export enum TransactionRequestDeliveryType {
    Physical = "PHYSICAL",
    Digital = "DIGITAL",
    Hybrid = "HYBRID",
}

/**
 * General data regarding item such as name, price, etc.
 */
export type DeliveryDetails = {
    /**
     * Value to populate the `deliveryType` field for this cart item. This overrides
     *
     * @remarks
     * the type set at the wider level.
     *
     * Represents the type of delivery. This can be set to `PHYSICAL` for any
     * type of shipped goods, `DIGITAL` for non-shipped goods (services,
     * gift cards etc.), or `HYBRID` for others.
     */
    deliveryType?: TransactionRequestDeliveryType | null | undefined;
    /**
     * Value to populate the `deliveryMethod` field for this cart item. This overrides
     *
     * @remarks
     * the method set at the wider level.
     *
     * Represents the delivery method chosen by customer such as postal service,
     * email, in game transfer, etc.
     */
    deliveryMethod?: string | undefined;
};

/**
 * Personal details are those which contribute to building up a picture
 *
 * @remarks
 * of the person as an individual, such as name, title, etc.
 */
export type PersonalDetails = {
    /**
     * First name.
     */
    firstName?: string | undefined;
    /**
     * Last name.
     */
    lastName?: string | undefined;
    /**
     * Email address.
     */
    email?: string | undefined;
};

/**
 * Address details for the beneficiary.
 */
export type TransactionRequestAddress = {
    /**
     * Country, two-letter ISO 3166-1 alpha 2 country code.
     */
    country: string;
    /**
     * Street-level address. Required when full address details are available.
     */
    address1?: string | null | undefined;
    /**
     * Unit-level address.
     */
    address2?: string | null | undefined;
    /**
     * Zipcode.
     */
    zip?: string | null | undefined;
    /**
     * Top-level administrative subdivision - state/province/department/etc.
     *
     * @remarks
     * Can be either abbreviated format or full name (NY/New York).
     */
    region?: string | null | undefined;
    /**
     * Company name.
     */
    company?: string | null | undefined;
    /**
     * City. Required when full address details are available.
     */
    city?: string | null | undefined;
};

export type Phone = {
    /**
     * Phone number including all country and local access codes.
     */
    phone: string;
};

/**
 * Comments to merchant or beneficiary written by customer.
 */
export type Comments = {
    /**
     * Comments the customer left to the merchant.
     */
    userCommentsToMerchant?: string | null | undefined;
    /**
     * Comments the customer left to the beneficiary of the purchase made.
     */
    messageToBeneficiary?: string | null | undefined;
    /**
     * Comments by the merchant.
     */
    merchantComments?: string | null | undefined;
};

export type Beneficiaries = {
    /**
     * Personal details are those which contribute to building up a picture
     *
     * @remarks
     * of the person as an individual, such as name, title, etc.
     */
    personalDetails: PersonalDetails;
    /**
     * Address details for the beneficiary.
     */
    address?: TransactionRequestAddress | null | undefined;
    /**
     * List of all phone numbers for the beneficiary.
     */
    phone?: Array<Phone> | undefined;
    /**
     * Comments to merchant or beneficiary written by customer.
     */
    comments?: Comments | null | undefined;
};

export type CartItems = {
    /**
     * General data regarding item such as name, price, etc.
     */
    basicItemData?: BasicItemData | undefined;
    /**
     * General data regarding item such as name, price, etc.
     */
    deliveryDetails?: DeliveryDetails | undefined;
    /**
     * List of all entities receiving or using the purchased cart item.
     */
    beneficiaries?: Array<Beneficiaries> | undefined;
};

/**
 * A monetary amount in USD or local currency.
 */
export type CouponDiscountAmount = {
    /**
     * Transaction amount in USD.
     */
    amountUsd?: string | undefined;
    /**
     * Transaction amount in currency chosen by the buyer.
     */
    amountLocalCurrency?: string | undefined;
    /**
     * Transaction currency chosen by the buyer, 3-letter ISO-4217 format currency code.
     */
    currency?: string | undefined;
};

/**
 * The `totalDiscount` object that's sent to Forter's validation API.
 *
 * @remarks
 * It represents the discount that was given to the customer.
 */
export type TotalDiscount = {
    /**
     * The coupon code used.
     */
    couponCodeUsed?: string | undefined;
    /**
     * The discount type.
     */
    discountType: string;
    /**
     * A monetary amount in USD or local currency.
     */
    couponDiscountAmount?: CouponDiscountAmount | null | undefined;
    /**
     * Coupon discount percentage.
     */
    couponDiscountPercent?: string | null | undefined;
};

/**
 * Additional options for Forter (anti-fraud).
 */
export type ForterAntiFraud = {
    /**
     * Value to populate the `deliveryType` field in `primaryDeliveryDetails`.
     *
     * @remarks
     *
     * Represents the type of delivery. This can be set to `PHYSICAL` for any
     * type of shipped goods, `DIGITAL` for non-shipped goods (services,
     * gift cards etc.), or `HYBRID` for others.
     */
    deliveryType?: DeliveryType | null | undefined;
    /**
     * Value to populate the `deliveryMethod` field in `primaryDeliveryDetails`.
     *
     * @remarks
     *
     * Represents the delivery method chosen by customer such as postal service,
     * email, in game transfer, etc.
     */
    deliveryMethod?: string | null | undefined;
    /**
     * Defines if this is a guest check-out. This will redact the `accountId` and
     *
     * @remarks
     * `created` fields from the `accountOwner` details sent to Forter.
     */
    isGuestBuyer?: boolean | undefined;
    /**
     * A list of Forter cart item objects. These will be merged into the `cart_items`
     *
     * @remarks
     * passed to the transaction. Every cart item here will be merged with a cart item
     * on the transaction with the same index.
     *
     * Together, these will augment the `cartItems` values sent to the Forter validation
     * API.
     */
    cartItems?: Array<CartItems> | undefined;
    /**
     * The `totalDiscount` object that's sent to Forter's validation API.
     *
     * @remarks
     * It represents the discount that was given to the customer.
     */
    totalDiscount?: TotalDiscount | null | undefined;
};

/**
 * Additional options to be passed through to Adyen when processing
 *
 * @remarks
 * card transactions.
 */
export type AdyenCard = {
    /**
     * A key-value object representing additional data to be passed
     *
     * @remarks
     * to Adyen.
     */
    additionalData?: Record<string, string> | undefined;
};

export type AdditionalData = {
    key?: string | undefined;
    value?: string | undefined;
};

/**
 * Additional options to be passed through to PayPal when processing
 *
 * @remarks
 * transactions.
 */
export type PaypalPaypal = {
    /**
     * An array with key-value objects representing additional
     *
     * @remarks
     * data to be passed to PayPal.
     */
    additionalData?: Array<AdditionalData> | undefined;
};

export type TransactionRequestAdditionalData = {
    key?: string | undefined;
    value?: string | undefined;
};

/**
 * Additional options to be passed through to PayPal when processing
 *
 * @remarks
 * transactions.
 */
export type PaypalPaypalpaylater = {
    /**
     * An array with key-value objects representing additional
     *
     * @remarks
     * data to be passed to PayPal.
     */
    additionalData?: Array<TransactionRequestAdditionalData> | undefined;
};

/**
 * Stripe Connect configuration options.
 */
export type StripeConnect = {
    /**
     * The ID of the connected Stripe account to process for.
     */
    stripeAccount?: string | null | undefined;
    /**
     * The application fee to charge when processing for a connected account.
     */
    applicationFeeAmount?: number | null | undefined;
};

/**
 * Additional options to be passed through to Stripe when processing
 *
 * @remarks
 * transactions.
 */
export type StripeCard = {
    /**
     * Defines if Stripe should automatically fail the payment if it
     *
     * @remarks
     * requires two-factor authentication from the user.
     */
    errorOnRequiresAction?: boolean | undefined;
    /**
     * Stripe Connect configuration options.
     */
    stripeConnect?: StripeConnect | null | undefined;
};

/**
 * Allows for passing optional configuration per connection to take
 *
 * @remarks
 * advantage of connection specific features. When provided, the data
 * is only passed to the target connection type to prevent sharing
 * configuration across connections.
 *
 * Please note that each of the keys this object are in kebab-case, for
 * example `cybersource-anti-fraud` as they represent the ID of the
 * connector. All the other keys will be snake case, for example
 * `merchant_defined_data` or camel case to match an external API that the
 * connector uses.
 */
export type ConnectionOptions = {
    /**
     * Additional options for Cybersource payment gateway.
     */
    cybersourceCard?: CybersourceCard | null | undefined;
    /**
     * Additional options for Cybersource Decision Manager (anti-fraud).
     */
    cybersourceAntiFraud?: CybersourceAntiFraud | null | undefined;
    /**
     * Additional options for Forter (anti-fraud).
     */
    forterAntiFraud?: ForterAntiFraud | null | undefined;
    /**
     * Additional options to be passed through to Adyen when processing
     *
     * @remarks
     * card transactions.
     */
    adyenCard?: AdyenCard | null | undefined;
    /**
     * Additional options to be passed through to PayPal when processing
     *
     * @remarks
     * transactions.
     */
    paypalPaypal?: PaypalPaypal | null | undefined;
    /**
     * Additional options to be passed through to PayPal when processing
     *
     * @remarks
     * transactions.
     */
    paypalPaypalpaylater?: PaypalPaypalpaylater | null | undefined;
    /**
     * Additional options to be passed through to Stripe when processing
     *
     * @remarks
     * transactions.
     */
    stripeCard?: StripeCard | null | undefined;
};

export type TransactionRequestGiftCards =
    | TransactionGiftCardStoredRequest
    | TransactionGiftCardNewRequest;

/**
 * Defines the intent of this API call. This determines the desired initial
 *
 * @remarks
 * state of the transaction.
 *
 * * `authorize` - (Default) Optionally approves and then authorizes a
 * transaction but does not capture the funds.
 * * `capture` - Optionally approves and then authorizes and captures the
 * funds of the transaction.
 */
export enum TransactionRequestIntent {
    Authorize = "authorize",
    Capture = "capture",
}

/**
 * The source of the transaction. Defaults to `ecommerce`.
 */
export enum PaymentSource {
    Ecommerce = "ecommerce",
    Moto = "moto",
    Recurring = "recurring",
    Installment = "installment",
    CardOnFile = "card_on_file",
}

/**
 * The statement descriptor is the text to be shown on the buyer's statements.
 *
 * @remarks
 *
 * The specific usage of these fields will depend on the capabilities of
 * the underlying PSP and bank. As a typical example, 'name' and
 * 'description' could be concatenated using '* ' as a separator, and
 * then the resulting descriptor would be truncated to 22 characters by
 * the issuing bank.
 */
export type StatementDescriptor = {
    /**
     * Reflects your doing business as (DBA) name.
     *
     * @remarks
     *
     * Other validations:
     *
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    name?: string | null | undefined;
    /**
     * A short description about the purchase.
     *
     * @remarks
     *
     * Other validations:
     * 1. Contains only Latin characters.
     * 2. Contain at least one letter
     * 3. Does not contain any of the special characters `< > \ ' " *`
     * 4. Supports:
     *   1. Lower case: `a-z`
     *   2. Upper case: `A-Z`
     *   3. Numbers: `0-9`
     *   4. Spaces: ` `
     *   5. Special characters: `. , _ - ? + /`.
     */
    description?: string | null | undefined;
    /**
     * City from which the charge originated.
     */
    city?: string | null | undefined;
    /**
     * The value in the phone number field of a customer's statement which
     *
     * @remarks
     * should be formatted according to the
     * [E164 number standard](https://www.twilio.com/docs/glossary/what-e164).
     */
    phoneNumber?: string | null | undefined;
    /**
     * The value in the URL/web address field of a customer's statement.
     */
    url?: string | null | undefined;
};

/**
 * Pass through 3-D Secure data to support external 3-D Secure authorisation.
 *
 * @remarks
 * If using an external 3-D Secure provider, you should not pass
 * a `redirect_url` in the `payment_method` object for a transaction.
 */
export type ThreeDSecureData = ThreeDSecureDataV2 | ThreeDSecureDataV1;

/**
 * A request to create a transaction.
 */
export type TransactionRequest = {
    /**
     * The monetary amount for this transaction, in the smallest
     *
     * @remarks
     * currency unit for the given currency, for example `1299` cents to create
     * an authorization for `$12.99`.
     *
     * If the `intent` is set to `capture`, an amount greater than zero must
     * be supplied.
     *
     * All gift card amounts are subtracted from this amount before the
     * remainder is charged to the provided `payment_method`.
     */
    amount: number;
    /**
     * A supported ISO-4217 currency code.
     *
     * @remarks
     *
     * For redirect requests, this value must match the one specified for
     * `currency` in `payment_method`.
     *
     */
    currency: string;
    /**
     * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
     */
    paymentMethod?:
        | ApplePayPaymentMethodRequest
        | StoredPaymentMethodRequest
        | PaymentMethodCheckoutSession
        | Redirect
        | GooglePayPaymentMethodRequest
        | PaymentMethodCard
        | null
        | undefined;
    /**
     * This field represents the fingerprint data to be passed to the active
     *
     * @remarks
     * anti-fraud service.
     */
    antiFraudFingerprint?: string | null | undefined;
    /**
     * Whether to capture the transaction asynchronously.
     *
     * @remarks
     *
     * - When `async_capture` is `false` (default), the transaction is captured
     *   in the same request.
     * - When `async_capture` is `true`, the transaction is automatically
     *   captured at a later time.
     *
     * Redirect transactions are not affected by this flag.
     *
     * This flag can only be set to `true` when `intent` is set to `capture`.
     */
    asyncCapture?: boolean | undefined;
    /**
     * Information about the browser used by the buyer.
     */
    browserInfo?: BrowserInfo | null | undefined;
    /**
     * The `external_identifier` of the buyer to associate this payment method
     *
     * @remarks
     * to. If this field is provided then the `buyer_id` field
     * needs to be unset.
     *
     * If a stored payment method or gift card is provided, then the buyer for
     * that payment method needs to match the buyer for this field.
     */
    buyerExternalIdentifier?: string | undefined;
    /**
     * The ID of the buyer to associate this payment method to. If this field is
     *
     * @remarks
     * provided then the `buyer_external_identifier` field needs to be unset.
     *
     * If a stored payment method or gift card is provided, then the buyer for
     * that payment method needs to match the buyer for this field.
     */
    buyerId?: string | undefined;
    /**
     * An array of cart items that represents the line items of a transaction.
     */
    cartItems?: Array<CartItem> | undefined;
    /**
     * Allows for passing optional configuration per connection to take
     *
     * @remarks
     * advantage of connection specific features. When provided, the data
     * is only passed to the target connection type to prevent sharing
     * configuration across connections.
     *
     * Please note that each of the keys this object are in kebab-case, for
     * example `cybersource-anti-fraud` as they represent the ID of the
     * connector. All the other keys will be snake case, for example
     * `merchant_defined_data` or camel case to match an external API that the
     * connector uses.
     */
    connectionOptions?: ConnectionOptions | null | undefined;
    /**
     * The 2-letter ISO code of the country of the transaction.
     *
     * @remarks
     * This is used to filter the payment services that is used to process the
     * transaction.
     *
     * If this value is provided for redirect requests and it's not `null`, it
     * must match the one specified for `country` in `payment_method`. Otherwise,
     * the value specified for `country` in `payment_method` will be assumed
     * implicitly.
     *
     */
    country?: string | null | undefined;
    /**
     * An external identifier that can be used to match the transaction against your own records.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added.
     *
     * @remarks
     * By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
     */
    giftCards?:
        | Array<TransactionGiftCardStoredRequest | TransactionGiftCardNewRequest>
        | null
        | undefined;
    /**
     * Defines the intent of this API call. This determines the desired initial
     *
     * @remarks
     * state of the transaction.
     *
     * * `authorize` - (Default) Optionally approves and then authorizes a
     * transaction but does not capture the funds.
     * * `capture` - Optionally approves and then authorizes and captures the
     * funds of the transaction.
     */
    intent?: TransactionRequestIntent | undefined;
    /**
     * Indicates whether the transaction represents a subsequent payment
     *
     * @remarks
     * coming from a setup recurring payment.
     * Please note there are some restrictions on how this flag may be
     * used.
     *
     * The flag can only be `false` (or not set) when the transaction meets
     * one of the following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `card_on_file`.
     *
     * The flag can only be set to `true` when the transaction meets one of the
     * following criteria:
     *
     * * It is not `merchant_initiated`.
     * * `payment_source` is set to `recurring` or `installment` and
     * `merchant_initiated` is set to `true`.
     * * `payment_source` is set to `card_on_file`.
     */
    isSubsequentPayment?: boolean | undefined;
    /**
     * Indicates whether the transaction was initiated by the merchant (true)
     *
     * @remarks
     * or customer (false).
     */
    merchantInitiated?: boolean | undefined;
    /**
     * Any additional information about the transaction that you would like to
     *
     * @remarks
     * store as key-value pairs. This data is passed to payment service
     * providers that support it.
     */
    metadata?: Record<string, string> | undefined;
    /**
     * The source of the transaction. Defaults to `ecommerce`.
     */
    paymentSource?: PaymentSource | undefined;
    /**
     * A scheme's transaction identifier to use in connecting a merchant
     *
     * @remarks
     * initiated transaction to a previous customer initiated transaction.
     *
     * If not provided, and a qualifying customer initiated transaction has been
     * previously made, then Gr4vy will populate this value with the identifier
     * returned for that transaction.
     *
     * e.g. the Visa Transaction Identifier, or Mastercard Trace ID.
     */
    previousSchemeTransactionId?: string | null | undefined;
    /**
     * The unique identifier of a set of shipping details stored for the buyer.
     *
     * @remarks
     *
     * If provided, the created transaction will include a copy of the details
     * at the point of transaction creation; i.e. it will not be affected by
     * later changes to the detail in the database.
     */
    shippingDetailsId?: string | null | undefined;
    statementDescriptor?: StatementDescriptor | null | undefined;
    /**
     * Whether or not to also try and store the payment method with us so that
     *
     * @remarks
     * it can be used again for future use. This is only supported for payment
     * methods that support this feature. There are also a few restrictions on
     * how the flag may be set:
     *
     * * The flag has to be set to `true` when the `payment_source` is set to
     * `recurring` or `installment`, and `merchant_initiated` is set to `false`.
     *
     * * The flag has to be set to `false` (or not set) when using a previously
     * vaulted payment method.
     */
    store?: boolean | undefined;
    /**
     * Pass through 3-D Secure data to support external 3-D Secure authorisation.
     *
     * @remarks
     * If using an external 3-D Secure provider, you should not pass
     * a `redirect_url` in the `payment_method` object for a transaction.
     */
    threeDSecureData?: ThreeDSecureDataV2 | ThreeDSecureDataV1 | undefined;
    /**
     * The unique identifier of an existing payment service. When
     *
     * @remarks
     * provided, the created transaction will be processed by the given
     * payment service and any routing rules will be skipped.
     */
    paymentServiceId?: string | null | undefined;
};

/** @internal */
export const TransactionCheckoutSessionRequestPaymentMethodMethod$: z.ZodNativeEnum<
    typeof TransactionCheckoutSessionRequestPaymentMethodMethod
> = z.nativeEnum(TransactionCheckoutSessionRequestPaymentMethodMethod);

/** @internal */
export namespace PaymentMethodCheckoutSession$ {
    export type Inbound = {
        method: TransactionCheckoutSessionRequestPaymentMethodMethod;
        id: string;
        external_identifier?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<PaymentMethodCheckoutSession, z.ZodTypeDef, Inbound> = z
        .object({
            method: TransactionCheckoutSessionRequestPaymentMethodMethod$,
            id: z.string(),
            external_identifier: z.nullable(z.string()).optional(),
            redirect_url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                id: v.id,
                ...(v.external_identifier === undefined
                    ? null
                    : { externalIdentifier: v.external_identifier }),
                ...(v.redirect_url === undefined ? null : { redirectUrl: v.redirect_url }),
            };
        });

    export type Outbound = {
        method: TransactionCheckoutSessionRequestPaymentMethodMethod;
        id: string;
        external_identifier?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodCheckoutSession> = z
        .object({
            method: TransactionCheckoutSessionRequestPaymentMethodMethod$,
            id: z.string(),
            externalIdentifier: z.nullable(z.string()).optional(),
            redirectUrl: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                id: v.id,
                ...(v.externalIdentifier === undefined
                    ? null
                    : { external_identifier: v.externalIdentifier }),
                ...(v.redirectUrl === undefined ? null : { redirect_url: v.redirectUrl }),
            };
        });
}

/** @internal */
export const GooglePayRequestPaymentMethodMethod$: z.ZodNativeEnum<
    typeof GooglePayRequestPaymentMethodMethod
> = z.nativeEnum(GooglePayRequestPaymentMethodMethod);

/** @internal */
export namespace AssuranceDetails$ {
    export type Inbound = {
        account_verified?: boolean | null | undefined;
        card_holder_authenticated?: boolean | null | undefined;
    };

    export const inboundSchema: z.ZodType<AssuranceDetails, z.ZodTypeDef, Inbound> = z
        .object({
            account_verified: z.nullable(z.boolean()).optional(),
            card_holder_authenticated: z.nullable(z.boolean()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.account_verified === undefined
                    ? null
                    : { accountVerified: v.account_verified }),
                ...(v.card_holder_authenticated === undefined
                    ? null
                    : { cardHolderAuthenticated: v.card_holder_authenticated }),
            };
        });

    export type Outbound = {
        account_verified?: boolean | null | undefined;
        card_holder_authenticated?: boolean | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AssuranceDetails> = z
        .object({
            accountVerified: z.nullable(z.boolean()).optional(),
            cardHolderAuthenticated: z.nullable(z.boolean()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.accountVerified === undefined
                    ? null
                    : { account_verified: v.accountVerified }),
                ...(v.cardHolderAuthenticated === undefined
                    ? null
                    : { card_holder_authenticated: v.cardHolderAuthenticated }),
            };
        });
}

/** @internal */
export namespace GooglePayPaymentMethodRequest$ {
    export type Inbound = {
        method: GooglePayRequestPaymentMethodMethod;
        token: string;
        assurance_details?: AssuranceDetails$.Inbound | null | undefined;
        card_holder_name?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<GooglePayPaymentMethodRequest, z.ZodTypeDef, Inbound> = z
        .object({
            method: GooglePayRequestPaymentMethodMethod$,
            token: z.string(),
            assurance_details: z.nullable(z.lazy(() => AssuranceDetails$.inboundSchema)).optional(),
            card_holder_name: z.nullable(z.string()).optional(),
            redirect_url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                token: v.token,
                ...(v.assurance_details === undefined
                    ? null
                    : { assuranceDetails: v.assurance_details }),
                ...(v.card_holder_name === undefined
                    ? null
                    : { cardHolderName: v.card_holder_name }),
                ...(v.redirect_url === undefined ? null : { redirectUrl: v.redirect_url }),
            };
        });

    export type Outbound = {
        method: GooglePayRequestPaymentMethodMethod;
        token: string;
        assurance_details?: AssuranceDetails$.Outbound | null | undefined;
        card_holder_name?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, GooglePayPaymentMethodRequest> =
        z
            .object({
                method: GooglePayRequestPaymentMethodMethod$,
                token: z.string(),
                assuranceDetails: z
                    .nullable(z.lazy(() => AssuranceDetails$.outboundSchema))
                    .optional(),
                cardHolderName: z.nullable(z.string()).optional(),
                redirectUrl: z.nullable(z.string()).optional(),
            })
            .transform((v) => {
                return {
                    method: v.method,
                    token: v.token,
                    ...(v.assuranceDetails === undefined
                        ? null
                        : { assurance_details: v.assuranceDetails }),
                    ...(v.cardHolderName === undefined
                        ? null
                        : { card_holder_name: v.cardHolderName }),
                    ...(v.redirectUrl === undefined ? null : { redirect_url: v.redirectUrl }),
                };
            });
}

/** @internal */
export const ApplePayRequestPaymentMethodMethod$: z.ZodNativeEnum<
    typeof ApplePayRequestPaymentMethodMethod
> = z.nativeEnum(ApplePayRequestPaymentMethodMethod);

/** @internal */
export namespace Token$ {
    export type Inbound = {};

    export const inboundSchema: z.ZodType<Token, z.ZodTypeDef, Inbound> = z.object({});

    export type Outbound = {};

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Token> = z.object({});
}

/** @internal */
export namespace ApplePayPaymentMethodRequest$ {
    export type Inbound = {
        method: ApplePayRequestPaymentMethodMethod;
        token: Token$.Inbound;
    };

    export const inboundSchema: z.ZodType<ApplePayPaymentMethodRequest, z.ZodTypeDef, Inbound> = z
        .object({
            method: ApplePayRequestPaymentMethodMethod$,
            token: z.lazy(() => Token$.inboundSchema),
        })
        .transform((v) => {
            return {
                method: v.method,
                token: v.token,
            };
        });

    export type Outbound = {
        method: ApplePayRequestPaymentMethodMethod;
        token: Token$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ApplePayPaymentMethodRequest> = z
        .object({
            method: ApplePayRequestPaymentMethodMethod$,
            token: z.lazy(() => Token$.outboundSchema),
        })
        .transform((v) => {
            return {
                method: v.method,
                token: v.token,
            };
        });
}

/** @internal */
export const TokenizedRequestPaymentMethodMethod$: z.ZodNativeEnum<
    typeof TokenizedRequestPaymentMethodMethod
> = z.nativeEnum(TokenizedRequestPaymentMethodMethod);

/** @internal */
export namespace StoredPaymentMethodRequest$ {
    export type Inbound = {
        method: TokenizedRequestPaymentMethodMethod;
        id: string;
        redirect_url?: string | undefined;
        security_code?: string | undefined;
    };

    export const inboundSchema: z.ZodType<StoredPaymentMethodRequest, z.ZodTypeDef, Inbound> = z
        .object({
            method: TokenizedRequestPaymentMethodMethod$,
            id: z.string(),
            redirect_url: z.string().optional(),
            security_code: z.string().optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                id: v.id,
                ...(v.redirect_url === undefined ? null : { redirectUrl: v.redirect_url }),
                ...(v.security_code === undefined ? null : { securityCode: v.security_code }),
            };
        });

    export type Outbound = {
        method: TokenizedRequestPaymentMethodMethod;
        id: string;
        redirect_url?: string | undefined;
        security_code?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StoredPaymentMethodRequest> = z
        .object({
            method: TokenizedRequestPaymentMethodMethod$,
            id: z.string(),
            redirectUrl: z.string().optional(),
            securityCode: z.string().optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                id: v.id,
                ...(v.redirectUrl === undefined ? null : { redirect_url: v.redirectUrl }),
                ...(v.securityCode === undefined ? null : { security_code: v.securityCode }),
            };
        });
}

/** @internal */
export const TransactionRedirectRequestPaymentMethodMethod$: z.ZodNativeEnum<
    typeof TransactionRedirectRequestPaymentMethodMethod
> = z.nativeEnum(TransactionRedirectRequestPaymentMethodMethod);

/** @internal */
export namespace Redirect$ {
    export type Inbound = {
        method: TransactionRedirectRequestPaymentMethodMethod;
        redirect_url: string;
        currency: string;
        country: string;
        external_identifier?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<Redirect, z.ZodTypeDef, Inbound> = z
        .object({
            method: TransactionRedirectRequestPaymentMethodMethod$,
            redirect_url: z.string(),
            currency: z.string(),
            country: z.string(),
            external_identifier: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                redirectUrl: v.redirect_url,
                currency: v.currency,
                country: v.country,
                ...(v.external_identifier === undefined
                    ? null
                    : { externalIdentifier: v.external_identifier }),
            };
        });

    export type Outbound = {
        method: TransactionRedirectRequestPaymentMethodMethod;
        redirect_url: string;
        currency: string;
        country: string;
        external_identifier?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Redirect> = z
        .object({
            method: TransactionRedirectRequestPaymentMethodMethod$,
            redirectUrl: z.string(),
            currency: z.string(),
            country: z.string(),
            externalIdentifier: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                redirect_url: v.redirectUrl,
                currency: v.currency,
                country: v.country,
                ...(v.externalIdentifier === undefined
                    ? null
                    : { external_identifier: v.externalIdentifier }),
            };
        });
}

/** @internal */
export const TransactionCardRequestPaymentMethodMethod$: z.ZodNativeEnum<
    typeof TransactionCardRequestPaymentMethodMethod
> = z.nativeEnum(TransactionCardRequestPaymentMethodMethod);

/** @internal */
export namespace PaymentMethodCard$ {
    export type Inbound = {
        method: TransactionCardRequestPaymentMethodMethod;
        number: string;
        expiration_date: string;
        security_code: string;
        external_identifier?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<PaymentMethodCard, z.ZodTypeDef, Inbound> = z
        .object({
            method: TransactionCardRequestPaymentMethodMethod$,
            number: z.string(),
            expiration_date: z.string(),
            security_code: z.string(),
            external_identifier: z.nullable(z.string()).optional(),
            redirect_url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                number: v.number,
                expirationDate: v.expiration_date,
                securityCode: v.security_code,
                ...(v.external_identifier === undefined
                    ? null
                    : { externalIdentifier: v.external_identifier }),
                ...(v.redirect_url === undefined ? null : { redirectUrl: v.redirect_url }),
            };
        });

    export type Outbound = {
        method: TransactionCardRequestPaymentMethodMethod;
        number: string;
        expiration_date: string;
        security_code: string;
        external_identifier?: string | null | undefined;
        redirect_url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodCard> = z
        .object({
            method: TransactionCardRequestPaymentMethodMethod$,
            number: z.string(),
            expirationDate: z.string(),
            securityCode: z.string(),
            externalIdentifier: z.nullable(z.string()).optional(),
            redirectUrl: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                method: v.method,
                number: v.number,
                expiration_date: v.expirationDate,
                security_code: v.securityCode,
                ...(v.externalIdentifier === undefined
                    ? null
                    : { external_identifier: v.externalIdentifier }),
                ...(v.redirectUrl === undefined ? null : { redirect_url: v.redirectUrl }),
            };
        });
}

/** @internal */
export namespace TransactionRequestPaymentMethod$ {
    export type Inbound =
        | ApplePayPaymentMethodRequest$.Inbound
        | StoredPaymentMethodRequest$.Inbound
        | PaymentMethodCheckoutSession$.Inbound
        | Redirect$.Inbound
        | GooglePayPaymentMethodRequest$.Inbound
        | PaymentMethodCard$.Inbound;

    export type Outbound =
        | ApplePayPaymentMethodRequest$.Outbound
        | StoredPaymentMethodRequest$.Outbound
        | PaymentMethodCheckoutSession$.Outbound
        | Redirect$.Outbound
        | GooglePayPaymentMethodRequest$.Outbound
        | PaymentMethodCard$.Outbound;
    export const inboundSchema: z.ZodType<TransactionRequestPaymentMethod, z.ZodTypeDef, Inbound> =
        z.union([
            z.lazy(() => ApplePayPaymentMethodRequest$.inboundSchema),
            z.lazy(() => StoredPaymentMethodRequest$.inboundSchema),
            z.lazy(() => PaymentMethodCheckoutSession$.inboundSchema),
            z.lazy(() => Redirect$.inboundSchema),
            z.lazy(() => GooglePayPaymentMethodRequest$.inboundSchema),
            z.lazy(() => PaymentMethodCard$.inboundSchema),
        ]);
    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        TransactionRequestPaymentMethod
    > = z.union([
        z.lazy(() => ApplePayPaymentMethodRequest$.outboundSchema),
        z.lazy(() => StoredPaymentMethodRequest$.outboundSchema),
        z.lazy(() => PaymentMethodCheckoutSession$.outboundSchema),
        z.lazy(() => Redirect$.outboundSchema),
        z.lazy(() => GooglePayPaymentMethodRequest$.outboundSchema),
        z.lazy(() => PaymentMethodCard$.outboundSchema),
    ]);
}

/** @internal */
export const UserDevice$: z.ZodNativeEnum<typeof UserDevice> = z.nativeEnum(UserDevice);

/** @internal */
export namespace BrowserInfo$ {
    export type Inbound = {
        java_enabled: boolean;
        javascript_enabled: boolean;
        language: string;
        color_depth: number;
        screen_height: number;
        screen_width: number;
        time_zone_offset: number;
        user_device: UserDevice;
        user_agent: string;
        accept_header?: string | undefined;
    };

    export const inboundSchema: z.ZodType<BrowserInfo, z.ZodTypeDef, Inbound> = z
        .object({
            java_enabled: z.boolean(),
            javascript_enabled: z.boolean(),
            language: z.string(),
            color_depth: z.number(),
            screen_height: z.number(),
            screen_width: z.number(),
            time_zone_offset: z.number(),
            user_device: UserDevice$,
            user_agent: z.string(),
            accept_header: z.string().optional(),
        })
        .transform((v) => {
            return {
                javaEnabled: v.java_enabled,
                javascriptEnabled: v.javascript_enabled,
                language: v.language,
                colorDepth: v.color_depth,
                screenHeight: v.screen_height,
                screenWidth: v.screen_width,
                timeZoneOffset: v.time_zone_offset,
                userDevice: v.user_device,
                userAgent: v.user_agent,
                ...(v.accept_header === undefined ? null : { acceptHeader: v.accept_header }),
            };
        });

    export type Outbound = {
        java_enabled: boolean;
        javascript_enabled: boolean;
        language: string;
        color_depth: number;
        screen_height: number;
        screen_width: number;
        time_zone_offset: number;
        user_device: UserDevice;
        user_agent: string;
        accept_header?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BrowserInfo> = z
        .object({
            javaEnabled: z.boolean(),
            javascriptEnabled: z.boolean(),
            language: z.string(),
            colorDepth: z.number(),
            screenHeight: z.number(),
            screenWidth: z.number(),
            timeZoneOffset: z.number(),
            userDevice: UserDevice$,
            userAgent: z.string(),
            acceptHeader: z.string().optional(),
        })
        .transform((v) => {
            return {
                java_enabled: v.javaEnabled,
                javascript_enabled: v.javascriptEnabled,
                language: v.language,
                color_depth: v.colorDepth,
                screen_height: v.screenHeight,
                screen_width: v.screenWidth,
                time_zone_offset: v.timeZoneOffset,
                user_device: v.userDevice,
                user_agent: v.userAgent,
                ...(v.acceptHeader === undefined ? null : { accept_header: v.acceptHeader }),
            };
        });
}

/** @internal */
export namespace CybersourceCard$ {
    export type Inbound = {
        meta_key_merchant_id?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<CybersourceCard, z.ZodTypeDef, Inbound> = z
        .object({
            meta_key_merchant_id: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.meta_key_merchant_id === undefined
                    ? null
                    : { metaKeyMerchantId: v.meta_key_merchant_id }),
            };
        });

    export type Outbound = {
        meta_key_merchant_id?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CybersourceCard> = z
        .object({
            metaKeyMerchantId: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.metaKeyMerchantId === undefined
                    ? null
                    : { meta_key_merchant_id: v.metaKeyMerchantId }),
            };
        });
}

/** @internal */
export namespace CybersourceAntiFraud$ {
    export type Inbound = {
        meta_key_merchant_id?: string | null | undefined;
        merchant_defined_data?: Record<string, string> | undefined;
    };

    export const inboundSchema: z.ZodType<CybersourceAntiFraud, z.ZodTypeDef, Inbound> = z
        .object({
            meta_key_merchant_id: z.nullable(z.string()).optional(),
            merchant_defined_data: z.record(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.meta_key_merchant_id === undefined
                    ? null
                    : { metaKeyMerchantId: v.meta_key_merchant_id }),
                ...(v.merchant_defined_data === undefined
                    ? null
                    : { merchantDefinedData: v.merchant_defined_data }),
            };
        });

    export type Outbound = {
        meta_key_merchant_id?: string | null | undefined;
        merchant_defined_data?: Record<string, string> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CybersourceAntiFraud> = z
        .object({
            metaKeyMerchantId: z.nullable(z.string()).optional(),
            merchantDefinedData: z.record(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.metaKeyMerchantId === undefined
                    ? null
                    : { meta_key_merchant_id: v.metaKeyMerchantId }),
                ...(v.merchantDefinedData === undefined
                    ? null
                    : { merchant_defined_data: v.merchantDefinedData }),
            };
        });
}

/** @internal */
export const DeliveryType$: z.ZodNativeEnum<typeof DeliveryType> = z.nativeEnum(DeliveryType);

/** @internal */
export const TransactionRequestType$: z.ZodNativeEnum<typeof TransactionRequestType> =
    z.nativeEnum(TransactionRequestType);

/** @internal */
export namespace BasicItemData$ {
    export type Inbound = {
        type?: TransactionRequestType | undefined;
    };

    export const inboundSchema: z.ZodType<BasicItemData, z.ZodTypeDef, Inbound> = z
        .object({
            type: TransactionRequestType$.optional(),
        })
        .transform((v) => {
            return {
                ...(v.type === undefined ? null : { type: v.type }),
            };
        });

    export type Outbound = {
        type?: TransactionRequestType | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BasicItemData> = z
        .object({
            type: TransactionRequestType$.optional(),
        })
        .transform((v) => {
            return {
                ...(v.type === undefined ? null : { type: v.type }),
            };
        });
}

/** @internal */
export const TransactionRequestDeliveryType$: z.ZodNativeEnum<
    typeof TransactionRequestDeliveryType
> = z.nativeEnum(TransactionRequestDeliveryType);

/** @internal */
export namespace DeliveryDetails$ {
    export type Inbound = {
        delivery_type?: TransactionRequestDeliveryType | null | undefined;
        delivery_method?: string | undefined;
    };

    export const inboundSchema: z.ZodType<DeliveryDetails, z.ZodTypeDef, Inbound> = z
        .object({
            delivery_type: z.nullable(TransactionRequestDeliveryType$).optional(),
            delivery_method: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.delivery_type === undefined ? null : { deliveryType: v.delivery_type }),
                ...(v.delivery_method === undefined ? null : { deliveryMethod: v.delivery_method }),
            };
        });

    export type Outbound = {
        delivery_type?: TransactionRequestDeliveryType | null | undefined;
        delivery_method?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, DeliveryDetails> = z
        .object({
            deliveryType: z.nullable(TransactionRequestDeliveryType$).optional(),
            deliveryMethod: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.deliveryType === undefined ? null : { delivery_type: v.deliveryType }),
                ...(v.deliveryMethod === undefined ? null : { delivery_method: v.deliveryMethod }),
            };
        });
}

/** @internal */
export namespace PersonalDetails$ {
    export type Inbound = {
        first_name?: string | undefined;
        last_name?: string | undefined;
        email?: string | undefined;
    };

    export const inboundSchema: z.ZodType<PersonalDetails, z.ZodTypeDef, Inbound> = z
        .object({
            first_name: z.string().optional(),
            last_name: z.string().optional(),
            email: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.first_name === undefined ? null : { firstName: v.first_name }),
                ...(v.last_name === undefined ? null : { lastName: v.last_name }),
                ...(v.email === undefined ? null : { email: v.email }),
            };
        });

    export type Outbound = {
        first_name?: string | undefined;
        last_name?: string | undefined;
        email?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PersonalDetails> = z
        .object({
            firstName: z.string().optional(),
            lastName: z.string().optional(),
            email: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.firstName === undefined ? null : { first_name: v.firstName }),
                ...(v.lastName === undefined ? null : { last_name: v.lastName }),
                ...(v.email === undefined ? null : { email: v.email }),
            };
        });
}

/** @internal */
export namespace TransactionRequestAddress$ {
    export type Inbound = {
        country: string;
        address1?: string | null | undefined;
        address2?: string | null | undefined;
        zip?: string | null | undefined;
        region?: string | null | undefined;
        company?: string | null | undefined;
        city?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<TransactionRequestAddress, z.ZodTypeDef, Inbound> = z
        .object({
            country: z.string(),
            address1: z.nullable(z.string()).optional(),
            address2: z.nullable(z.string()).optional(),
            zip: z.nullable(z.string()).optional(),
            region: z.nullable(z.string()).optional(),
            company: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                country: v.country,
                ...(v.address1 === undefined ? null : { address1: v.address1 }),
                ...(v.address2 === undefined ? null : { address2: v.address2 }),
                ...(v.zip === undefined ? null : { zip: v.zip }),
                ...(v.region === undefined ? null : { region: v.region }),
                ...(v.company === undefined ? null : { company: v.company }),
                ...(v.city === undefined ? null : { city: v.city }),
            };
        });

    export type Outbound = {
        country: string;
        address1?: string | null | undefined;
        address2?: string | null | undefined;
        zip?: string | null | undefined;
        region?: string | null | undefined;
        company?: string | null | undefined;
        city?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionRequestAddress> = z
        .object({
            country: z.string(),
            address1: z.nullable(z.string()).optional(),
            address2: z.nullable(z.string()).optional(),
            zip: z.nullable(z.string()).optional(),
            region: z.nullable(z.string()).optional(),
            company: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                country: v.country,
                ...(v.address1 === undefined ? null : { address1: v.address1 }),
                ...(v.address2 === undefined ? null : { address2: v.address2 }),
                ...(v.zip === undefined ? null : { zip: v.zip }),
                ...(v.region === undefined ? null : { region: v.region }),
                ...(v.company === undefined ? null : { company: v.company }),
                ...(v.city === undefined ? null : { city: v.city }),
            };
        });
}

/** @internal */
export namespace Phone$ {
    export type Inbound = {
        phone: string;
    };

    export const inboundSchema: z.ZodType<Phone, z.ZodTypeDef, Inbound> = z
        .object({
            phone: z.string(),
        })
        .transform((v) => {
            return {
                phone: v.phone,
            };
        });

    export type Outbound = {
        phone: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Phone> = z
        .object({
            phone: z.string(),
        })
        .transform((v) => {
            return {
                phone: v.phone,
            };
        });
}

/** @internal */
export namespace Comments$ {
    export type Inbound = {
        user_comments_to_merchant?: string | null | undefined;
        message_to_beneficiary?: string | null | undefined;
        merchant_comments?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<Comments, z.ZodTypeDef, Inbound> = z
        .object({
            user_comments_to_merchant: z.nullable(z.string()).optional(),
            message_to_beneficiary: z.nullable(z.string()).optional(),
            merchant_comments: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.user_comments_to_merchant === undefined
                    ? null
                    : { userCommentsToMerchant: v.user_comments_to_merchant }),
                ...(v.message_to_beneficiary === undefined
                    ? null
                    : { messageToBeneficiary: v.message_to_beneficiary }),
                ...(v.merchant_comments === undefined
                    ? null
                    : { merchantComments: v.merchant_comments }),
            };
        });

    export type Outbound = {
        user_comments_to_merchant?: string | null | undefined;
        message_to_beneficiary?: string | null | undefined;
        merchant_comments?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Comments> = z
        .object({
            userCommentsToMerchant: z.nullable(z.string()).optional(),
            messageToBeneficiary: z.nullable(z.string()).optional(),
            merchantComments: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.userCommentsToMerchant === undefined
                    ? null
                    : { user_comments_to_merchant: v.userCommentsToMerchant }),
                ...(v.messageToBeneficiary === undefined
                    ? null
                    : { message_to_beneficiary: v.messageToBeneficiary }),
                ...(v.merchantComments === undefined
                    ? null
                    : { merchant_comments: v.merchantComments }),
            };
        });
}

/** @internal */
export namespace Beneficiaries$ {
    export type Inbound = {
        personal_details: PersonalDetails$.Inbound;
        address?: TransactionRequestAddress$.Inbound | null | undefined;
        phone?: Array<Phone$.Inbound> | undefined;
        comments?: Comments$.Inbound | null | undefined;
    };

    export const inboundSchema: z.ZodType<Beneficiaries, z.ZodTypeDef, Inbound> = z
        .object({
            personal_details: z.lazy(() => PersonalDetails$.inboundSchema),
            address: z.nullable(z.lazy(() => TransactionRequestAddress$.inboundSchema)).optional(),
            phone: z.array(z.lazy(() => Phone$.inboundSchema)).optional(),
            comments: z.nullable(z.lazy(() => Comments$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                personalDetails: v.personal_details,
                ...(v.address === undefined ? null : { address: v.address }),
                ...(v.phone === undefined ? null : { phone: v.phone }),
                ...(v.comments === undefined ? null : { comments: v.comments }),
            };
        });

    export type Outbound = {
        personal_details: PersonalDetails$.Outbound;
        address?: TransactionRequestAddress$.Outbound | null | undefined;
        phone?: Array<Phone$.Outbound> | undefined;
        comments?: Comments$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Beneficiaries> = z
        .object({
            personalDetails: z.lazy(() => PersonalDetails$.outboundSchema),
            address: z.nullable(z.lazy(() => TransactionRequestAddress$.outboundSchema)).optional(),
            phone: z.array(z.lazy(() => Phone$.outboundSchema)).optional(),
            comments: z.nullable(z.lazy(() => Comments$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                personal_details: v.personalDetails,
                ...(v.address === undefined ? null : { address: v.address }),
                ...(v.phone === undefined ? null : { phone: v.phone }),
                ...(v.comments === undefined ? null : { comments: v.comments }),
            };
        });
}

/** @internal */
export namespace CartItems$ {
    export type Inbound = {
        basic_item_data?: BasicItemData$.Inbound | undefined;
        delivery_details?: DeliveryDetails$.Inbound | undefined;
        beneficiaries?: Array<Beneficiaries$.Inbound> | undefined;
    };

    export const inboundSchema: z.ZodType<CartItems, z.ZodTypeDef, Inbound> = z
        .object({
            basic_item_data: z.lazy(() => BasicItemData$.inboundSchema).optional(),
            delivery_details: z.lazy(() => DeliveryDetails$.inboundSchema).optional(),
            beneficiaries: z.array(z.lazy(() => Beneficiaries$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.basic_item_data === undefined ? null : { basicItemData: v.basic_item_data }),
                ...(v.delivery_details === undefined
                    ? null
                    : { deliveryDetails: v.delivery_details }),
                ...(v.beneficiaries === undefined ? null : { beneficiaries: v.beneficiaries }),
            };
        });

    export type Outbound = {
        basic_item_data?: BasicItemData$.Outbound | undefined;
        delivery_details?: DeliveryDetails$.Outbound | undefined;
        beneficiaries?: Array<Beneficiaries$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CartItems> = z
        .object({
            basicItemData: z.lazy(() => BasicItemData$.outboundSchema).optional(),
            deliveryDetails: z.lazy(() => DeliveryDetails$.outboundSchema).optional(),
            beneficiaries: z.array(z.lazy(() => Beneficiaries$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.basicItemData === undefined ? null : { basic_item_data: v.basicItemData }),
                ...(v.deliveryDetails === undefined
                    ? null
                    : { delivery_details: v.deliveryDetails }),
                ...(v.beneficiaries === undefined ? null : { beneficiaries: v.beneficiaries }),
            };
        });
}

/** @internal */
export namespace CouponDiscountAmount$ {
    export type Inbound = {
        amount_usd?: string | undefined;
        amount_local_currency?: string | undefined;
        currency?: string | undefined;
    };

    export const inboundSchema: z.ZodType<CouponDiscountAmount, z.ZodTypeDef, Inbound> = z
        .object({
            amount_usd: z.string().optional(),
            amount_local_currency: z.string().optional(),
            currency: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.amount_usd === undefined ? null : { amountUsd: v.amount_usd }),
                ...(v.amount_local_currency === undefined
                    ? null
                    : { amountLocalCurrency: v.amount_local_currency }),
                ...(v.currency === undefined ? null : { currency: v.currency }),
            };
        });

    export type Outbound = {
        amount_usd?: string | undefined;
        amount_local_currency?: string | undefined;
        currency?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CouponDiscountAmount> = z
        .object({
            amountUsd: z.string().optional(),
            amountLocalCurrency: z.string().optional(),
            currency: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.amountUsd === undefined ? null : { amount_usd: v.amountUsd }),
                ...(v.amountLocalCurrency === undefined
                    ? null
                    : { amount_local_currency: v.amountLocalCurrency }),
                ...(v.currency === undefined ? null : { currency: v.currency }),
            };
        });
}

/** @internal */
export namespace TotalDiscount$ {
    export type Inbound = {
        coupon_code_used?: string | undefined;
        discount_type: string;
        coupon_discount_amount?: CouponDiscountAmount$.Inbound | null | undefined;
        coupon_discount_percent?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<TotalDiscount, z.ZodTypeDef, Inbound> = z
        .object({
            coupon_code_used: z.string().optional(),
            discount_type: z.string(),
            coupon_discount_amount: z
                .nullable(z.lazy(() => CouponDiscountAmount$.inboundSchema))
                .optional(),
            coupon_discount_percent: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.coupon_code_used === undefined
                    ? null
                    : { couponCodeUsed: v.coupon_code_used }),
                discountType: v.discount_type,
                ...(v.coupon_discount_amount === undefined
                    ? null
                    : { couponDiscountAmount: v.coupon_discount_amount }),
                ...(v.coupon_discount_percent === undefined
                    ? null
                    : { couponDiscountPercent: v.coupon_discount_percent }),
            };
        });

    export type Outbound = {
        coupon_code_used?: string | undefined;
        discount_type: string;
        coupon_discount_amount?: CouponDiscountAmount$.Outbound | null | undefined;
        coupon_discount_percent?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TotalDiscount> = z
        .object({
            couponCodeUsed: z.string().optional(),
            discountType: z.string(),
            couponDiscountAmount: z
                .nullable(z.lazy(() => CouponDiscountAmount$.outboundSchema))
                .optional(),
            couponDiscountPercent: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.couponCodeUsed === undefined ? null : { coupon_code_used: v.couponCodeUsed }),
                discount_type: v.discountType,
                ...(v.couponDiscountAmount === undefined
                    ? null
                    : { coupon_discount_amount: v.couponDiscountAmount }),
                ...(v.couponDiscountPercent === undefined
                    ? null
                    : { coupon_discount_percent: v.couponDiscountPercent }),
            };
        });
}

/** @internal */
export namespace ForterAntiFraud$ {
    export type Inbound = {
        delivery_type?: DeliveryType | null | undefined;
        delivery_method?: string | null | undefined;
        is_guest_buyer?: boolean | undefined;
        cart_items?: Array<CartItems$.Inbound> | undefined;
        total_discount?: TotalDiscount$.Inbound | null | undefined;
    };

    export const inboundSchema: z.ZodType<ForterAntiFraud, z.ZodTypeDef, Inbound> = z
        .object({
            delivery_type: z.nullable(DeliveryType$).optional(),
            delivery_method: z.nullable(z.string()).optional(),
            is_guest_buyer: z.boolean().default(false),
            cart_items: z.array(z.lazy(() => CartItems$.inboundSchema)).optional(),
            total_discount: z.nullable(z.lazy(() => TotalDiscount$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.delivery_type === undefined ? null : { deliveryType: v.delivery_type }),
                ...(v.delivery_method === undefined ? null : { deliveryMethod: v.delivery_method }),
                isGuestBuyer: v.is_guest_buyer,
                ...(v.cart_items === undefined ? null : { cartItems: v.cart_items }),
                ...(v.total_discount === undefined ? null : { totalDiscount: v.total_discount }),
            };
        });

    export type Outbound = {
        delivery_type?: DeliveryType | null | undefined;
        delivery_method?: string | null | undefined;
        is_guest_buyer: boolean;
        cart_items?: Array<CartItems$.Outbound> | undefined;
        total_discount?: TotalDiscount$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ForterAntiFraud> = z
        .object({
            deliveryType: z.nullable(DeliveryType$).optional(),
            deliveryMethod: z.nullable(z.string()).optional(),
            isGuestBuyer: z.boolean().default(false),
            cartItems: z.array(z.lazy(() => CartItems$.outboundSchema)).optional(),
            totalDiscount: z.nullable(z.lazy(() => TotalDiscount$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.deliveryType === undefined ? null : { delivery_type: v.deliveryType }),
                ...(v.deliveryMethod === undefined ? null : { delivery_method: v.deliveryMethod }),
                is_guest_buyer: v.isGuestBuyer,
                ...(v.cartItems === undefined ? null : { cart_items: v.cartItems }),
                ...(v.totalDiscount === undefined ? null : { total_discount: v.totalDiscount }),
            };
        });
}

/** @internal */
export namespace AdyenCard$ {
    export type Inbound = {
        additionalData?: Record<string, string> | undefined;
    };

    export const inboundSchema: z.ZodType<AdyenCard, z.ZodTypeDef, Inbound> = z
        .object({
            additionalData: z.record(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.additionalData === undefined ? null : { additionalData: v.additionalData }),
            };
        });

    export type Outbound = {
        additionalData?: Record<string, string> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AdyenCard> = z
        .object({
            additionalData: z.record(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.additionalData === undefined ? null : { additionalData: v.additionalData }),
            };
        });
}

/** @internal */
export namespace AdditionalData$ {
    export type Inbound = {
        key?: string | undefined;
        value?: string | undefined;
    };

    export const inboundSchema: z.ZodType<AdditionalData, z.ZodTypeDef, Inbound> = z
        .object({
            key: z.string().optional(),
            value: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.key === undefined ? null : { key: v.key }),
                ...(v.value === undefined ? null : { value: v.value }),
            };
        });

    export type Outbound = {
        key?: string | undefined;
        value?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, AdditionalData> = z
        .object({
            key: z.string().optional(),
            value: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.key === undefined ? null : { key: v.key }),
                ...(v.value === undefined ? null : { value: v.value }),
            };
        });
}

/** @internal */
export namespace PaypalPaypal$ {
    export type Inbound = {
        additional_data?: Array<AdditionalData$.Inbound> | undefined;
    };

    export const inboundSchema: z.ZodType<PaypalPaypal, z.ZodTypeDef, Inbound> = z
        .object({
            additional_data: z.array(z.lazy(() => AdditionalData$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.additional_data === undefined ? null : { additionalData: v.additional_data }),
            };
        });

    export type Outbound = {
        additional_data?: Array<AdditionalData$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaypalPaypal> = z
        .object({
            additionalData: z.array(z.lazy(() => AdditionalData$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.additionalData === undefined ? null : { additional_data: v.additionalData }),
            };
        });
}

/** @internal */
export namespace TransactionRequestAdditionalData$ {
    export type Inbound = {
        key?: string | undefined;
        value?: string | undefined;
    };

    export const inboundSchema: z.ZodType<TransactionRequestAdditionalData, z.ZodTypeDef, Inbound> =
        z
            .object({
                key: z.string().optional(),
                value: z.string().optional(),
            })
            .transform((v) => {
                return {
                    ...(v.key === undefined ? null : { key: v.key }),
                    ...(v.value === undefined ? null : { value: v.value }),
                };
            });

    export type Outbound = {
        key?: string | undefined;
        value?: string | undefined;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        TransactionRequestAdditionalData
    > = z
        .object({
            key: z.string().optional(),
            value: z.string().optional(),
        })
        .transform((v) => {
            return {
                ...(v.key === undefined ? null : { key: v.key }),
                ...(v.value === undefined ? null : { value: v.value }),
            };
        });
}

/** @internal */
export namespace PaypalPaypalpaylater$ {
    export type Inbound = {
        additional_data?: Array<TransactionRequestAdditionalData$.Inbound> | undefined;
    };

    export const inboundSchema: z.ZodType<PaypalPaypalpaylater, z.ZodTypeDef, Inbound> = z
        .object({
            additional_data: z
                .array(z.lazy(() => TransactionRequestAdditionalData$.inboundSchema))
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.additional_data === undefined ? null : { additionalData: v.additional_data }),
            };
        });

    export type Outbound = {
        additional_data?: Array<TransactionRequestAdditionalData$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaypalPaypalpaylater> = z
        .object({
            additionalData: z
                .array(z.lazy(() => TransactionRequestAdditionalData$.outboundSchema))
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.additionalData === undefined ? null : { additional_data: v.additionalData }),
            };
        });
}

/** @internal */
export namespace StripeConnect$ {
    export type Inbound = {
        stripe_account?: string | null | undefined;
        application_fee_amount?: number | null | undefined;
    };

    export const inboundSchema: z.ZodType<StripeConnect, z.ZodTypeDef, Inbound> = z
        .object({
            stripe_account: z.nullable(z.string()).optional(),
            application_fee_amount: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.stripe_account === undefined ? null : { stripeAccount: v.stripe_account }),
                ...(v.application_fee_amount === undefined
                    ? null
                    : { applicationFeeAmount: v.application_fee_amount }),
            };
        });

    export type Outbound = {
        stripe_account?: string | null | undefined;
        application_fee_amount?: number | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StripeConnect> = z
        .object({
            stripeAccount: z.nullable(z.string()).optional(),
            applicationFeeAmount: z.nullable(z.number()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.stripeAccount === undefined ? null : { stripe_account: v.stripeAccount }),
                ...(v.applicationFeeAmount === undefined
                    ? null
                    : { application_fee_amount: v.applicationFeeAmount }),
            };
        });
}

/** @internal */
export namespace StripeCard$ {
    export type Inbound = {
        error_on_requires_action?: boolean | undefined;
        stripe_connect?: StripeConnect$.Inbound | null | undefined;
    };

    export const inboundSchema: z.ZodType<StripeCard, z.ZodTypeDef, Inbound> = z
        .object({
            error_on_requires_action: z.boolean().default(false),
            stripe_connect: z.nullable(z.lazy(() => StripeConnect$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                errorOnRequiresAction: v.error_on_requires_action,
                ...(v.stripe_connect === undefined ? null : { stripeConnect: v.stripe_connect }),
            };
        });

    export type Outbound = {
        error_on_requires_action: boolean;
        stripe_connect?: StripeConnect$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StripeCard> = z
        .object({
            errorOnRequiresAction: z.boolean().default(false),
            stripeConnect: z.nullable(z.lazy(() => StripeConnect$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                error_on_requires_action: v.errorOnRequiresAction,
                ...(v.stripeConnect === undefined ? null : { stripe_connect: v.stripeConnect }),
            };
        });
}

/** @internal */
export namespace ConnectionOptions$ {
    export type Inbound = {
        "cybersource-card"?: CybersourceCard$.Inbound | null | undefined;
        "cybersource-anti-fraud"?: CybersourceAntiFraud$.Inbound | null | undefined;
        "forter-anti-fraud"?: ForterAntiFraud$.Inbound | null | undefined;
        "adyen-card"?: AdyenCard$.Inbound | null | undefined;
        "paypal-paypal"?: PaypalPaypal$.Inbound | null | undefined;
        "paypal-paypalpaylater"?: PaypalPaypalpaylater$.Inbound | null | undefined;
        "stripe-card"?: StripeCard$.Inbound | null | undefined;
    };

    export const inboundSchema: z.ZodType<ConnectionOptions, z.ZodTypeDef, Inbound> = z
        .object({
            "cybersource-card": z.nullable(z.lazy(() => CybersourceCard$.inboundSchema)).optional(),
            "cybersource-anti-fraud": z
                .nullable(z.lazy(() => CybersourceAntiFraud$.inboundSchema))
                .optional(),
            "forter-anti-fraud": z
                .nullable(z.lazy(() => ForterAntiFraud$.inboundSchema))
                .optional(),
            "adyen-card": z.nullable(z.lazy(() => AdyenCard$.inboundSchema)).optional(),
            "paypal-paypal": z.nullable(z.lazy(() => PaypalPaypal$.inboundSchema)).optional(),
            "paypal-paypalpaylater": z
                .nullable(z.lazy(() => PaypalPaypalpaylater$.inboundSchema))
                .optional(),
            "stripe-card": z.nullable(z.lazy(() => StripeCard$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v["cybersource-card"] === undefined
                    ? null
                    : { cybersourceCard: v["cybersource-card"] }),
                ...(v["cybersource-anti-fraud"] === undefined
                    ? null
                    : { cybersourceAntiFraud: v["cybersource-anti-fraud"] }),
                ...(v["forter-anti-fraud"] === undefined
                    ? null
                    : { forterAntiFraud: v["forter-anti-fraud"] }),
                ...(v["adyen-card"] === undefined ? null : { adyenCard: v["adyen-card"] }),
                ...(v["paypal-paypal"] === undefined ? null : { paypalPaypal: v["paypal-paypal"] }),
                ...(v["paypal-paypalpaylater"] === undefined
                    ? null
                    : { paypalPaypalpaylater: v["paypal-paypalpaylater"] }),
                ...(v["stripe-card"] === undefined ? null : { stripeCard: v["stripe-card"] }),
            };
        });

    export type Outbound = {
        "cybersource-card"?: CybersourceCard$.Outbound | null | undefined;
        "cybersource-anti-fraud"?: CybersourceAntiFraud$.Outbound | null | undefined;
        "forter-anti-fraud"?: ForterAntiFraud$.Outbound | null | undefined;
        "adyen-card"?: AdyenCard$.Outbound | null | undefined;
        "paypal-paypal"?: PaypalPaypal$.Outbound | null | undefined;
        "paypal-paypalpaylater"?: PaypalPaypalpaylater$.Outbound | null | undefined;
        "stripe-card"?: StripeCard$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ConnectionOptions> = z
        .object({
            cybersourceCard: z.nullable(z.lazy(() => CybersourceCard$.outboundSchema)).optional(),
            cybersourceAntiFraud: z
                .nullable(z.lazy(() => CybersourceAntiFraud$.outboundSchema))
                .optional(),
            forterAntiFraud: z.nullable(z.lazy(() => ForterAntiFraud$.outboundSchema)).optional(),
            adyenCard: z.nullable(z.lazy(() => AdyenCard$.outboundSchema)).optional(),
            paypalPaypal: z.nullable(z.lazy(() => PaypalPaypal$.outboundSchema)).optional(),
            paypalPaypalpaylater: z
                .nullable(z.lazy(() => PaypalPaypalpaylater$.outboundSchema))
                .optional(),
            stripeCard: z.nullable(z.lazy(() => StripeCard$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                ...(v.cybersourceCard === undefined
                    ? null
                    : { "cybersource-card": v.cybersourceCard }),
                ...(v.cybersourceAntiFraud === undefined
                    ? null
                    : { "cybersource-anti-fraud": v.cybersourceAntiFraud }),
                ...(v.forterAntiFraud === undefined
                    ? null
                    : { "forter-anti-fraud": v.forterAntiFraud }),
                ...(v.adyenCard === undefined ? null : { "adyen-card": v.adyenCard }),
                ...(v.paypalPaypal === undefined ? null : { "paypal-paypal": v.paypalPaypal }),
                ...(v.paypalPaypalpaylater === undefined
                    ? null
                    : { "paypal-paypalpaylater": v.paypalPaypalpaylater }),
                ...(v.stripeCard === undefined ? null : { "stripe-card": v.stripeCard }),
            };
        });
}

/** @internal */
export namespace TransactionRequestGiftCards$ {
    export type Inbound =
        | TransactionGiftCardStoredRequest$.Inbound
        | TransactionGiftCardNewRequest$.Inbound;

    export type Outbound =
        | TransactionGiftCardStoredRequest$.Outbound
        | TransactionGiftCardNewRequest$.Outbound;
    export const inboundSchema: z.ZodType<TransactionRequestGiftCards, z.ZodTypeDef, Inbound> =
        z.union([
            TransactionGiftCardStoredRequest$.inboundSchema,
            TransactionGiftCardNewRequest$.inboundSchema,
        ]);
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionRequestGiftCards> =
        z.union([
            TransactionGiftCardStoredRequest$.outboundSchema,
            TransactionGiftCardNewRequest$.outboundSchema,
        ]);
}

/** @internal */
export const TransactionRequestIntent$: z.ZodNativeEnum<typeof TransactionRequestIntent> =
    z.nativeEnum(TransactionRequestIntent);

/** @internal */
export const PaymentSource$: z.ZodNativeEnum<typeof PaymentSource> = z.nativeEnum(PaymentSource);

/** @internal */
export namespace StatementDescriptor$ {
    export type Inbound = {
        name?: string | null | undefined;
        description?: string | null | undefined;
        city?: string | null | undefined;
        phone_number?: string | null | undefined;
        url?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<StatementDescriptor, z.ZodTypeDef, Inbound> = z
        .object({
            name: z.nullable(z.string()).optional(),
            description: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
            phone_number: z.nullable(z.string()).optional(),
            url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.description === undefined ? null : { description: v.description }),
                ...(v.city === undefined ? null : { city: v.city }),
                ...(v.phone_number === undefined ? null : { phoneNumber: v.phone_number }),
                ...(v.url === undefined ? null : { url: v.url }),
            };
        });

    export type Outbound = {
        name?: string | null | undefined;
        description?: string | null | undefined;
        city?: string | null | undefined;
        phone_number?: string | null | undefined;
        url?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, StatementDescriptor> = z
        .object({
            name: z.nullable(z.string()).optional(),
            description: z.nullable(z.string()).optional(),
            city: z.nullable(z.string()).optional(),
            phoneNumber: z.nullable(z.string()).optional(),
            url: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return {
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.description === undefined ? null : { description: v.description }),
                ...(v.city === undefined ? null : { city: v.city }),
                ...(v.phoneNumber === undefined ? null : { phone_number: v.phoneNumber }),
                ...(v.url === undefined ? null : { url: v.url }),
            };
        });
}

/** @internal */
export namespace ThreeDSecureData$ {
    export type Inbound = ThreeDSecureDataV2$.Inbound | ThreeDSecureDataV1$.Inbound;

    export type Outbound = ThreeDSecureDataV2$.Outbound | ThreeDSecureDataV1$.Outbound;
    export const inboundSchema: z.ZodType<ThreeDSecureData, z.ZodTypeDef, Inbound> = z.union([
        ThreeDSecureDataV2$.inboundSchema,
        ThreeDSecureDataV1$.inboundSchema,
    ]);
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ThreeDSecureData> = z.union([
        ThreeDSecureDataV2$.outboundSchema,
        ThreeDSecureDataV1$.outboundSchema,
    ]);
}

/** @internal */
export namespace TransactionRequest$ {
    export type Inbound = {
        amount: number;
        currency: string;
        payment_method?:
            | ApplePayPaymentMethodRequest$.Inbound
            | StoredPaymentMethodRequest$.Inbound
            | PaymentMethodCheckoutSession$.Inbound
            | Redirect$.Inbound
            | GooglePayPaymentMethodRequest$.Inbound
            | PaymentMethodCard$.Inbound
            | null
            | undefined;
        anti_fraud_fingerprint?: string | null | undefined;
        async_capture?: boolean | undefined;
        browser_info?: BrowserInfo$.Inbound | null | undefined;
        buyer_external_identifier?: string | undefined;
        buyer_id?: string | undefined;
        cart_items?: Array<CartItem$.Inbound> | undefined;
        connection_options?: ConnectionOptions$.Inbound | null | undefined;
        country?: string | null | undefined;
        external_identifier?: string | null | undefined;
        gift_cards?:
            | Array<
                  TransactionGiftCardStoredRequest$.Inbound | TransactionGiftCardNewRequest$.Inbound
              >
            | null
            | undefined;
        intent?: TransactionRequestIntent | undefined;
        is_subsequent_payment?: boolean | undefined;
        merchant_initiated?: boolean | undefined;
        metadata?: Record<string, string> | undefined;
        payment_source?: PaymentSource | undefined;
        previous_scheme_transaction_id?: string | null | undefined;
        shipping_details_id?: string | null | undefined;
        statement_descriptor?: StatementDescriptor$.Inbound | null | undefined;
        store?: boolean | undefined;
        three_d_secure_data?: ThreeDSecureDataV2$.Inbound | ThreeDSecureDataV1$.Inbound | undefined;
        payment_service_id?: string | null | undefined;
    };

    export const inboundSchema: z.ZodType<TransactionRequest, z.ZodTypeDef, Inbound> = z
        .object({
            amount: z.number().int(),
            currency: z.string(),
            payment_method: z
                .nullable(
                    z.union([
                        z.lazy(() => ApplePayPaymentMethodRequest$.inboundSchema),
                        z.lazy(() => StoredPaymentMethodRequest$.inboundSchema),
                        z.lazy(() => PaymentMethodCheckoutSession$.inboundSchema),
                        z.lazy(() => Redirect$.inboundSchema),
                        z.lazy(() => GooglePayPaymentMethodRequest$.inboundSchema),
                        z.lazy(() => PaymentMethodCard$.inboundSchema),
                    ])
                )
                .optional(),
            anti_fraud_fingerprint: z.nullable(z.string()).default(null),
            async_capture: z.boolean().default(false),
            browser_info: z.nullable(z.lazy(() => BrowserInfo$.inboundSchema)).optional(),
            buyer_external_identifier: z.string().optional(),
            buyer_id: z.string().optional(),
            cart_items: z.array(CartItem$.inboundSchema).optional(),
            connection_options: z
                .nullable(z.lazy(() => ConnectionOptions$.inboundSchema))
                .optional(),
            country: z.nullable(z.string()).optional(),
            external_identifier: z.nullable(z.string()).optional(),
            gift_cards: z
                .nullable(
                    z.array(
                        z.union([
                            TransactionGiftCardStoredRequest$.inboundSchema,
                            TransactionGiftCardNewRequest$.inboundSchema,
                        ])
                    )
                )
                .optional(),
            intent: TransactionRequestIntent$.default(TransactionRequestIntent.Authorize),
            is_subsequent_payment: z.boolean().default(false),
            merchant_initiated: z.boolean().default(false),
            metadata: z.record(z.string()).optional(),
            payment_source: PaymentSource$.optional(),
            previous_scheme_transaction_id: z.nullable(z.string()).default(null),
            shipping_details_id: z.nullable(z.string()).default(null),
            statement_descriptor: z
                .nullable(z.lazy(() => StatementDescriptor$.inboundSchema))
                .optional(),
            store: z.boolean().default(false),
            three_d_secure_data: z
                .union([ThreeDSecureDataV2$.inboundSchema, ThreeDSecureDataV1$.inboundSchema])
                .optional(),
            payment_service_id: z.nullable(z.string()).default(null),
        })
        .transform((v) => {
            return {
                amount: v.amount,
                currency: v.currency,
                ...(v.payment_method === undefined ? null : { paymentMethod: v.payment_method }),
                antiFraudFingerprint: v.anti_fraud_fingerprint,
                asyncCapture: v.async_capture,
                ...(v.browser_info === undefined ? null : { browserInfo: v.browser_info }),
                ...(v.buyer_external_identifier === undefined
                    ? null
                    : { buyerExternalIdentifier: v.buyer_external_identifier }),
                ...(v.buyer_id === undefined ? null : { buyerId: v.buyer_id }),
                ...(v.cart_items === undefined ? null : { cartItems: v.cart_items }),
                ...(v.connection_options === undefined
                    ? null
                    : { connectionOptions: v.connection_options }),
                ...(v.country === undefined ? null : { country: v.country }),
                ...(v.external_identifier === undefined
                    ? null
                    : { externalIdentifier: v.external_identifier }),
                ...(v.gift_cards === undefined ? null : { giftCards: v.gift_cards }),
                intent: v.intent,
                isSubsequentPayment: v.is_subsequent_payment,
                merchantInitiated: v.merchant_initiated,
                ...(v.metadata === undefined ? null : { metadata: v.metadata }),
                ...(v.payment_source === undefined ? null : { paymentSource: v.payment_source }),
                previousSchemeTransactionId: v.previous_scheme_transaction_id,
                shippingDetailsId: v.shipping_details_id,
                ...(v.statement_descriptor === undefined
                    ? null
                    : { statementDescriptor: v.statement_descriptor }),
                store: v.store,
                ...(v.three_d_secure_data === undefined
                    ? null
                    : { threeDSecureData: v.three_d_secure_data }),
                paymentServiceId: v.payment_service_id,
            };
        });

    export type Outbound = {
        amount: number;
        currency: string;
        payment_method?:
            | ApplePayPaymentMethodRequest$.Outbound
            | StoredPaymentMethodRequest$.Outbound
            | PaymentMethodCheckoutSession$.Outbound
            | Redirect$.Outbound
            | GooglePayPaymentMethodRequest$.Outbound
            | PaymentMethodCard$.Outbound
            | null
            | undefined;
        anti_fraud_fingerprint: string | null;
        async_capture: boolean;
        browser_info?: BrowserInfo$.Outbound | null | undefined;
        buyer_external_identifier?: string | undefined;
        buyer_id?: string | undefined;
        cart_items?: Array<CartItem$.Outbound> | undefined;
        connection_options?: ConnectionOptions$.Outbound | null | undefined;
        country?: string | null | undefined;
        external_identifier?: string | null | undefined;
        gift_cards?:
            | Array<
                  | TransactionGiftCardStoredRequest$.Outbound
                  | TransactionGiftCardNewRequest$.Outbound
              >
            | null
            | undefined;
        intent: TransactionRequestIntent;
        is_subsequent_payment: boolean;
        merchant_initiated: boolean;
        metadata?: Record<string, string> | undefined;
        payment_source?: PaymentSource | undefined;
        previous_scheme_transaction_id: string | null;
        shipping_details_id: string | null;
        statement_descriptor?: StatementDescriptor$.Outbound | null | undefined;
        store: boolean;
        three_d_secure_data?:
            | ThreeDSecureDataV2$.Outbound
            | ThreeDSecureDataV1$.Outbound
            | undefined;
        payment_service_id: string | null;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TransactionRequest> = z
        .object({
            amount: z.number().int(),
            currency: z.string(),
            paymentMethod: z
                .nullable(
                    z.union([
                        z.lazy(() => ApplePayPaymentMethodRequest$.outboundSchema),
                        z.lazy(() => StoredPaymentMethodRequest$.outboundSchema),
                        z.lazy(() => PaymentMethodCheckoutSession$.outboundSchema),
                        z.lazy(() => Redirect$.outboundSchema),
                        z.lazy(() => GooglePayPaymentMethodRequest$.outboundSchema),
                        z.lazy(() => PaymentMethodCard$.outboundSchema),
                    ])
                )
                .optional(),
            antiFraudFingerprint: z.nullable(z.string()).default(null),
            asyncCapture: z.boolean().default(false),
            browserInfo: z.nullable(z.lazy(() => BrowserInfo$.outboundSchema)).optional(),
            buyerExternalIdentifier: z.string().optional(),
            buyerId: z.string().optional(),
            cartItems: z.array(CartItem$.outboundSchema).optional(),
            connectionOptions: z
                .nullable(z.lazy(() => ConnectionOptions$.outboundSchema))
                .optional(),
            country: z.nullable(z.string()).optional(),
            externalIdentifier: z.nullable(z.string()).optional(),
            giftCards: z
                .nullable(
                    z.array(
                        z.union([
                            TransactionGiftCardStoredRequest$.outboundSchema,
                            TransactionGiftCardNewRequest$.outboundSchema,
                        ])
                    )
                )
                .optional(),
            intent: TransactionRequestIntent$.default(TransactionRequestIntent.Authorize),
            isSubsequentPayment: z.boolean().default(false),
            merchantInitiated: z.boolean().default(false),
            metadata: z.record(z.string()).optional(),
            paymentSource: PaymentSource$.optional(),
            previousSchemeTransactionId: z.nullable(z.string()).default(null),
            shippingDetailsId: z.nullable(z.string()).default(null),
            statementDescriptor: z
                .nullable(z.lazy(() => StatementDescriptor$.outboundSchema))
                .optional(),
            store: z.boolean().default(false),
            threeDSecureData: z
                .union([ThreeDSecureDataV2$.outboundSchema, ThreeDSecureDataV1$.outboundSchema])
                .optional(),
            paymentServiceId: z.nullable(z.string()).default(null),
        })
        .transform((v) => {
            return {
                amount: v.amount,
                currency: v.currency,
                ...(v.paymentMethod === undefined ? null : { payment_method: v.paymentMethod }),
                anti_fraud_fingerprint: v.antiFraudFingerprint,
                async_capture: v.asyncCapture,
                ...(v.browserInfo === undefined ? null : { browser_info: v.browserInfo }),
                ...(v.buyerExternalIdentifier === undefined
                    ? null
                    : { buyer_external_identifier: v.buyerExternalIdentifier }),
                ...(v.buyerId === undefined ? null : { buyer_id: v.buyerId }),
                ...(v.cartItems === undefined ? null : { cart_items: v.cartItems }),
                ...(v.connectionOptions === undefined
                    ? null
                    : { connection_options: v.connectionOptions }),
                ...(v.country === undefined ? null : { country: v.country }),
                ...(v.externalIdentifier === undefined
                    ? null
                    : { external_identifier: v.externalIdentifier }),
                ...(v.giftCards === undefined ? null : { gift_cards: v.giftCards }),
                intent: v.intent,
                is_subsequent_payment: v.isSubsequentPayment,
                merchant_initiated: v.merchantInitiated,
                ...(v.metadata === undefined ? null : { metadata: v.metadata }),
                ...(v.paymentSource === undefined ? null : { payment_source: v.paymentSource }),
                previous_scheme_transaction_id: v.previousSchemeTransactionId,
                shipping_details_id: v.shippingDetailsId,
                ...(v.statementDescriptor === undefined
                    ? null
                    : { statement_descriptor: v.statementDescriptor }),
                store: v.store,
                ...(v.threeDSecureData === undefined
                    ? null
                    : { three_d_secure_data: v.threeDSecureData }),
                payment_service_id: v.paymentServiceId,
            };
        });
}
