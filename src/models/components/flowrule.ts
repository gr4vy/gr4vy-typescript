/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { FlowAmountCondition, FlowAmountCondition$ } from "./flowamountcondition";
import { FlowAmountRangeCondition, FlowAmountRangeCondition$ } from "./flowamountrangecondition";
import { FlowAmountZeroCondition, FlowAmountZeroCondition$ } from "./flowamountzerocondition";
import {
    FlowAntiFraudDecisionCondition,
    FlowAntiFraudDecisionCondition$,
} from "./flowantifrauddecisioncondition";
import { FlowBINRangeCondition, FlowBINRangeCondition$ } from "./flowbinrangecondition";
import {
    FlowBrowserLanguageCondition,
    FlowBrowserLanguageCondition$,
} from "./flowbrowserlanguagecondition";
import { FlowCardCountryCondition, FlowCardCountryCondition$ } from "./flowcardcountrycondition";
import { FlowCardSchemeCondition, FlowCardSchemeCondition$ } from "./flowcardschemecondition";
import { FlowCardSourceCondition, FlowCardSourceCondition$ } from "./flowcardsourcecondition";
import { FlowCardTypeCondition, FlowCardTypeCondition$ } from "./flowcardtypecondition";
import { FlowCountryCondition, FlowCountryCondition$ } from "./flowcountrycondition";
import { FlowCurrencyCondition, FlowCurrencyCondition$ } from "./flowcurrencycondition";
import {
    FlowIsSubsequentPaymentCondition,
    FlowIsSubsequentPaymentCondition$,
} from "./flowissubsequentpaymentcondition";
import {
    FlowMerchantInitiatedCondition,
    FlowMerchantInitiatedCondition$,
} from "./flowmerchantinitiatedcondition";
import { FlowMetadataCondition, FlowMetadataCondition$ } from "./flowmetadatacondition";
import {
    FlowPaymentMethodCondition,
    FlowPaymentMethodCondition$,
} from "./flowpaymentmethodcondition";
import {
    FlowPaymentMethodsCondition,
    FlowPaymentMethodsCondition$,
} from "./flowpaymentmethodscondition";
import {
    FlowPaymentSourceCondition,
    FlowPaymentSourceCondition$,
} from "./flowpaymentsourcecondition";
import {
    FlowProductCategoriesCondition,
    FlowProductCategoriesCondition$,
} from "./flowproductcategoriescondition";
import { FlowProductTypesCondition, FlowProductTypesCondition$ } from "./flowproducttypescondition";
import { FlowRuleBooleanOutcome, FlowRuleBooleanOutcome$ } from "./flowrulebooleanoutcome";
import { FlowRuleMethodOutcome, FlowRuleMethodOutcome$ } from "./flowrulemethodoutcome";
import { FlowRuleServiceOutcome, FlowRuleServiceOutcome$ } from "./flowruleserviceoutcome";
import {
    FlowRuleThreeDSecureOutcome,
    FlowRuleThreeDSecureOutcome$,
} from "./flowrulethreedsecureoutcome";
import { FlowRuleUUIDsListOutcome, FlowRuleUUIDsListOutcome$ } from "./flowruleuuidslistoutcome";
import { FlowSKUsCondition, FlowSKUsCondition$ } from "./flowskuscondition";
import * as z from "zod";

/**
 * The type of this resource. Is always `rule`.
 */
export enum FlowRuleType {
    Rule = "rule",
}

/**
 * The name of the Flow.
 */
export enum FlowRuleFlow {
    Checkout = "checkout",
    CardTransaction = "card-transaction",
    NonCardTransaction = "non-card-transaction",
    RedirectTransaction = "redirect-transaction",
}

/**
 * Action for the given rule. Actions can only be used in
 *
 * @remarks
 * flows that support them.
 *
 * * The `checkout` flow only supports the
 * `select-payment-options` action.
 * * The `card-transaction` supports the `route-transaction`,
 * `skip-3ds`, and `decline-early` actions.
 * * The `non-card-transaction` flow only supports the
 * `decline-early` action.
 * * The `redirect-transaction` flow only supports
 * the `route-transaction` action.
 *
 */
export enum FlowRuleAction {
    SelectPaymentOptions = "select-payment-options",
    DeclineEarly = "decline-early",
    RouteTransaction = "route-transaction",
    Skip3ds = "skip-3ds",
}

export type Conditions =
    | FlowAmountCondition
    | FlowAmountRangeCondition
    | FlowAmountZeroCondition
    | FlowAntiFraudDecisionCondition
    | FlowBINRangeCondition
    | FlowBrowserLanguageCondition
    | FlowCardCountryCondition
    | FlowCardSchemeCondition
    | FlowCardSourceCondition
    | FlowCardTypeCondition
    | FlowCountryCondition
    | FlowCurrencyCondition
    | FlowIsSubsequentPaymentCondition
    | FlowMetadataCondition
    | FlowMerchantInitiatedCondition
    | FlowPaymentMethodCondition
    | FlowPaymentMethodsCondition
    | FlowPaymentSourceCondition
    | FlowProductCategoriesCondition
    | FlowProductTypesCondition
    | FlowSKUsCondition;

export type FlowRuleOutcome =
    | FlowRuleMethodOutcome
    | FlowRuleBooleanOutcome
    | FlowRuleUUIDsListOutcome
    | FlowRuleThreeDSecureOutcome
    | FlowRuleServiceOutcome;

export type FlowRule = {
    /**
     * The type of this resource. Is always `rule`.
     */
    type?: FlowRuleType | undefined;
    /**
     * The unique Gr4vy ID for this rule.
     */
    id?: string | undefined;
    /**
     * The unique ID for a merchant account.
     */
    merchantAccountId?: string | undefined;
    /**
     * Description of the flow rule.
     */
    description?: string | null | undefined;
    /**
     * The name of the Flow.
     */
    flow?: FlowRuleFlow | undefined;
    /**
     * Action for the given rule. Actions can only be used in
     *
     * @remarks
     * flows that support them.
     *
     * * The `checkout` flow only supports the
     * `select-payment-options` action.
     * * The `card-transaction` supports the `route-transaction`,
     * `skip-3ds`, and `decline-early` actions.
     * * The `non-card-transaction` flow only supports the
     * `decline-early` action.
     * * The `redirect-transaction` flow only supports
     * the `route-transaction` action.
     *
     */
    action?: FlowRuleAction | undefined;
    /**
     * One or more conditions that apply for this rule. Each condition
     *
     * @remarks
     * needs to match for this rule to go into effect.
     */
    conditions?:
        | Array<
              | FlowAmountCondition
              | FlowAmountRangeCondition
              | FlowAmountZeroCondition
              | FlowAntiFraudDecisionCondition
              | FlowBINRangeCondition
              | FlowBrowserLanguageCondition
              | FlowCardCountryCondition
              | FlowCardSchemeCondition
              | FlowCardSourceCondition
              | FlowCardTypeCondition
              | FlowCountryCondition
              | FlowCurrencyCondition
              | FlowIsSubsequentPaymentCondition
              | FlowMetadataCondition
              | FlowMerchantInitiatedCondition
              | FlowPaymentMethodCondition
              | FlowPaymentMethodsCondition
              | FlowPaymentSourceCondition
              | FlowProductCategoriesCondition
              | FlowProductTypesCondition
              | FlowSKUsCondition
          >
        | undefined;
    outcome?:
        | FlowRuleMethodOutcome
        | FlowRuleBooleanOutcome
        | FlowRuleUUIDsListOutcome
        | FlowRuleThreeDSecureOutcome
        | FlowRuleServiceOutcome
        | undefined;
    /**
     * The position of the rule in the flow.
     */
    position?: number | undefined;
    /**
     * The date and time
     *
     * @remarks
     * when this buyer was created in our system.
     */
    createdAt?: Date | undefined;
    /**
     * The date and time
     *
     * @remarks
     * when this buyer was last updated in our system.
     */
    updatedAt?: Date | undefined;
};

/** @internal */
export namespace FlowRuleType$ {
    export const inboundSchema = z.nativeEnum(FlowRuleType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace FlowRuleFlow$ {
    export const inboundSchema = z.nativeEnum(FlowRuleFlow);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace FlowRuleAction$ {
    export const inboundSchema = z.nativeEnum(FlowRuleAction);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Conditions$ {
    export const inboundSchema: z.ZodType<Conditions, z.ZodTypeDef, unknown> = z.union([
        FlowAmountCondition$.inboundSchema,
        FlowAmountRangeCondition$.inboundSchema,
        FlowAmountZeroCondition$.inboundSchema,
        FlowAntiFraudDecisionCondition$.inboundSchema,
        FlowBINRangeCondition$.inboundSchema,
        FlowBrowserLanguageCondition$.inboundSchema,
        FlowCardCountryCondition$.inboundSchema,
        FlowCardSchemeCondition$.inboundSchema,
        FlowCardSourceCondition$.inboundSchema,
        FlowCardTypeCondition$.inboundSchema,
        FlowCountryCondition$.inboundSchema,
        FlowCurrencyCondition$.inboundSchema,
        FlowIsSubsequentPaymentCondition$.inboundSchema,
        FlowMetadataCondition$.inboundSchema,
        FlowMerchantInitiatedCondition$.inboundSchema,
        FlowPaymentMethodCondition$.inboundSchema,
        FlowPaymentMethodsCondition$.inboundSchema,
        FlowPaymentSourceCondition$.inboundSchema,
        FlowProductCategoriesCondition$.inboundSchema,
        FlowProductTypesCondition$.inboundSchema,
        FlowSKUsCondition$.inboundSchema,
    ]);

    export type Outbound =
        | FlowAmountCondition$.Outbound
        | FlowAmountRangeCondition$.Outbound
        | FlowAmountZeroCondition$.Outbound
        | FlowAntiFraudDecisionCondition$.Outbound
        | FlowBINRangeCondition$.Outbound
        | FlowBrowserLanguageCondition$.Outbound
        | FlowCardCountryCondition$.Outbound
        | FlowCardSchemeCondition$.Outbound
        | FlowCardSourceCondition$.Outbound
        | FlowCardTypeCondition$.Outbound
        | FlowCountryCondition$.Outbound
        | FlowCurrencyCondition$.Outbound
        | FlowIsSubsequentPaymentCondition$.Outbound
        | FlowMetadataCondition$.Outbound
        | FlowMerchantInitiatedCondition$.Outbound
        | FlowPaymentMethodCondition$.Outbound
        | FlowPaymentMethodsCondition$.Outbound
        | FlowPaymentSourceCondition$.Outbound
        | FlowProductCategoriesCondition$.Outbound
        | FlowProductTypesCondition$.Outbound
        | FlowSKUsCondition$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Conditions> = z.union([
        FlowAmountCondition$.outboundSchema,
        FlowAmountRangeCondition$.outboundSchema,
        FlowAmountZeroCondition$.outboundSchema,
        FlowAntiFraudDecisionCondition$.outboundSchema,
        FlowBINRangeCondition$.outboundSchema,
        FlowBrowserLanguageCondition$.outboundSchema,
        FlowCardCountryCondition$.outboundSchema,
        FlowCardSchemeCondition$.outboundSchema,
        FlowCardSourceCondition$.outboundSchema,
        FlowCardTypeCondition$.outboundSchema,
        FlowCountryCondition$.outboundSchema,
        FlowCurrencyCondition$.outboundSchema,
        FlowIsSubsequentPaymentCondition$.outboundSchema,
        FlowMetadataCondition$.outboundSchema,
        FlowMerchantInitiatedCondition$.outboundSchema,
        FlowPaymentMethodCondition$.outboundSchema,
        FlowPaymentMethodsCondition$.outboundSchema,
        FlowPaymentSourceCondition$.outboundSchema,
        FlowProductCategoriesCondition$.outboundSchema,
        FlowProductTypesCondition$.outboundSchema,
        FlowSKUsCondition$.outboundSchema,
    ]);
}

/** @internal */
export namespace FlowRuleOutcome$ {
    export const inboundSchema: z.ZodType<FlowRuleOutcome, z.ZodTypeDef, unknown> = z.union([
        FlowRuleMethodOutcome$.inboundSchema,
        FlowRuleBooleanOutcome$.inboundSchema,
        FlowRuleUUIDsListOutcome$.inboundSchema,
        FlowRuleThreeDSecureOutcome$.inboundSchema,
        FlowRuleServiceOutcome$.inboundSchema,
    ]);

    export type Outbound =
        | FlowRuleMethodOutcome$.Outbound
        | FlowRuleBooleanOutcome$.Outbound
        | FlowRuleUUIDsListOutcome$.Outbound
        | FlowRuleThreeDSecureOutcome$.Outbound
        | FlowRuleServiceOutcome$.Outbound;
    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, FlowRuleOutcome> = z.union([
        FlowRuleMethodOutcome$.outboundSchema,
        FlowRuleBooleanOutcome$.outboundSchema,
        FlowRuleUUIDsListOutcome$.outboundSchema,
        FlowRuleThreeDSecureOutcome$.outboundSchema,
        FlowRuleServiceOutcome$.outboundSchema,
    ]);
}

/** @internal */
export namespace FlowRule$ {
    export const inboundSchema: z.ZodType<FlowRule, z.ZodTypeDef, unknown> = z
        .object({
            type: FlowRuleType$.inboundSchema.optional(),
            id: z.string().optional(),
            merchant_account_id: z.string().optional(),
            description: z.nullable(z.string()).optional(),
            flow: FlowRuleFlow$.inboundSchema.optional(),
            action: FlowRuleAction$.inboundSchema.optional(),
            conditions: z
                .array(
                    z.union([
                        FlowAmountCondition$.inboundSchema,
                        FlowAmountRangeCondition$.inboundSchema,
                        FlowAmountZeroCondition$.inboundSchema,
                        FlowAntiFraudDecisionCondition$.inboundSchema,
                        FlowBINRangeCondition$.inboundSchema,
                        FlowBrowserLanguageCondition$.inboundSchema,
                        FlowCardCountryCondition$.inboundSchema,
                        FlowCardSchemeCondition$.inboundSchema,
                        FlowCardSourceCondition$.inboundSchema,
                        FlowCardTypeCondition$.inboundSchema,
                        FlowCountryCondition$.inboundSchema,
                        FlowCurrencyCondition$.inboundSchema,
                        FlowIsSubsequentPaymentCondition$.inboundSchema,
                        FlowMetadataCondition$.inboundSchema,
                        FlowMerchantInitiatedCondition$.inboundSchema,
                        FlowPaymentMethodCondition$.inboundSchema,
                        FlowPaymentMethodsCondition$.inboundSchema,
                        FlowPaymentSourceCondition$.inboundSchema,
                        FlowProductCategoriesCondition$.inboundSchema,
                        FlowProductTypesCondition$.inboundSchema,
                        FlowSKUsCondition$.inboundSchema,
                    ])
                )
                .optional(),
            outcome: z
                .union([
                    FlowRuleMethodOutcome$.inboundSchema,
                    FlowRuleBooleanOutcome$.inboundSchema,
                    FlowRuleUUIDsListOutcome$.inboundSchema,
                    FlowRuleThreeDSecureOutcome$.inboundSchema,
                    FlowRuleServiceOutcome$.inboundSchema,
                ])
                .optional(),
            position: z.number().optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            updated_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                merchant_account_id: "merchantAccountId",
                created_at: "createdAt",
                updated_at: "updatedAt",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        merchant_account_id?: string | undefined;
        description?: string | null | undefined;
        flow?: string | undefined;
        action?: string | undefined;
        conditions?:
            | Array<
                  | FlowAmountCondition$.Outbound
                  | FlowAmountRangeCondition$.Outbound
                  | FlowAmountZeroCondition$.Outbound
                  | FlowAntiFraudDecisionCondition$.Outbound
                  | FlowBINRangeCondition$.Outbound
                  | FlowBrowserLanguageCondition$.Outbound
                  | FlowCardCountryCondition$.Outbound
                  | FlowCardSchemeCondition$.Outbound
                  | FlowCardSourceCondition$.Outbound
                  | FlowCardTypeCondition$.Outbound
                  | FlowCountryCondition$.Outbound
                  | FlowCurrencyCondition$.Outbound
                  | FlowIsSubsequentPaymentCondition$.Outbound
                  | FlowMetadataCondition$.Outbound
                  | FlowMerchantInitiatedCondition$.Outbound
                  | FlowPaymentMethodCondition$.Outbound
                  | FlowPaymentMethodsCondition$.Outbound
                  | FlowPaymentSourceCondition$.Outbound
                  | FlowProductCategoriesCondition$.Outbound
                  | FlowProductTypesCondition$.Outbound
                  | FlowSKUsCondition$.Outbound
              >
            | undefined;
        outcome?:
            | FlowRuleMethodOutcome$.Outbound
            | FlowRuleBooleanOutcome$.Outbound
            | FlowRuleUUIDsListOutcome$.Outbound
            | FlowRuleThreeDSecureOutcome$.Outbound
            | FlowRuleServiceOutcome$.Outbound
            | undefined;
        position?: number | undefined;
        created_at?: string | undefined;
        updated_at?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, FlowRule> = z
        .object({
            type: FlowRuleType$.outboundSchema.optional(),
            id: z.string().optional(),
            merchantAccountId: z.string().optional(),
            description: z.nullable(z.string()).optional(),
            flow: FlowRuleFlow$.outboundSchema.optional(),
            action: FlowRuleAction$.outboundSchema.optional(),
            conditions: z
                .array(
                    z.union([
                        FlowAmountCondition$.outboundSchema,
                        FlowAmountRangeCondition$.outboundSchema,
                        FlowAmountZeroCondition$.outboundSchema,
                        FlowAntiFraudDecisionCondition$.outboundSchema,
                        FlowBINRangeCondition$.outboundSchema,
                        FlowBrowserLanguageCondition$.outboundSchema,
                        FlowCardCountryCondition$.outboundSchema,
                        FlowCardSchemeCondition$.outboundSchema,
                        FlowCardSourceCondition$.outboundSchema,
                        FlowCardTypeCondition$.outboundSchema,
                        FlowCountryCondition$.outboundSchema,
                        FlowCurrencyCondition$.outboundSchema,
                        FlowIsSubsequentPaymentCondition$.outboundSchema,
                        FlowMetadataCondition$.outboundSchema,
                        FlowMerchantInitiatedCondition$.outboundSchema,
                        FlowPaymentMethodCondition$.outboundSchema,
                        FlowPaymentMethodsCondition$.outboundSchema,
                        FlowPaymentSourceCondition$.outboundSchema,
                        FlowProductCategoriesCondition$.outboundSchema,
                        FlowProductTypesCondition$.outboundSchema,
                        FlowSKUsCondition$.outboundSchema,
                    ])
                )
                .optional(),
            outcome: z
                .union([
                    FlowRuleMethodOutcome$.outboundSchema,
                    FlowRuleBooleanOutcome$.outboundSchema,
                    FlowRuleUUIDsListOutcome$.outboundSchema,
                    FlowRuleThreeDSecureOutcome$.outboundSchema,
                    FlowRuleServiceOutcome$.outboundSchema,
                ])
                .optional(),
            position: z.number().optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            updatedAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                merchantAccountId: "merchant_account_id",
                createdAt: "created_at",
                updatedAt: "updated_at",
            });
        });
}
