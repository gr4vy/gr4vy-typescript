/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import { PaymentMethodDetailsCard, PaymentMethodDetailsCard$ } from "./paymentmethoddetailscard";
import * as z from "zod";

/**
 * `payment-method`.
 */
export enum PaymentMethodType {
    PaymentMethod = "payment-method",
}

export enum PaymentMethodAdditionalSchemes {
    Accel = "accel",
    Amex = "amex",
    Bancontact = "bancontact",
    CarteBancaire = "carte-bancaire",
    Cirrus = "cirrus",
    Culiance = "culiance",
    Dankort = "dankort",
    DinersClub = "diners-club",
    Discover = "discover",
    EftposAustralia = "eftpos-australia",
    Elo = "elo",
    Hipercard = "hipercard",
    Jcb = "jcb",
    Maestro = "maestro",
    Mastercard = "mastercard",
    Mir = "mir",
    Nyce = "nyce",
    Other = "other",
    Pulse = "pulse",
    Rupay = "rupay",
    Star = "star",
    Uatp = "uatp",
    Unionpay = "unionpay",
    Visa = "visa",
}

/**
 * The browser target that an approval URL must be opened in. If `any` or `null`, then there is no specific requirement.
 */
export enum PaymentMethodApprovalTarget {
    Any = "any",
    NewWindow = "new_window",
}

/**
 * The type of this resource. Is always `buyer`.
 */
export enum PaymentMethodBuyerType {
    Buyer = "buyer",
}

/**
 * The type of this resource. Is always `billing-details`.
 */
export enum PaymentMethodBuyerBillingDetailsType {
    BillingDetails = "billing-details",
}

/**
 * The billing address of the buyer.
 */
export type PaymentMethodAddress = {
    /**
     * The city for the address.
     */
    city?: string | null | undefined;
    /**
     * The country for the address in ISO 3166 format.
     */
    country?: string | null | undefined;
    /**
     * The postal code or zip code for the address.
     */
    postalCode?: string | null | undefined;
    /**
     * The state, county, or province for the address.
     */
    state?: string | null | undefined;
    /**
     * The code of state, county, or province for the address in
     *
     * @remarks
     * ISO 3166-2 format.
     */
    stateCode?: string | null | undefined;
    /**
     * The house number or name for the address. Not all payment
     *
     * @remarks
     * services use this field but some do.
     */
    houseNumberOrName?: string | null | undefined;
    /**
     * The first line of the address.
     */
    line1?: string | null | undefined;
    /**
     * The second line of the address.
     */
    line2?: string | null | undefined;
    /**
     * The optional name of the company or organisation to add
     *
     * @remarks
     * to the address.
     */
    organization?: string | null | undefined;
};

/**
 * The kind of tax ID.
 */
export enum PaymentMethodKind {
    AeTrn = "ae.trn",
    AuAbn = "au.abn",
    ArDni = "ar.dni",
    ArCuil = "ar.cuil",
    ArCuit = "ar.cuit",
    BrCnpj = "br.cnpj",
    BrCpf = "br.cpf",
    CaBn = "ca.bn",
    CaGstHst = "ca.gst_hst",
    CaPstBc = "ca.pst_bc",
    CaPstMb = "ca.pst_mb",
    CaPstSk = "ca.pst_sk",
    CaQst = "ca.qst",
    ChVat = "ch.vat",
    ClTin = "cl.tin",
    EsCif = "es.cif",
    EuVat = "eu.vat",
    GbVat = "gb.vat",
    HkBr = "hk.br",
    IdNik = "id.nik",
    IdNpwp = "id.npwp",
    InGst = "in.gst",
    JpCn = "jp.cn",
    JpRn = "jp.rn",
    KrBrn = "kr.brn",
    LiUid = "li.uid",
    MxCurp = "mx.curp",
    MyFrp = "my.frp",
    MyItn = "my.itn",
    MyNric = "my.nric",
    MySst = "my.sst",
    NoVat = "no.vat",
    NzGst = "nz.gst",
    PhTin = "ph.tin",
    RuInn = "ru.inn",
    RuKpp = "ru.kpp",
    SaVat = "sa.vat",
    SgGst = "sg.gst",
    SgUen = "sg.uen",
    ThId = "th.id",
    ThVat = "th.vat",
    TwVat = "tw.vat",
    UsEin = "us.ein",
    ZaVat = "za.vat",
}

/**
 * The tax information associated with the billing details.
 */
export type PaymentMethodTaxID = {
    /**
     * The tax ID for the buyer.
     */
    value: string;
    /**
     * The kind of tax ID.
     */
    kind: PaymentMethodKind;
};

/**
 * The billing details associated with a buyer.
 */
export type PaymentMethodBillingDetails = {
    /**
     * The type of this resource. Is always `billing-details`.
     */
    type?: PaymentMethodBuyerBillingDetailsType | undefined;
    /**
     * The first name(s) or given name of the buyer.
     */
    firstName?: string | null | undefined;
    /**
     * The last name, or family name, of the buyer.
     */
    lastName?: string | null | undefined;
    /**
     * The email address of the buyer.
     */
    emailAddress?: string | null | undefined;
    /**
     * The phone number of the buyer. This number is formatted according to the
     *
     * @remarks
     * [E164 number standard](https://www.twilio.com/docs/glossary/what-e164).
     */
    phoneNumber?: string | null | undefined;
    /**
     * The billing address of the buyer.
     */
    address?: PaymentMethodAddress | null | undefined;
    /**
     * The tax information associated with the billing details.
     */
    taxId?: PaymentMethodTaxID | null | undefined;
};

/**
 * The optional buyer for which this payment method has been stored.
 */
export type PaymentMethodBuyer = {
    /**
     * The type of this resource. Is always `buyer`.
     */
    type?: PaymentMethodBuyerType | undefined;
    /**
     * The unique Gr4vy ID for this buyer.
     */
    id?: string | undefined;
    /**
     * The billing details associated with a buyer.
     */
    billingDetails?: PaymentMethodBillingDetails | null | undefined;
    /**
     * The date and time
     *
     * @remarks
     * when this buyer was created in our system.
     */
    createdAt?: Date | undefined;
    /**
     * A unique name for this buyer which is used in the Gr4vy admin panel to give a buyer a human readable name.
     */
    displayName?: string | null | undefined;
    /**
     * An external identifier that can be used to match the buyer against your own records.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * The unique ID for a merchant account.
     */
    merchantAccountId?: string | undefined;
    /**
     * The date and time
     *
     * @remarks
     * when this buyer was last updated in our system.
     */
    updatedAt?: Date | undefined;
};

/**
 * The type of this payment method.
 */
export enum PaymentMethodMethod {
    Afterpay = "afterpay",
    Alipay = "alipay",
    Alipayhk = "alipayhk",
    Applepay = "applepay",
    Bacs = "bacs",
    Banked = "banked",
    Becs = "becs",
    Bitpay = "bitpay",
    Boleto = "boleto",
    Boost = "boost",
    Card = "card",
    Cashapp = "cashapp",
    Chaseorbital = "chaseorbital",
    CheckoutSession = "checkout-session",
    Clearpay = "clearpay",
    ClickToPay = "click-to-pay",
    Dana = "dana",
    Dcb = "dcb",
    Dlocal = "dlocal",
    Ebanx = "ebanx",
    Everydaypay = "everydaypay",
    Gcash = "gcash",
    Giropay = "giropay",
    Gocardless = "gocardless",
    Googlepay = "googlepay",
    Gopay = "gopay",
    Grabpay = "grabpay",
    Ideal = "ideal",
    Kakaopay = "kakaopay",
    Klarna = "klarna",
    Laybuy = "laybuy",
    Linkaja = "linkaja",
    Maybankqrpay = "maybankqrpay",
    Multibanco = "multibanco",
    Oney3x = "oney_3x",
    Oney4x = "oney_4x",
    Oney6x = "oney_6x",
    Oney10x = "oney_10x",
    Oney12x = "oney_12x",
    Ovo = "ovo",
    Oxxo = "oxxo",
    Payid = "payid",
    Paymaya = "paymaya",
    Paypal = "paypal",
    Paypalpaylater = "paypalpaylater",
    Payto = "payto",
    Venmo = "venmo",
    Pix = "pix",
    Rabbitlinepay = "rabbitlinepay",
    Scalapay = "scalapay",
    Sepa = "sepa",
    Shopeepay = "shopeepay",
    Singteldash = "singteldash",
    Sofort = "sofort",
    Stripedd = "stripedd",
    Thaiqr = "thaiqr",
    Touchngo = "touchngo",
    Truemoney = "truemoney",
    Trustly = "trustly",
    Trustlyeurope = "trustlyeurope",
    NetworkToken = "network-token",
    Givingblock = "givingblock",
    Wechat = "wechat",
    Zippay = "zippay",
    Bancontact = "bancontact",
    Eps = "eps",
    Linepay = "linepay",
    Razorpay = "razorpay",
    Multipago = "multipago",
    Waave = "waave",
    Smartpay = "smartpay",
    Vipps = "vipps",
}

/**
 * The mode to use with this payment method.
 */
export enum Mode {
    Card = "card",
    Redirect = "redirect",
    Applepay = "applepay",
    Googlepay = "googlepay",
}

/**
 * The scheme of the card. Only applies to card payments.
 */
export enum PaymentMethodScheme {
    Accel = "accel",
    Amex = "amex",
    Bancontact = "bancontact",
    CarteBancaire = "carte-bancaire",
    Cirrus = "cirrus",
    Culiance = "culiance",
    Dankort = "dankort",
    DinersClub = "diners-club",
    Discover = "discover",
    EftposAustralia = "eftpos-australia",
    Elo = "elo",
    Hipercard = "hipercard",
    Jcb = "jcb",
    Maestro = "maestro",
    Mastercard = "mastercard",
    Mir = "mir",
    Nyce = "nyce",
    Other = "other",
    Pulse = "pulse",
    Rupay = "rupay",
    Star = "star",
    Uatp = "uatp",
    Unionpay = "unionpay",
    Visa = "visa",
}

/**
 * The state of the payment method.
 *
 * @remarks
 *
 * - `processing` - The payment method is stored but has not been used yet.
 * - `buyer_approval_required` - Storing the payment method requires
 *   the buyer to provide approval. Follow the `approval_url` for next steps.
 * - `succeeded` - The payment method is stored and has been used.
 * - `failed` - The payment method could not be stored, or failed first use.
 */
export enum Status {
    Processing = "processing",
    BuyerApprovalRequired = "buyer_approval_required",
    Succeeded = "succeeded",
    Failed = "failed",
}

/**
 * A generic payment method.
 */
export type PaymentMethod = {
    /**
     * `payment-method`.
     */
    type?: PaymentMethodType | undefined;
    /**
     * The unique ID of the payment method.
     */
    id?: string | undefined;
    /**
     * Additional schemes of the card. Only applies to card payment methods.
     */
    additionalSchemes?: Array<PaymentMethodAdditionalSchemes> | null | undefined;
    /**
     * The browser target that an approval URL must be opened in. If `any` or `null`, then there is no specific requirement.
     */
    approvalTarget?: PaymentMethodApprovalTarget | null | undefined;
    /**
     * The optional URL that the buyer needs to be redirected to to further authorize their payment.
     */
    approvalUrl?: string | null | undefined;
    /**
     * The optional buyer for which this payment method has been stored.
     */
    buyer?: PaymentMethodBuyer | null | undefined;
    /**
     * The 2-letter ISO code of the country this payment method can
     *
     * @remarks
     * be used for. If this value is `null` the payment method may be
     * used in multiple countries.
     */
    country?: string | null | undefined;
    /**
     * The date and time when this payment method was first created in our
     *
     * @remarks
     * system.
     */
    createdAt?: Date | undefined;
    /**
     * The ISO-4217 currency code that this payment method can be
     *
     * @remarks
     * used for. If this value is `null` the payment method may be
     * used for multiple currencies.
     */
    currency?: string | null | undefined;
    /**
     * A credit or debit card payment method.
     */
    details?: PaymentMethodDetailsCard | undefined;
    /**
     * The expiration date for the payment method.
     */
    expirationDate?: string | null | undefined;
    /**
     * An external identifier that can be used to match the payment method
     *
     * @remarks
     * against your own records.
     */
    externalIdentifier?: string | null | undefined;
    /**
     * Whether this card has a pending replacement that hasn't been applied yet.
     *
     * @remarks
     *
     * When the Account Updater determines that new card details are available, existing details are not
     * changed immediately, but this field is set to `true`. There are three scenarios in which the actual
     * replacement occurs:
     *
     * 1. When this card has expired.
     * 2. When only the expiration date changed.
     * 3. When a transaction using this card is declined with any of the following codes:
     *     * `canceled_payment_method`
     *     * `expired_payment_method`
     *     * `unavailable_payment_method`
     *     * `unknown_payment_method`
     *
     * When the replacement is applied, this field is set to `false`.
     * For non-card payment methods, the value of this field is always set to `false`.
     */
    hasReplacement?: boolean | undefined;
    /**
     * A label for the card or the account. For a `paypal` payment method this
     *
     * @remarks
     * is the user's email address. For a card it is the last 4 digits of the
     * card.
     */
    label?: string | null | undefined;
    /**
     * The date and time when this card was last replaced.
     *
     * @remarks
     *
     * When the Account Updater determines that new card details are available, existing details are not
     * changed immediately. There are three scenarios in which the actual replacement occurs:
     *
     * 1. When this card has expired.
     * 2. When only the expiration date changed.
     * 3. When a transaction using this card is declined with any of the following codes:
     *     * `canceled_payment_method`
     *     * `expired_payment_method`
     *     * `unavailable_payment_method`
     *     * `unknown_payment_method`
     *
     * When the replacement is applied, this field is updated.
     * For non-card payment methods, the value of this field is always set to `null`.
     */
    lastReplacedAt?: Date | null | undefined;
    /**
     * The unique ID for a merchant account.
     */
    merchantAccountId?: string | undefined;
    /**
     * The type of this payment method.
     */
    method?: PaymentMethodMethod | undefined;
    /**
     * The mode to use with this payment method.
     */
    mode?: Mode | undefined;
    /**
     * The scheme of the card. Only applies to card payments.
     */
    scheme?: PaymentMethodScheme | null | undefined;
    /**
     * The state of the payment method.
     *
     * @remarks
     *
     * - `processing` - The payment method is stored but has not been used yet.
     * - `buyer_approval_required` - Storing the payment method requires
     *   the buyer to provide approval. Follow the `approval_url` for next steps.
     * - `succeeded` - The payment method is stored and has been used.
     * - `failed` - The payment method could not be stored, or failed first use.
     */
    status?: Status | undefined;
    /**
     * The date and time when this payment method was last updated in our system.
     */
    updatedAt?: Date | undefined;
    /**
     * The unique hash derived from the payment method identifier (e.g. card number).
     */
    fingerprint?: string | null | undefined;
};

/** @internal */
export namespace PaymentMethodType$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodAdditionalSchemes$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodAdditionalSchemes);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodApprovalTarget$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodApprovalTarget);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodBuyerType$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodBuyerType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodBuyerBillingDetailsType$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodBuyerBillingDetailsType);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodAddress$ {
    export const inboundSchema: z.ZodType<PaymentMethodAddress, z.ZodTypeDef, unknown> = z
        .object({
            city: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            postal_code: z.nullable(z.string()).optional(),
            state: z.nullable(z.string()).optional(),
            state_code: z.nullable(z.string()).optional(),
            house_number_or_name: z.nullable(z.string()).optional(),
            line1: z.nullable(z.string()).optional(),
            line2: z.nullable(z.string()).optional(),
            organization: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                postal_code: "postalCode",
                state_code: "stateCode",
                house_number_or_name: "houseNumberOrName",
            });
        });

    export type Outbound = {
        city?: string | null | undefined;
        country?: string | null | undefined;
        postal_code?: string | null | undefined;
        state?: string | null | undefined;
        state_code?: string | null | undefined;
        house_number_or_name?: string | null | undefined;
        line1?: string | null | undefined;
        line2?: string | null | undefined;
        organization?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodAddress> = z
        .object({
            city: z.nullable(z.string()).optional(),
            country: z.nullable(z.string()).optional(),
            postalCode: z.nullable(z.string()).optional(),
            state: z.nullable(z.string()).optional(),
            stateCode: z.nullable(z.string()).optional(),
            houseNumberOrName: z.nullable(z.string()).optional(),
            line1: z.nullable(z.string()).optional(),
            line2: z.nullable(z.string()).optional(),
            organization: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                postalCode: "postal_code",
                stateCode: "state_code",
                houseNumberOrName: "house_number_or_name",
            });
        });
}

/** @internal */
export namespace PaymentMethodKind$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodKind);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodTaxID$ {
    export const inboundSchema: z.ZodType<PaymentMethodTaxID, z.ZodTypeDef, unknown> = z.object({
        value: z.string(),
        kind: PaymentMethodKind$.inboundSchema,
    });

    export type Outbound = {
        value: string;
        kind: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodTaxID> = z.object({
        value: z.string(),
        kind: PaymentMethodKind$.outboundSchema,
    });
}

/** @internal */
export namespace PaymentMethodBillingDetails$ {
    export const inboundSchema: z.ZodType<PaymentMethodBillingDetails, z.ZodTypeDef, unknown> = z
        .object({
            type: PaymentMethodBuyerBillingDetailsType$.inboundSchema.optional(),
            first_name: z.nullable(z.string()).optional(),
            last_name: z.nullable(z.string()).optional(),
            email_address: z.nullable(z.string()).optional(),
            phone_number: z.nullable(z.string()).optional(),
            address: z.nullable(z.lazy(() => PaymentMethodAddress$.inboundSchema)).optional(),
            tax_id: z.nullable(z.lazy(() => PaymentMethodTaxID$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                first_name: "firstName",
                last_name: "lastName",
                email_address: "emailAddress",
                phone_number: "phoneNumber",
                tax_id: "taxId",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        first_name?: string | null | undefined;
        last_name?: string | null | undefined;
        email_address?: string | null | undefined;
        phone_number?: string | null | undefined;
        address?: PaymentMethodAddress$.Outbound | null | undefined;
        tax_id?: PaymentMethodTaxID$.Outbound | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodBillingDetails> = z
        .object({
            type: PaymentMethodBuyerBillingDetailsType$.outboundSchema.optional(),
            firstName: z.nullable(z.string()).optional(),
            lastName: z.nullable(z.string()).optional(),
            emailAddress: z.nullable(z.string()).optional(),
            phoneNumber: z.nullable(z.string()).optional(),
            address: z.nullable(z.lazy(() => PaymentMethodAddress$.outboundSchema)).optional(),
            taxId: z.nullable(z.lazy(() => PaymentMethodTaxID$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                firstName: "first_name",
                lastName: "last_name",
                emailAddress: "email_address",
                phoneNumber: "phone_number",
                taxId: "tax_id",
            });
        });
}

/** @internal */
export namespace PaymentMethodBuyer$ {
    export const inboundSchema: z.ZodType<PaymentMethodBuyer, z.ZodTypeDef, unknown> = z
        .object({
            type: PaymentMethodBuyerType$.inboundSchema.optional(),
            id: z.string().optional(),
            billing_details: z
                .nullable(z.lazy(() => PaymentMethodBillingDetails$.inboundSchema))
                .optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            display_name: z.nullable(z.string()).optional(),
            external_identifier: z.nullable(z.string()).optional(),
            merchant_account_id: z.string().optional(),
            updated_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                billing_details: "billingDetails",
                created_at: "createdAt",
                display_name: "displayName",
                external_identifier: "externalIdentifier",
                merchant_account_id: "merchantAccountId",
                updated_at: "updatedAt",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        billing_details?: PaymentMethodBillingDetails$.Outbound | null | undefined;
        created_at?: string | undefined;
        display_name?: string | null | undefined;
        external_identifier?: string | null | undefined;
        merchant_account_id?: string | undefined;
        updated_at?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethodBuyer> = z
        .object({
            type: PaymentMethodBuyerType$.outboundSchema.optional(),
            id: z.string().optional(),
            billingDetails: z
                .nullable(z.lazy(() => PaymentMethodBillingDetails$.outboundSchema))
                .optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            displayName: z.nullable(z.string()).optional(),
            externalIdentifier: z.nullable(z.string()).optional(),
            merchantAccountId: z.string().optional(),
            updatedAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
        })
        .transform((v) => {
            return remap$(v, {
                billingDetails: "billing_details",
                createdAt: "created_at",
                displayName: "display_name",
                externalIdentifier: "external_identifier",
                merchantAccountId: "merchant_account_id",
                updatedAt: "updated_at",
            });
        });
}

/** @internal */
export namespace PaymentMethodMethod$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodMethod);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Mode$ {
    export const inboundSchema = z.nativeEnum(Mode);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethodScheme$ {
    export const inboundSchema = z.nativeEnum(PaymentMethodScheme);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Status$ {
    export const inboundSchema = z.nativeEnum(Status);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace PaymentMethod$ {
    export const inboundSchema: z.ZodType<PaymentMethod, z.ZodTypeDef, unknown> = z
        .object({
            type: PaymentMethodType$.inboundSchema.optional(),
            id: z.string().optional(),
            additional_schemes: z
                .nullable(z.array(PaymentMethodAdditionalSchemes$.inboundSchema))
                .optional(),
            approval_target: z.nullable(PaymentMethodApprovalTarget$.inboundSchema).optional(),
            approval_url: z.nullable(z.string()).optional(),
            buyer: z.nullable(z.lazy(() => PaymentMethodBuyer$.inboundSchema)).optional(),
            country: z.nullable(z.string()).optional(),
            created_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            currency: z.nullable(z.string()).optional(),
            details: PaymentMethodDetailsCard$.inboundSchema.optional(),
            expiration_date: z.nullable(z.string()).optional(),
            external_identifier: z.nullable(z.string()).optional(),
            has_replacement: z.boolean().optional(),
            label: z.nullable(z.string()).optional(),
            last_replaced_at: z
                .nullable(
                    z
                        .string()
                        .datetime({ offset: true })
                        .transform((v) => new Date(v))
                )
                .optional(),
            merchant_account_id: z.string().optional(),
            method: PaymentMethodMethod$.inboundSchema.optional(),
            mode: Mode$.inboundSchema.optional(),
            scheme: z.nullable(PaymentMethodScheme$.inboundSchema).optional(),
            status: Status$.inboundSchema.optional(),
            updated_at: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
            fingerprint: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                additional_schemes: "additionalSchemes",
                approval_target: "approvalTarget",
                approval_url: "approvalUrl",
                created_at: "createdAt",
                expiration_date: "expirationDate",
                external_identifier: "externalIdentifier",
                has_replacement: "hasReplacement",
                last_replaced_at: "lastReplacedAt",
                merchant_account_id: "merchantAccountId",
                updated_at: "updatedAt",
            });
        });

    export type Outbound = {
        type?: string | undefined;
        id?: string | undefined;
        additional_schemes?: Array<string> | null | undefined;
        approval_target?: string | null | undefined;
        approval_url?: string | null | undefined;
        buyer?: PaymentMethodBuyer$.Outbound | null | undefined;
        country?: string | null | undefined;
        created_at?: string | undefined;
        currency?: string | null | undefined;
        details?: PaymentMethodDetailsCard$.Outbound | undefined;
        expiration_date?: string | null | undefined;
        external_identifier?: string | null | undefined;
        has_replacement?: boolean | undefined;
        label?: string | null | undefined;
        last_replaced_at?: string | null | undefined;
        merchant_account_id?: string | undefined;
        method?: string | undefined;
        mode?: string | undefined;
        scheme?: string | null | undefined;
        status?: string | undefined;
        updated_at?: string | undefined;
        fingerprint?: string | null | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PaymentMethod> = z
        .object({
            type: PaymentMethodType$.outboundSchema.optional(),
            id: z.string().optional(),
            additionalSchemes: z
                .nullable(z.array(PaymentMethodAdditionalSchemes$.outboundSchema))
                .optional(),
            approvalTarget: z.nullable(PaymentMethodApprovalTarget$.outboundSchema).optional(),
            approvalUrl: z.nullable(z.string()).optional(),
            buyer: z.nullable(z.lazy(() => PaymentMethodBuyer$.outboundSchema)).optional(),
            country: z.nullable(z.string()).optional(),
            createdAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            currency: z.nullable(z.string()).optional(),
            details: PaymentMethodDetailsCard$.outboundSchema.optional(),
            expirationDate: z.nullable(z.string()).optional(),
            externalIdentifier: z.nullable(z.string()).optional(),
            hasReplacement: z.boolean().optional(),
            label: z.nullable(z.string()).optional(),
            lastReplacedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
            merchantAccountId: z.string().optional(),
            method: PaymentMethodMethod$.outboundSchema.optional(),
            mode: Mode$.outboundSchema.optional(),
            scheme: z.nullable(PaymentMethodScheme$.outboundSchema).optional(),
            status: Status$.outboundSchema.optional(),
            updatedAt: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
            fingerprint: z.nullable(z.string()).optional(),
        })
        .transform((v) => {
            return remap$(v, {
                additionalSchemes: "additional_schemes",
                approvalTarget: "approval_target",
                approvalUrl: "approval_url",
                createdAt: "created_at",
                expirationDate: "expiration_date",
                externalIdentifier: "external_identifier",
                hasReplacement: "has_replacement",
                lastReplacedAt: "last_replaced_at",
                merchantAccountId: "merchant_account_id",
                updatedAt: "updated_at",
            });
        });
}
